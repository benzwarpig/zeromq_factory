// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TuyaDpMessage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TuyaDpMessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TuyaDpMessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Points.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TuyaDpMessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TuyaDpMessage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TuyaDpMessage_2eproto;
namespace LSLAM {
class CleanDeviceMsg;
struct CleanDeviceMsgDefaultTypeInternal;
extern CleanDeviceMsgDefaultTypeInternal _CleanDeviceMsg_default_instance_;
class CleanRecordMsg;
struct CleanRecordMsgDefaultTypeInternal;
extern CleanRecordMsgDefaultTypeInternal _CleanRecordMsg_default_instance_;
class DeviceMsg;
struct DeviceMsgDefaultTypeInternal;
extern DeviceMsgDefaultTypeInternal _DeviceMsg_default_instance_;
class LanguagePackMsg;
struct LanguagePackMsgDefaultTypeInternal;
extern LanguagePackMsgDefaultTypeInternal _LanguagePackMsg_default_instance_;
class RobotStatusMsg;
struct RobotStatusMsgDefaultTypeInternal;
extern RobotStatusMsgDefaultTypeInternal _RobotStatusMsg_default_instance_;
class TuyaCommandMsg;
struct TuyaCommandMsgDefaultTypeInternal;
extern TuyaCommandMsgDefaultTypeInternal _TuyaCommandMsg_default_instance_;
class TuyaDpMsg;
struct TuyaDpMsgDefaultTypeInternal;
extern TuyaDpMsgDefaultTypeInternal _TuyaDpMsg_default_instance_;
class TuyaSettingMsg;
struct TuyaSettingMsgDefaultTypeInternal;
extern TuyaSettingMsgDefaultTypeInternal _TuyaSettingMsg_default_instance_;
}  // namespace LSLAM
PROTOBUF_NAMESPACE_OPEN
template<> ::LSLAM::CleanDeviceMsg* Arena::CreateMaybeMessage<::LSLAM::CleanDeviceMsg>(Arena*);
template<> ::LSLAM::CleanRecordMsg* Arena::CreateMaybeMessage<::LSLAM::CleanRecordMsg>(Arena*);
template<> ::LSLAM::DeviceMsg* Arena::CreateMaybeMessage<::LSLAM::DeviceMsg>(Arena*);
template<> ::LSLAM::LanguagePackMsg* Arena::CreateMaybeMessage<::LSLAM::LanguagePackMsg>(Arena*);
template<> ::LSLAM::RobotStatusMsg* Arena::CreateMaybeMessage<::LSLAM::RobotStatusMsg>(Arena*);
template<> ::LSLAM::TuyaCommandMsg* Arena::CreateMaybeMessage<::LSLAM::TuyaCommandMsg>(Arena*);
template<> ::LSLAM::TuyaDpMsg* Arena::CreateMaybeMessage<::LSLAM::TuyaDpMsg>(Arena*);
template<> ::LSLAM::TuyaSettingMsg* Arena::CreateMaybeMessage<::LSLAM::TuyaSettingMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace LSLAM {

enum TuyaCommandMsg_COMMAND : int {
  TuyaCommandMsg_COMMAND_clean_command = 0,
  TuyaCommandMsg_COMMAND_pause_command = 1,
  TuyaCommandMsg_COMMAND_recharge_command = 2,
  TuyaCommandMsg_COMMAND_select_area_clean = 3,
  TuyaCommandMsg_COMMAND_aim_point_clean = 4,
  TuyaCommandMsg_COMMAND_plan_area_clean = 5,
  TuyaCommandMsg_COMMAND_over_task = 6,
  TuyaCommandMsg_COMMAND_remote_control = 7,
  TuyaCommandMsg_COMMAND_look_for_robot = 8,
  TuyaCommandMsg_COMMAND_explore = 9,
  TuyaCommandMsg_COMMAND_TuyaCommandMsg_COMMAND_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaCommandMsg_COMMAND_TuyaCommandMsg_COMMAND_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaCommandMsg_COMMAND_IsValid(int value);
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg_COMMAND_COMMAND_MIN = TuyaCommandMsg_COMMAND_clean_command;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg_COMMAND_COMMAND_MAX = TuyaCommandMsg_COMMAND_explore;
constexpr int TuyaCommandMsg_COMMAND_COMMAND_ARRAYSIZE = TuyaCommandMsg_COMMAND_COMMAND_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_COMMAND_descriptor();
template<typename T>
inline const std::string& TuyaCommandMsg_COMMAND_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaCommandMsg_COMMAND>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaCommandMsg_COMMAND_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaCommandMsg_COMMAND_descriptor(), enum_t_value);
}
inline bool TuyaCommandMsg_COMMAND_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaCommandMsg_COMMAND* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaCommandMsg_COMMAND>(
    TuyaCommandMsg_COMMAND_descriptor(), name, value);
}
enum TuyaCommandMsg_RemoteControlDirection : int {
  TuyaCommandMsg_RemoteControlDirection_DEFAIL = 0,
  TuyaCommandMsg_RemoteControlDirection_FORWARD = 1,
  TuyaCommandMsg_RemoteControlDirection_BACKWARD = 2,
  TuyaCommandMsg_RemoteControlDirection_TRUN_LEFT = 3,
  TuyaCommandMsg_RemoteControlDirection_TURN_RIGHT = 4,
  TuyaCommandMsg_RemoteControlDirection_STOP = 5,
  TuyaCommandMsg_RemoteControlDirection_TuyaCommandMsg_RemoteControlDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaCommandMsg_RemoteControlDirection_TuyaCommandMsg_RemoteControlDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaCommandMsg_RemoteControlDirection_IsValid(int value);
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_MIN = TuyaCommandMsg_RemoteControlDirection_DEFAIL;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_MAX = TuyaCommandMsg_RemoteControlDirection_STOP;
constexpr int TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_ARRAYSIZE = TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_RemoteControlDirection_descriptor();
template<typename T>
inline const std::string& TuyaCommandMsg_RemoteControlDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaCommandMsg_RemoteControlDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaCommandMsg_RemoteControlDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaCommandMsg_RemoteControlDirection_descriptor(), enum_t_value);
}
inline bool TuyaCommandMsg_RemoteControlDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaCommandMsg_RemoteControlDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaCommandMsg_RemoteControlDirection>(
    TuyaCommandMsg_RemoteControlDirection_descriptor(), name, value);
}
enum TuyaCommandMsg_SuctionLevel : int {
  TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_CLOSE = 0,
  TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_MUTE = 1,
  TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_NORMAL = 2,
  TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_STRONG = 3,
  TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_SUPER_STRONG = 4,
  TuyaCommandMsg_SuctionLevel_TuyaCommandMsg_SuctionLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaCommandMsg_SuctionLevel_TuyaCommandMsg_SuctionLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaCommandMsg_SuctionLevel_IsValid(int value);
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg_SuctionLevel_SuctionLevel_MIN = TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_CLOSE;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg_SuctionLevel_SuctionLevel_MAX = TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_SUPER_STRONG;
constexpr int TuyaCommandMsg_SuctionLevel_SuctionLevel_ARRAYSIZE = TuyaCommandMsg_SuctionLevel_SuctionLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_SuctionLevel_descriptor();
template<typename T>
inline const std::string& TuyaCommandMsg_SuctionLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaCommandMsg_SuctionLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaCommandMsg_SuctionLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaCommandMsg_SuctionLevel_descriptor(), enum_t_value);
}
inline bool TuyaCommandMsg_SuctionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaCommandMsg_SuctionLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaCommandMsg_SuctionLevel>(
    TuyaCommandMsg_SuctionLevel_descriptor(), name, value);
}
enum TuyaCommandMsg_WaterVolumeLevel : int {
  TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_CLOSE = 0,
  TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_ONE = 1,
  TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_TWO = 2,
  TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_THREE = 3,
  TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_NOT_SET = 4,
  TuyaCommandMsg_WaterVolumeLevel_TuyaCommandMsg_WaterVolumeLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaCommandMsg_WaterVolumeLevel_TuyaCommandMsg_WaterVolumeLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaCommandMsg_WaterVolumeLevel_IsValid(int value);
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_MIN = TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_CLOSE;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_MAX = TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_NOT_SET;
constexpr int TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_ARRAYSIZE = TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_WaterVolumeLevel_descriptor();
template<typename T>
inline const std::string& TuyaCommandMsg_WaterVolumeLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaCommandMsg_WaterVolumeLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaCommandMsg_WaterVolumeLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaCommandMsg_WaterVolumeLevel_descriptor(), enum_t_value);
}
inline bool TuyaCommandMsg_WaterVolumeLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaCommandMsg_WaterVolumeLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaCommandMsg_WaterVolumeLevel>(
    TuyaCommandMsg_WaterVolumeLevel_descriptor(), name, value);
}
enum TuyaSettingMsg_SET : int {
  TuyaSettingMsg_SET_set_virtual_wall = 0,
  TuyaSettingMsg_SET_set_penalty_area = 1,
  TuyaSettingMsg_SET_partition_segmentation = 2,
  TuyaSettingMsg_SET_partition_merge = 4,
  TuyaSettingMsg_SET_partition_restore_the_default = 5,
  TuyaSettingMsg_SET_set_room_properties = 6,
  TuyaSettingMsg_SET_room_named = 7,
  TuyaSettingMsg_SET_clean_order = 8,
  TuyaSettingMsg_SET_reset_map = 9,
  TuyaSettingMsg_SET_timing_clean = 10,
  TuyaSettingMsg_SET_save_map_to_cloud = 11,
  TuyaSettingMsg_SET_save_map_to_local = 12,
  TuyaSettingMsg_SET_do_not_disturb = 13,
  TuyaSettingMsg_SET_reset_edge_brush = 14,
  TuyaSettingMsg_SET_reset_roll_brush = 15,
  TuyaSettingMsg_SET_reset_filter = 16,
  TuyaSettingMsg_SET_rag_life_reset = 17,
  TuyaSettingMsg_SET_set_pack_language = 18,
  TuyaSettingMsg_SET_volume_set = 19,
  TuyaSettingMsg_SET_do_not_disturb_switch = 20,
  TuyaSettingMsg_SET_set_fan_motor = 21,
  TuyaSettingMsg_SET_set_water_box_motor = 22,
  TuyaSettingMsg_SET_TuyaSettingMsg_SET_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_SET_TuyaSettingMsg_SET_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_SET_IsValid(int value);
constexpr TuyaSettingMsg_SET TuyaSettingMsg_SET_SET_MIN = TuyaSettingMsg_SET_set_virtual_wall;
constexpr TuyaSettingMsg_SET TuyaSettingMsg_SET_SET_MAX = TuyaSettingMsg_SET_set_water_box_motor;
constexpr int TuyaSettingMsg_SET_SET_ARRAYSIZE = TuyaSettingMsg_SET_SET_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_SET_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_SET_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_SET>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_SET_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_SET_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_SET_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_SET* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_SET>(
    TuyaSettingMsg_SET_descriptor(), name, value);
}
enum TuyaSettingMsg_CleanMode : int {
  TuyaSettingMsg_CleanMode_CLEAN = 0,
  TuyaSettingMsg_CleanMode_SWEEP = 1,
  TuyaSettingMsg_CleanMode_CLEAN_AND_SWEEP = 2,
  TuyaSettingMsg_CleanMode_TuyaSettingMsg_CleanMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_CleanMode_TuyaSettingMsg_CleanMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_CleanMode_IsValid(int value);
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg_CleanMode_CleanMode_MIN = TuyaSettingMsg_CleanMode_CLEAN;
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg_CleanMode_CleanMode_MAX = TuyaSettingMsg_CleanMode_CLEAN_AND_SWEEP;
constexpr int TuyaSettingMsg_CleanMode_CleanMode_ARRAYSIZE = TuyaSettingMsg_CleanMode_CleanMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_CleanMode_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_CleanMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_CleanMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_CleanMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_CleanMode_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_CleanMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_CleanMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_CleanMode>(
    TuyaSettingMsg_CleanMode_descriptor(), name, value);
}
enum TuyaSettingMsg_CleanMotorState : int {
  TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_CLOSE = 0,
  TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_OPEN = 1,
  TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_LOW = 2,
  TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_MEDIUM = 3,
  TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_HIGH = 4,
  TuyaSettingMsg_CleanMotorState_TuyaSettingMsg_CleanMotorState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_CleanMotorState_TuyaSettingMsg_CleanMotorState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_CleanMotorState_IsValid(int value);
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg_CleanMotorState_CleanMotorState_MIN = TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_CLOSE;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg_CleanMotorState_CleanMotorState_MAX = TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_HIGH;
constexpr int TuyaSettingMsg_CleanMotorState_CleanMotorState_ARRAYSIZE = TuyaSettingMsg_CleanMotorState_CleanMotorState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_CleanMotorState_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_CleanMotorState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_CleanMotorState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_CleanMotorState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_CleanMotorState_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_CleanMotorState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_CleanMotorState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_CleanMotorState>(
    TuyaSettingMsg_CleanMotorState_descriptor(), name, value);
}
enum TuyaSettingMsg_FanMotorLevel : int {
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_CLOSE = 0,
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_MUTE = 1,
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_NORMAL = 2,
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_STRONG = 3,
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_SUPER_STRONG = 4,
  TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_NOT_SET = 5,
  TuyaSettingMsg_FanMotorLevel_TuyaSettingMsg_FanMotorLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_FanMotorLevel_TuyaSettingMsg_FanMotorLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_FanMotorLevel_IsValid(int value);
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg_FanMotorLevel_FanMotorLevel_MIN = TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_CLOSE;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg_FanMotorLevel_FanMotorLevel_MAX = TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_NOT_SET;
constexpr int TuyaSettingMsg_FanMotorLevel_FanMotorLevel_ARRAYSIZE = TuyaSettingMsg_FanMotorLevel_FanMotorLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_FanMotorLevel_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_FanMotorLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_FanMotorLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_FanMotorLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_FanMotorLevel_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_FanMotorLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_FanMotorLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_FanMotorLevel>(
    TuyaSettingMsg_FanMotorLevel_descriptor(), name, value);
}
enum TuyaSettingMsg_WaterBoxLevel : int {
  TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_CLOSE = 0,
  TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_ONE = 1,
  TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_TWO = 2,
  TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_THREE = 3,
  TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_NOT_SET = 4,
  TuyaSettingMsg_WaterBoxLevel_TuyaSettingMsg_WaterBoxLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_WaterBoxLevel_TuyaSettingMsg_WaterBoxLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_WaterBoxLevel_IsValid(int value);
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_MIN = TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_CLOSE;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_MAX = TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_NOT_SET;
constexpr int TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_ARRAYSIZE = TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_WaterBoxLevel_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_WaterBoxLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_WaterBoxLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_WaterBoxLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_WaterBoxLevel_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_WaterBoxLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_WaterBoxLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_WaterBoxLevel>(
    TuyaSettingMsg_WaterBoxLevel_descriptor(), name, value);
}
enum TuyaSettingMsg_YtypeSweep : int {
  TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_CLOSE = 0,
  TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_OPEN = 1,
  TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_NOT_SET = 2,
  TuyaSettingMsg_YtypeSweep_TuyaSettingMsg_YtypeSweep_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_YtypeSweep_TuyaSettingMsg_YtypeSweep_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_YtypeSweep_IsValid(int value);
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg_YtypeSweep_YtypeSweep_MIN = TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_CLOSE;
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg_YtypeSweep_YtypeSweep_MAX = TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_NOT_SET;
constexpr int TuyaSettingMsg_YtypeSweep_YtypeSweep_ARRAYSIZE = TuyaSettingMsg_YtypeSweep_YtypeSweep_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_YtypeSweep_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_YtypeSweep_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_YtypeSweep>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_YtypeSweep_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_YtypeSweep_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_YtypeSweep_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_YtypeSweep* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_YtypeSweep>(
    TuyaSettingMsg_YtypeSweep_descriptor(), name, value);
}
enum TuyaSettingMsg_PenaltyAreaMode : int {
  TuyaSettingMsg_PenaltyAreaMode_ban_clean_and_sweep = 0,
  TuyaSettingMsg_PenaltyAreaMode_ban_clean = 1,
  TuyaSettingMsg_PenaltyAreaMode_ban_sweep = 2,
  TuyaSettingMsg_PenaltyAreaMode_TuyaSettingMsg_PenaltyAreaMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaSettingMsg_PenaltyAreaMode_TuyaSettingMsg_PenaltyAreaMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaSettingMsg_PenaltyAreaMode_IsValid(int value);
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_MIN = TuyaSettingMsg_PenaltyAreaMode_ban_clean_and_sweep;
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_MAX = TuyaSettingMsg_PenaltyAreaMode_ban_sweep;
constexpr int TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_ARRAYSIZE = TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_PenaltyAreaMode_descriptor();
template<typename T>
inline const std::string& TuyaSettingMsg_PenaltyAreaMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaSettingMsg_PenaltyAreaMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaSettingMsg_PenaltyAreaMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaSettingMsg_PenaltyAreaMode_descriptor(), enum_t_value);
}
inline bool TuyaSettingMsg_PenaltyAreaMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaSettingMsg_PenaltyAreaMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaSettingMsg_PenaltyAreaMode>(
    TuyaSettingMsg_PenaltyAreaMode_descriptor(), name, value);
}
enum RobotStatusMsg_STATUS : int {
  RobotStatusMsg_STATUS_initial = 0,
  RobotStatusMsg_STATUS_smart = 1,
  RobotStatusMsg_STATUS_zone_clean = 2,
  RobotStatusMsg_STATUS_part_clean = 3,
  RobotStatusMsg_STATUS_cleaning = 4,
  RobotStatusMsg_STATUS_paused = 5,
  RobotStatusMsg_STATUS_goto_pos = 6,
  RobotStatusMsg_STATUS_pos_arrived = 7,
  RobotStatusMsg_STATUS_pos_unarrive = 8,
  RobotStatusMsg_STATUS_goto_charge = 9,
  RobotStatusMsg_STATUS_charging = 10,
  RobotStatusMsg_STATUS_charge_done = 11,
  RobotStatusMsg_STATUS_sleep = 12,
  RobotStatusMsg_STATUS_select_room = 13,
  RobotStatusMsg_STATUS_aim_clean = 14,
  RobotStatusMsg_STATUS_control_clean = 15,
  RobotStatusMsg_STATUS_explore = 16,
  RobotStatusMsg_STATUS_come_down_from_partner = 17,
  RobotStatusMsg_STATUS_standby = 18,
  RobotStatusMsg_STATUS_RobotStatusMsg_STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RobotStatusMsg_STATUS_RobotStatusMsg_STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RobotStatusMsg_STATUS_IsValid(int value);
constexpr RobotStatusMsg_STATUS RobotStatusMsg_STATUS_STATUS_MIN = RobotStatusMsg_STATUS_initial;
constexpr RobotStatusMsg_STATUS RobotStatusMsg_STATUS_STATUS_MAX = RobotStatusMsg_STATUS_standby;
constexpr int RobotStatusMsg_STATUS_STATUS_ARRAYSIZE = RobotStatusMsg_STATUS_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotStatusMsg_STATUS_descriptor();
template<typename T>
inline const std::string& RobotStatusMsg_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotStatusMsg_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotStatusMsg_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotStatusMsg_STATUS_descriptor(), enum_t_value);
}
inline bool RobotStatusMsg_STATUS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotStatusMsg_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotStatusMsg_STATUS>(
    RobotStatusMsg_STATUS_descriptor(), name, value);
}
enum RobotStatusMsg_Fault : int {
  RobotStatusMsg_Fault_no_fault = 0,
  RobotStatusMsg_Fault_edge_sweep_fault = 1,
  RobotStatusMsg_Fault_middle_sweel_fault = 2,
  RobotStatusMsg_Fault_left_wheel_fault = 3,
  RobotStatusMsg_Fault_right_wheel_fault = 4,
  RobotStatusMsg_Fault_garbage_box_fault = 5,
  RobotStatusMsg_Fault_land_check_fault = 6,
  RobotStatusMsg_Fault_collision_fault = 7,
  RobotStatusMsg_Fault_laser_ranging_sensor_fault = 8,
  RobotStatusMsg_Fault_D_TOF_fault = 9,
  RobotStatusMsg_Fault_edge_sensor_fault = 10,
  RobotStatusMsg_Fault_low_water_volume_of_water_tank = 11,
  RobotStatusMsg_Fault_dust_box_is_full = 12,
  RobotStatusMsg_Fault_dust_box_removed = 13,
  RobotStatusMsg_Fault_abnormal_installation_of_dust_box = 14,
  RobotStatusMsg_Fault_abnormal_installation_of_roller_brush = 15,
  RobotStatusMsg_Fault_the_drive_wheel_is_entangled = 16,
  RobotStatusMsg_Fault_fan_blocked = 17,
  RobotStatusMsg_Fault_battery_is_too_low_return_to_charging = 18,
  RobotStatusMsg_Fault_battery_is_too_low_stop_cleaning = 19,
  RobotStatusMsg_Fault_power_is_less_than_20 = 20,
  RobotStatusMsg_Fault_charging_electrode_of_base_station_is_dirty = 21,
  RobotStatusMsg_Fault_complete_the_cleaning_task = 22,
  RobotStatusMsg_Fault_sweeping_area_blocked = 23,
  RobotStatusMsg_Fault_start_in_restricted_area = 24,
  RobotStatusMsg_Fault_cleaning_area_does_not_exist = 25,
  RobotStatusMsg_Fault_positioning_abnormality = 26,
  RobotStatusMsg_Fault_unable_to_continue_working = 27,
  RobotStatusMsg_Fault_unable_to_return_to_base_station = 28,
  RobotStatusMsg_Fault_water_shortage_in_water_tank = 29,
  RobotStatusMsg_Fault_water_tank_not_installed_in_place = 30,
  RobotStatusMsg_Fault_water_tank_is_full = 31,
  RobotStatusMsg_Fault_dust_collection_bag_is_full = 32,
  RobotStatusMsg_Fault_dust_collection_failed = 33,
  RobotStatusMsg_Fault_sewage_tank_is_full = 34,
  RobotStatusMsg_Fault_sewage_tank_cannot_be_recycled = 35,
  RobotStatusMsg_Fault_heating_system_fault = 36,
  RobotStatusMsg_Fault_mop_drying_tips = 37,
  RobotStatusMsg_Fault_enclosure_tank_cover_not_fully_closed = 38,
  RobotStatusMsg_Fault_housing_dust_box_not_fully_closed = 39,
  RobotStatusMsg_Fault_broom_water = 40,
  RobotStatusMsg_Fault_sweeping_machine_pumping = 41,
  RobotStatusMsg_Fault_host_start = 42,
  RobotStatusMsg_Fault_host_pause = 43,
  RobotStatusMsg_Fault_suspension_sensor_fault = 44,
  RobotStatusMsg_Fault_not_in_horizontal_plane = 45,
  RobotStatusMsg_Fault_check_the_radar_upper_cover = 46,
  RobotStatusMsg_Fault_abnormal_noise_of_main_engine = 47,
  RobotStatusMsg_Fault_sudden_stop = 48,
  RobotStatusMsg_Fault_not_start_after_charging = 49,
  RobotStatusMsg_Fault_rebuild_drawing = 50,
  RobotStatusMsg_Fault_pause_during_running = 51,
  RobotStatusMsg_Fault_dust_duct_blockage = 53,
  RobotStatusMsg_Fault_excessive_dust = 54,
  RobotStatusMsg_Fault_pick_up = 56,
  RobotStatusMsg_Fault_dangling_handling = 57,
  RobotStatusMsg_Fault_trapped = 58,
  RobotStatusMsg_Fault_mop_brush_motor_is_not_setup = 59,
  RobotStatusMsg_Fault_edge_brush_motor_is_not_setuo = 60,
  RobotStatusMsg_Fault_edge_sweep_err = 61,
  RobotStatusMsg_Fault_middle_sweel_err = 62,
  RobotStatusMsg_Fault_battery_error = 63,
  RobotStatusMsg_Fault_fan_motor_error = 64,
  RobotStatusMsg_Fault_mop_brush_motor_is_twine = 65,
  RobotStatusMsg_Fault_mop_brush_motor_is_err = 66,
  RobotStatusMsg_Fault_partner_clean_water_box_is_not_exist = 67,
  RobotStatusMsg_Fault_partner_waste_water_box_is_not_exist = 68,
  RobotStatusMsg_Fault_partner_water_overflow = 69,
  RobotStatusMsg_Fault_partner_dust_collection_err = 70,
  RobotStatusMsg_Fault_partner_clean_mop_err = 71,
  RobotStatusMsg_Fault_partner_drying_mop_err = 72,
  RobotStatusMsg_Fault_partner_air_blower_error_err = 73,
  RobotStatusMsg_Fault_dry_mop_temperature_err = 74,
  RobotStatusMsg_Fault_start_up_when_slant = 75,
  RobotStatusMsg_Fault_RobotStatusMsg_Fault_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RobotStatusMsg_Fault_RobotStatusMsg_Fault_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RobotStatusMsg_Fault_IsValid(int value);
constexpr RobotStatusMsg_Fault RobotStatusMsg_Fault_Fault_MIN = RobotStatusMsg_Fault_no_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg_Fault_Fault_MAX = RobotStatusMsg_Fault_start_up_when_slant;
constexpr int RobotStatusMsg_Fault_Fault_ARRAYSIZE = RobotStatusMsg_Fault_Fault_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotStatusMsg_Fault_descriptor();
template<typename T>
inline const std::string& RobotStatusMsg_Fault_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotStatusMsg_Fault>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotStatusMsg_Fault_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotStatusMsg_Fault_descriptor(), enum_t_value);
}
inline bool RobotStatusMsg_Fault_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotStatusMsg_Fault* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotStatusMsg_Fault>(
    RobotStatusMsg_Fault_descriptor(), name, value);
}
enum LanguagePackMsg_DownloadStatus : int {
  LanguagePackMsg_DownloadStatus_DOWNLOAD_FAILED = 0,
  LanguagePackMsg_DownloadStatus_INSTALLING = 1,
  LanguagePackMsg_DownloadStatus_INSTALL_SUCCESS = 2,
  LanguagePackMsg_DownloadStatus_USING = 3,
  LanguagePackMsg_DownloadStatus_LanguagePackMsg_DownloadStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LanguagePackMsg_DownloadStatus_LanguagePackMsg_DownloadStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LanguagePackMsg_DownloadStatus_IsValid(int value);
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg_DownloadStatus_DownloadStatus_MIN = LanguagePackMsg_DownloadStatus_DOWNLOAD_FAILED;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg_DownloadStatus_DownloadStatus_MAX = LanguagePackMsg_DownloadStatus_USING;
constexpr int LanguagePackMsg_DownloadStatus_DownloadStatus_ARRAYSIZE = LanguagePackMsg_DownloadStatus_DownloadStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguagePackMsg_DownloadStatus_descriptor();
template<typename T>
inline const std::string& LanguagePackMsg_DownloadStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguagePackMsg_DownloadStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguagePackMsg_DownloadStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguagePackMsg_DownloadStatus_descriptor(), enum_t_value);
}
inline bool LanguagePackMsg_DownloadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguagePackMsg_DownloadStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguagePackMsg_DownloadStatus>(
    LanguagePackMsg_DownloadStatus_descriptor(), name, value);
}
enum LanguagePackMsg_LanguageType : int {
  LanguagePackMsg_LanguageType_SIMPLIFIED_CHINESE = 0,
  LanguagePackMsg_LanguageType_TRADITIONAL_CHINESE = 1,
  LanguagePackMsg_LanguageType_ENGLISH = 2,
  LanguagePackMsg_LanguageType_GRTMAN = 3,
  LanguagePackMsg_LanguageType_FRENCH = 4,
  LanguagePackMsg_LanguageType_RUSSIAN = 5,
  LanguagePackMsg_LanguageType_SPANISH = 6,
  LanguagePackMsg_LanguageType_KOREAN = 7,
  LanguagePackMsg_LanguageType_LATIN = 8,
  LanguagePackMsg_LanguageType_PORTUGUESE = 9,
  LanguagePackMsg_LanguageType_JAPANESE = 10,
  LanguagePackMsg_LanguageType_ITALIAN = 11,
  LanguagePackMsg_LanguageType_LanguagePackMsg_LanguageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LanguagePackMsg_LanguageType_LanguagePackMsg_LanguageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LanguagePackMsg_LanguageType_IsValid(int value);
constexpr LanguagePackMsg_LanguageType LanguagePackMsg_LanguageType_LanguageType_MIN = LanguagePackMsg_LanguageType_SIMPLIFIED_CHINESE;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg_LanguageType_LanguageType_MAX = LanguagePackMsg_LanguageType_ITALIAN;
constexpr int LanguagePackMsg_LanguageType_LanguageType_ARRAYSIZE = LanguagePackMsg_LanguageType_LanguageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguagePackMsg_LanguageType_descriptor();
template<typename T>
inline const std::string& LanguagePackMsg_LanguageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguagePackMsg_LanguageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguagePackMsg_LanguageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguagePackMsg_LanguageType_descriptor(), enum_t_value);
}
inline bool LanguagePackMsg_LanguageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguagePackMsg_LanguageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguagePackMsg_LanguageType>(
    LanguagePackMsg_LanguageType_descriptor(), name, value);
}
enum TuyaStartupMode : int {
  unused = 0,
  explore_mode = 1,
  clean_mode = 2,
  sweep_mode = 3,
  clean_and_sweep_mode = 4,
  recharge_mode = 5,
  timing_mode = 6,
  aim_point = 7,
  select_area_clean = 8,
  edge_clean = 9,
  TuyaStartupMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TuyaStartupMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TuyaStartupMode_IsValid(int value);
constexpr TuyaStartupMode TuyaStartupMode_MIN = unused;
constexpr TuyaStartupMode TuyaStartupMode_MAX = edge_clean;
constexpr int TuyaStartupMode_ARRAYSIZE = TuyaStartupMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaStartupMode_descriptor();
template<typename T>
inline const std::string& TuyaStartupMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TuyaStartupMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TuyaStartupMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TuyaStartupMode_descriptor(), enum_t_value);
}
inline bool TuyaStartupMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TuyaStartupMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TuyaStartupMode>(
    TuyaStartupMode_descriptor(), name, value);
}
// ===================================================================

class TuyaCommandMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.TuyaCommandMsg) */ {
 public:
  inline TuyaCommandMsg() : TuyaCommandMsg(nullptr) {}
  ~TuyaCommandMsg() override;
  explicit PROTOBUF_CONSTEXPR TuyaCommandMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TuyaCommandMsg(const TuyaCommandMsg& from);
  TuyaCommandMsg(TuyaCommandMsg&& from) noexcept
    : TuyaCommandMsg() {
    *this = ::std::move(from);
  }

  inline TuyaCommandMsg& operator=(const TuyaCommandMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TuyaCommandMsg& operator=(TuyaCommandMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TuyaCommandMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TuyaCommandMsg* internal_default_instance() {
    return reinterpret_cast<const TuyaCommandMsg*>(
               &_TuyaCommandMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TuyaCommandMsg& a, TuyaCommandMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TuyaCommandMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TuyaCommandMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TuyaCommandMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TuyaCommandMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TuyaCommandMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TuyaCommandMsg& from) {
    TuyaCommandMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TuyaCommandMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.TuyaCommandMsg";
  }
  protected:
  explicit TuyaCommandMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TuyaCommandMsg_COMMAND COMMAND;
  static constexpr COMMAND clean_command =
    TuyaCommandMsg_COMMAND_clean_command;
  static constexpr COMMAND pause_command =
    TuyaCommandMsg_COMMAND_pause_command;
  static constexpr COMMAND recharge_command =
    TuyaCommandMsg_COMMAND_recharge_command;
  static constexpr COMMAND select_area_clean =
    TuyaCommandMsg_COMMAND_select_area_clean;
  static constexpr COMMAND aim_point_clean =
    TuyaCommandMsg_COMMAND_aim_point_clean;
  static constexpr COMMAND plan_area_clean =
    TuyaCommandMsg_COMMAND_plan_area_clean;
  static constexpr COMMAND over_task =
    TuyaCommandMsg_COMMAND_over_task;
  static constexpr COMMAND remote_control =
    TuyaCommandMsg_COMMAND_remote_control;
  static constexpr COMMAND look_for_robot =
    TuyaCommandMsg_COMMAND_look_for_robot;
  static constexpr COMMAND explore =
    TuyaCommandMsg_COMMAND_explore;
  static inline bool COMMAND_IsValid(int value) {
    return TuyaCommandMsg_COMMAND_IsValid(value);
  }
  static constexpr COMMAND COMMAND_MIN =
    TuyaCommandMsg_COMMAND_COMMAND_MIN;
  static constexpr COMMAND COMMAND_MAX =
    TuyaCommandMsg_COMMAND_COMMAND_MAX;
  static constexpr int COMMAND_ARRAYSIZE =
    TuyaCommandMsg_COMMAND_COMMAND_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  COMMAND_descriptor() {
    return TuyaCommandMsg_COMMAND_descriptor();
  }
  template<typename T>
  static inline const std::string& COMMAND_Name(T enum_t_value) {
    static_assert(::std::is_same<T, COMMAND>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function COMMAND_Name.");
    return TuyaCommandMsg_COMMAND_Name(enum_t_value);
  }
  static inline bool COMMAND_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      COMMAND* value) {
    return TuyaCommandMsg_COMMAND_Parse(name, value);
  }

  typedef TuyaCommandMsg_RemoteControlDirection RemoteControlDirection;
  static constexpr RemoteControlDirection DEFAIL =
    TuyaCommandMsg_RemoteControlDirection_DEFAIL;
  static constexpr RemoteControlDirection FORWARD =
    TuyaCommandMsg_RemoteControlDirection_FORWARD;
  static constexpr RemoteControlDirection BACKWARD =
    TuyaCommandMsg_RemoteControlDirection_BACKWARD;
  static constexpr RemoteControlDirection TRUN_LEFT =
    TuyaCommandMsg_RemoteControlDirection_TRUN_LEFT;
  static constexpr RemoteControlDirection TURN_RIGHT =
    TuyaCommandMsg_RemoteControlDirection_TURN_RIGHT;
  static constexpr RemoteControlDirection STOP =
    TuyaCommandMsg_RemoteControlDirection_STOP;
  static inline bool RemoteControlDirection_IsValid(int value) {
    return TuyaCommandMsg_RemoteControlDirection_IsValid(value);
  }
  static constexpr RemoteControlDirection RemoteControlDirection_MIN =
    TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_MIN;
  static constexpr RemoteControlDirection RemoteControlDirection_MAX =
    TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_MAX;
  static constexpr int RemoteControlDirection_ARRAYSIZE =
    TuyaCommandMsg_RemoteControlDirection_RemoteControlDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RemoteControlDirection_descriptor() {
    return TuyaCommandMsg_RemoteControlDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& RemoteControlDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RemoteControlDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RemoteControlDirection_Name.");
    return TuyaCommandMsg_RemoteControlDirection_Name(enum_t_value);
  }
  static inline bool RemoteControlDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RemoteControlDirection* value) {
    return TuyaCommandMsg_RemoteControlDirection_Parse(name, value);
  }

  typedef TuyaCommandMsg_SuctionLevel SuctionLevel;
  static constexpr SuctionLevel SUCYION_LEVEL_CLOSE =
    TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_CLOSE;
  static constexpr SuctionLevel SUCYION_LEVEL_MUTE =
    TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_MUTE;
  static constexpr SuctionLevel SUCYION_LEVEL_NORMAL =
    TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_NORMAL;
  static constexpr SuctionLevel SUCYION_LEVEL_STRONG =
    TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_STRONG;
  static constexpr SuctionLevel SUCYION_LEVEL_SUPER_STRONG =
    TuyaCommandMsg_SuctionLevel_SUCYION_LEVEL_SUPER_STRONG;
  static inline bool SuctionLevel_IsValid(int value) {
    return TuyaCommandMsg_SuctionLevel_IsValid(value);
  }
  static constexpr SuctionLevel SuctionLevel_MIN =
    TuyaCommandMsg_SuctionLevel_SuctionLevel_MIN;
  static constexpr SuctionLevel SuctionLevel_MAX =
    TuyaCommandMsg_SuctionLevel_SuctionLevel_MAX;
  static constexpr int SuctionLevel_ARRAYSIZE =
    TuyaCommandMsg_SuctionLevel_SuctionLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SuctionLevel_descriptor() {
    return TuyaCommandMsg_SuctionLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& SuctionLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SuctionLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SuctionLevel_Name.");
    return TuyaCommandMsg_SuctionLevel_Name(enum_t_value);
  }
  static inline bool SuctionLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SuctionLevel* value) {
    return TuyaCommandMsg_SuctionLevel_Parse(name, value);
  }

  typedef TuyaCommandMsg_WaterVolumeLevel WaterVolumeLevel;
  static constexpr WaterVolumeLevel WATER_BOX_LEVEL_CLOSE =
    TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_CLOSE;
  static constexpr WaterVolumeLevel WATER_BOX_LEVEL_ONE =
    TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_ONE;
  static constexpr WaterVolumeLevel WATER_BOX_LEVEL_TWO =
    TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_TWO;
  static constexpr WaterVolumeLevel WATER_BOX_LEVEL_THREE =
    TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_THREE;
  static constexpr WaterVolumeLevel WATER_BOX_LEVEL_NOT_SET =
    TuyaCommandMsg_WaterVolumeLevel_WATER_BOX_LEVEL_NOT_SET;
  static inline bool WaterVolumeLevel_IsValid(int value) {
    return TuyaCommandMsg_WaterVolumeLevel_IsValid(value);
  }
  static constexpr WaterVolumeLevel WaterVolumeLevel_MIN =
    TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_MIN;
  static constexpr WaterVolumeLevel WaterVolumeLevel_MAX =
    TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_MAX;
  static constexpr int WaterVolumeLevel_ARRAYSIZE =
    TuyaCommandMsg_WaterVolumeLevel_WaterVolumeLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WaterVolumeLevel_descriptor() {
    return TuyaCommandMsg_WaterVolumeLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& WaterVolumeLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WaterVolumeLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WaterVolumeLevel_Name.");
    return TuyaCommandMsg_WaterVolumeLevel_Name(enum_t_value);
  }
  static inline bool WaterVolumeLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WaterVolumeLevel* value) {
    return TuyaCommandMsg_WaterVolumeLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlanAreaCleanPointsFieldNumber = 2,
    kPartitionSegmentationPointsFieldNumber = 3,
    kRoomIdFieldNumber = 5,
    kAimPointCleanPointsFieldNumber = 4,
    kCurrentCommandFieldNumber = 1,
    kSelectAreaCleanTimeNumberFieldNumber = 6,
    kRoomNumberFieldNumber = 7,
    kAreaNumberFieldNumber = 8,
    kDirectionFieldNumber = 9,
    kSuctionLevelFieldNumber = 18,
    kWaterVolumeLevelFieldNumber = 19,
    kPlanAreaCleanTimeNumberFieldNumber = 20,
  };
  // repeated .LSLAM.Points plan_area_clean_points = 2;
  int plan_area_clean_points_size() const;
  private:
  int _internal_plan_area_clean_points_size() const;
  public:
  void clear_plan_area_clean_points();
  ::LSLAM::Points* mutable_plan_area_clean_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_plan_area_clean_points();
  private:
  const ::LSLAM::Points& _internal_plan_area_clean_points(int index) const;
  ::LSLAM::Points* _internal_add_plan_area_clean_points();
  public:
  const ::LSLAM::Points& plan_area_clean_points(int index) const;
  ::LSLAM::Points* add_plan_area_clean_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      plan_area_clean_points() const;

  // repeated .LSLAM.Points partition_segmentation_points = 3;
  int partition_segmentation_points_size() const;
  private:
  int _internal_partition_segmentation_points_size() const;
  public:
  void clear_partition_segmentation_points();
  ::LSLAM::Points* mutable_partition_segmentation_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_partition_segmentation_points();
  private:
  const ::LSLAM::Points& _internal_partition_segmentation_points(int index) const;
  ::LSLAM::Points* _internal_add_partition_segmentation_points();
  public:
  const ::LSLAM::Points& partition_segmentation_points(int index) const;
  ::LSLAM::Points* add_partition_segmentation_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      partition_segmentation_points() const;

  // repeated int32 room_id = 5;
  int room_id_size() const;
  private:
  int _internal_room_id_size() const;
  public:
  void clear_room_id();
  private:
  int32_t _internal_room_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_room_id() const;
  void _internal_add_room_id(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_room_id();
  public:
  int32_t room_id(int index) const;
  void set_room_id(int index, int32_t value);
  void add_room_id(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      room_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_room_id();

  // .LSLAM.Points aim_point_clean_points = 4;
  bool has_aim_point_clean_points() const;
  private:
  bool _internal_has_aim_point_clean_points() const;
  public:
  void clear_aim_point_clean_points();
  const ::LSLAM::Points& aim_point_clean_points() const;
  PROTOBUF_NODISCARD ::LSLAM::Points* release_aim_point_clean_points();
  ::LSLAM::Points* mutable_aim_point_clean_points();
  void set_allocated_aim_point_clean_points(::LSLAM::Points* aim_point_clean_points);
  private:
  const ::LSLAM::Points& _internal_aim_point_clean_points() const;
  ::LSLAM::Points* _internal_mutable_aim_point_clean_points();
  public:
  void unsafe_arena_set_allocated_aim_point_clean_points(
      ::LSLAM::Points* aim_point_clean_points);
  ::LSLAM::Points* unsafe_arena_release_aim_point_clean_points();

  // .LSLAM.TuyaCommandMsg.COMMAND current_command = 1;
  void clear_current_command();
  ::LSLAM::TuyaCommandMsg_COMMAND current_command() const;
  void set_current_command(::LSLAM::TuyaCommandMsg_COMMAND value);
  private:
  ::LSLAM::TuyaCommandMsg_COMMAND _internal_current_command() const;
  void _internal_set_current_command(::LSLAM::TuyaCommandMsg_COMMAND value);
  public:

  // int32 select_area_clean_time_number = 6;
  void clear_select_area_clean_time_number();
  int32_t select_area_clean_time_number() const;
  void set_select_area_clean_time_number(int32_t value);
  private:
  int32_t _internal_select_area_clean_time_number() const;
  void _internal_set_select_area_clean_time_number(int32_t value);
  public:

  // int32 room_number = 7;
  void clear_room_number();
  int32_t room_number() const;
  void set_room_number(int32_t value);
  private:
  int32_t _internal_room_number() const;
  void _internal_set_room_number(int32_t value);
  public:

  // int32 area_number = 8;
  void clear_area_number();
  int32_t area_number() const;
  void set_area_number(int32_t value);
  private:
  int32_t _internal_area_number() const;
  void _internal_set_area_number(int32_t value);
  public:

  // .LSLAM.TuyaCommandMsg.RemoteControlDirection direction = 9;
  void clear_direction();
  ::LSLAM::TuyaCommandMsg_RemoteControlDirection direction() const;
  void set_direction(::LSLAM::TuyaCommandMsg_RemoteControlDirection value);
  private:
  ::LSLAM::TuyaCommandMsg_RemoteControlDirection _internal_direction() const;
  void _internal_set_direction(::LSLAM::TuyaCommandMsg_RemoteControlDirection value);
  public:

  // .LSLAM.TuyaCommandMsg.SuctionLevel suction_level = 18;
  void clear_suction_level();
  ::LSLAM::TuyaCommandMsg_SuctionLevel suction_level() const;
  void set_suction_level(::LSLAM::TuyaCommandMsg_SuctionLevel value);
  private:
  ::LSLAM::TuyaCommandMsg_SuctionLevel _internal_suction_level() const;
  void _internal_set_suction_level(::LSLAM::TuyaCommandMsg_SuctionLevel value);
  public:

  // .LSLAM.TuyaCommandMsg.WaterVolumeLevel water_volume_level = 19;
  void clear_water_volume_level();
  ::LSLAM::TuyaCommandMsg_WaterVolumeLevel water_volume_level() const;
  void set_water_volume_level(::LSLAM::TuyaCommandMsg_WaterVolumeLevel value);
  private:
  ::LSLAM::TuyaCommandMsg_WaterVolumeLevel _internal_water_volume_level() const;
  void _internal_set_water_volume_level(::LSLAM::TuyaCommandMsg_WaterVolumeLevel value);
  public:

  // int32 plan_area_clean_time_number = 20;
  void clear_plan_area_clean_time_number();
  int32_t plan_area_clean_time_number() const;
  void set_plan_area_clean_time_number(int32_t value);
  private:
  int32_t _internal_plan_area_clean_time_number() const;
  void _internal_set_plan_area_clean_time_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.TuyaCommandMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > plan_area_clean_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > partition_segmentation_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _room_id_cached_byte_size_;
    ::LSLAM::Points* aim_point_clean_points_;
    int current_command_;
    int32_t select_area_clean_time_number_;
    int32_t room_number_;
    int32_t area_number_;
    int direction_;
    int suction_level_;
    int water_volume_level_;
    int32_t plan_area_clean_time_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class TuyaSettingMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.TuyaSettingMsg) */ {
 public:
  inline TuyaSettingMsg() : TuyaSettingMsg(nullptr) {}
  ~TuyaSettingMsg() override;
  explicit PROTOBUF_CONSTEXPR TuyaSettingMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TuyaSettingMsg(const TuyaSettingMsg& from);
  TuyaSettingMsg(TuyaSettingMsg&& from) noexcept
    : TuyaSettingMsg() {
    *this = ::std::move(from);
  }

  inline TuyaSettingMsg& operator=(const TuyaSettingMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TuyaSettingMsg& operator=(TuyaSettingMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TuyaSettingMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TuyaSettingMsg* internal_default_instance() {
    return reinterpret_cast<const TuyaSettingMsg*>(
               &_TuyaSettingMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TuyaSettingMsg& a, TuyaSettingMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TuyaSettingMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TuyaSettingMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TuyaSettingMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TuyaSettingMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TuyaSettingMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TuyaSettingMsg& from) {
    TuyaSettingMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TuyaSettingMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.TuyaSettingMsg";
  }
  protected:
  explicit TuyaSettingMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TuyaSettingMsg_SET SET;
  static constexpr SET set_virtual_wall =
    TuyaSettingMsg_SET_set_virtual_wall;
  static constexpr SET set_penalty_area =
    TuyaSettingMsg_SET_set_penalty_area;
  static constexpr SET partition_segmentation =
    TuyaSettingMsg_SET_partition_segmentation;
  static constexpr SET partition_merge =
    TuyaSettingMsg_SET_partition_merge;
  static constexpr SET partition_restore_the_default =
    TuyaSettingMsg_SET_partition_restore_the_default;
  static constexpr SET set_room_properties =
    TuyaSettingMsg_SET_set_room_properties;
  static constexpr SET room_named =
    TuyaSettingMsg_SET_room_named;
  static constexpr SET clean_order =
    TuyaSettingMsg_SET_clean_order;
  static constexpr SET reset_map =
    TuyaSettingMsg_SET_reset_map;
  static constexpr SET timing_clean =
    TuyaSettingMsg_SET_timing_clean;
  static constexpr SET save_map_to_cloud =
    TuyaSettingMsg_SET_save_map_to_cloud;
  static constexpr SET save_map_to_local =
    TuyaSettingMsg_SET_save_map_to_local;
  static constexpr SET do_not_disturb =
    TuyaSettingMsg_SET_do_not_disturb;
  static constexpr SET reset_edge_brush =
    TuyaSettingMsg_SET_reset_edge_brush;
  static constexpr SET reset_roll_brush =
    TuyaSettingMsg_SET_reset_roll_brush;
  static constexpr SET reset_filter =
    TuyaSettingMsg_SET_reset_filter;
  static constexpr SET rag_life_reset =
    TuyaSettingMsg_SET_rag_life_reset;
  static constexpr SET set_pack_language =
    TuyaSettingMsg_SET_set_pack_language;
  static constexpr SET volume_set =
    TuyaSettingMsg_SET_volume_set;
  static constexpr SET do_not_disturb_switch =
    TuyaSettingMsg_SET_do_not_disturb_switch;
  static constexpr SET set_fan_motor =
    TuyaSettingMsg_SET_set_fan_motor;
  static constexpr SET set_water_box_motor =
    TuyaSettingMsg_SET_set_water_box_motor;
  static inline bool SET_IsValid(int value) {
    return TuyaSettingMsg_SET_IsValid(value);
  }
  static constexpr SET SET_MIN =
    TuyaSettingMsg_SET_SET_MIN;
  static constexpr SET SET_MAX =
    TuyaSettingMsg_SET_SET_MAX;
  static constexpr int SET_ARRAYSIZE =
    TuyaSettingMsg_SET_SET_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SET_descriptor() {
    return TuyaSettingMsg_SET_descriptor();
  }
  template<typename T>
  static inline const std::string& SET_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SET>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SET_Name.");
    return TuyaSettingMsg_SET_Name(enum_t_value);
  }
  static inline bool SET_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SET* value) {
    return TuyaSettingMsg_SET_Parse(name, value);
  }

  typedef TuyaSettingMsg_CleanMode CleanMode;
  static constexpr CleanMode CLEAN =
    TuyaSettingMsg_CleanMode_CLEAN;
  static constexpr CleanMode SWEEP =
    TuyaSettingMsg_CleanMode_SWEEP;
  static constexpr CleanMode CLEAN_AND_SWEEP =
    TuyaSettingMsg_CleanMode_CLEAN_AND_SWEEP;
  static inline bool CleanMode_IsValid(int value) {
    return TuyaSettingMsg_CleanMode_IsValid(value);
  }
  static constexpr CleanMode CleanMode_MIN =
    TuyaSettingMsg_CleanMode_CleanMode_MIN;
  static constexpr CleanMode CleanMode_MAX =
    TuyaSettingMsg_CleanMode_CleanMode_MAX;
  static constexpr int CleanMode_ARRAYSIZE =
    TuyaSettingMsg_CleanMode_CleanMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CleanMode_descriptor() {
    return TuyaSettingMsg_CleanMode_descriptor();
  }
  template<typename T>
  static inline const std::string& CleanMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CleanMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CleanMode_Name.");
    return TuyaSettingMsg_CleanMode_Name(enum_t_value);
  }
  static inline bool CleanMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CleanMode* value) {
    return TuyaSettingMsg_CleanMode_Parse(name, value);
  }

  typedef TuyaSettingMsg_CleanMotorState CleanMotorState;
  static constexpr CleanMotorState CLEAN_MOTOR_CLOSE =
    TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_CLOSE;
  static constexpr CleanMotorState CLEAN_MOTOR_OPEN =
    TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_OPEN;
  static constexpr CleanMotorState CLEAN_MOTOR_LOW =
    TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_LOW;
  static constexpr CleanMotorState CLEAN_MOTOR_MEDIUM =
    TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_MEDIUM;
  static constexpr CleanMotorState CLEAN_MOTOR_HIGH =
    TuyaSettingMsg_CleanMotorState_CLEAN_MOTOR_HIGH;
  static inline bool CleanMotorState_IsValid(int value) {
    return TuyaSettingMsg_CleanMotorState_IsValid(value);
  }
  static constexpr CleanMotorState CleanMotorState_MIN =
    TuyaSettingMsg_CleanMotorState_CleanMotorState_MIN;
  static constexpr CleanMotorState CleanMotorState_MAX =
    TuyaSettingMsg_CleanMotorState_CleanMotorState_MAX;
  static constexpr int CleanMotorState_ARRAYSIZE =
    TuyaSettingMsg_CleanMotorState_CleanMotorState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CleanMotorState_descriptor() {
    return TuyaSettingMsg_CleanMotorState_descriptor();
  }
  template<typename T>
  static inline const std::string& CleanMotorState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CleanMotorState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CleanMotorState_Name.");
    return TuyaSettingMsg_CleanMotorState_Name(enum_t_value);
  }
  static inline bool CleanMotorState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CleanMotorState* value) {
    return TuyaSettingMsg_CleanMotorState_Parse(name, value);
  }

  typedef TuyaSettingMsg_FanMotorLevel FanMotorLevel;
  static constexpr FanMotorLevel FAN_MOTOR_CLOSE =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_CLOSE;
  static constexpr FanMotorLevel FAN_MOTOR_MUTE =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_MUTE;
  static constexpr FanMotorLevel FAN_MOTOR_NORMAL =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_NORMAL;
  static constexpr FanMotorLevel FAN_MOTOR_STRONG =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_STRONG;
  static constexpr FanMotorLevel FAN_MOTOR_SUPER_STRONG =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_SUPER_STRONG;
  static constexpr FanMotorLevel FAN_MOTOR_NOT_SET =
    TuyaSettingMsg_FanMotorLevel_FAN_MOTOR_NOT_SET;
  static inline bool FanMotorLevel_IsValid(int value) {
    return TuyaSettingMsg_FanMotorLevel_IsValid(value);
  }
  static constexpr FanMotorLevel FanMotorLevel_MIN =
    TuyaSettingMsg_FanMotorLevel_FanMotorLevel_MIN;
  static constexpr FanMotorLevel FanMotorLevel_MAX =
    TuyaSettingMsg_FanMotorLevel_FanMotorLevel_MAX;
  static constexpr int FanMotorLevel_ARRAYSIZE =
    TuyaSettingMsg_FanMotorLevel_FanMotorLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FanMotorLevel_descriptor() {
    return TuyaSettingMsg_FanMotorLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& FanMotorLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FanMotorLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FanMotorLevel_Name.");
    return TuyaSettingMsg_FanMotorLevel_Name(enum_t_value);
  }
  static inline bool FanMotorLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FanMotorLevel* value) {
    return TuyaSettingMsg_FanMotorLevel_Parse(name, value);
  }

  typedef TuyaSettingMsg_WaterBoxLevel WaterBoxLevel;
  static constexpr WaterBoxLevel WATER_BOX_LEVEL_CLOSE =
    TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_CLOSE;
  static constexpr WaterBoxLevel WATER_BOX_LEVEL_ONE =
    TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_ONE;
  static constexpr WaterBoxLevel WATER_BOX_LEVEL_TWO =
    TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_TWO;
  static constexpr WaterBoxLevel WATER_BOX_LEVEL_THREE =
    TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_THREE;
  static constexpr WaterBoxLevel WATER_BOX_LEVEL_NOT_SET =
    TuyaSettingMsg_WaterBoxLevel_WATER_BOX_LEVEL_NOT_SET;
  static inline bool WaterBoxLevel_IsValid(int value) {
    return TuyaSettingMsg_WaterBoxLevel_IsValid(value);
  }
  static constexpr WaterBoxLevel WaterBoxLevel_MIN =
    TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_MIN;
  static constexpr WaterBoxLevel WaterBoxLevel_MAX =
    TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_MAX;
  static constexpr int WaterBoxLevel_ARRAYSIZE =
    TuyaSettingMsg_WaterBoxLevel_WaterBoxLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  WaterBoxLevel_descriptor() {
    return TuyaSettingMsg_WaterBoxLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& WaterBoxLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, WaterBoxLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function WaterBoxLevel_Name.");
    return TuyaSettingMsg_WaterBoxLevel_Name(enum_t_value);
  }
  static inline bool WaterBoxLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      WaterBoxLevel* value) {
    return TuyaSettingMsg_WaterBoxLevel_Parse(name, value);
  }

  typedef TuyaSettingMsg_YtypeSweep YtypeSweep;
  static constexpr YtypeSweep YTYPE_SWEEP_CLOSE =
    TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_CLOSE;
  static constexpr YtypeSweep YTYPE_SWEEP_OPEN =
    TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_OPEN;
  static constexpr YtypeSweep YTYPE_SWEEP_NOT_SET =
    TuyaSettingMsg_YtypeSweep_YTYPE_SWEEP_NOT_SET;
  static inline bool YtypeSweep_IsValid(int value) {
    return TuyaSettingMsg_YtypeSweep_IsValid(value);
  }
  static constexpr YtypeSweep YtypeSweep_MIN =
    TuyaSettingMsg_YtypeSweep_YtypeSweep_MIN;
  static constexpr YtypeSweep YtypeSweep_MAX =
    TuyaSettingMsg_YtypeSweep_YtypeSweep_MAX;
  static constexpr int YtypeSweep_ARRAYSIZE =
    TuyaSettingMsg_YtypeSweep_YtypeSweep_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  YtypeSweep_descriptor() {
    return TuyaSettingMsg_YtypeSweep_descriptor();
  }
  template<typename T>
  static inline const std::string& YtypeSweep_Name(T enum_t_value) {
    static_assert(::std::is_same<T, YtypeSweep>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function YtypeSweep_Name.");
    return TuyaSettingMsg_YtypeSweep_Name(enum_t_value);
  }
  static inline bool YtypeSweep_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      YtypeSweep* value) {
    return TuyaSettingMsg_YtypeSweep_Parse(name, value);
  }

  typedef TuyaSettingMsg_PenaltyAreaMode PenaltyAreaMode;
  static constexpr PenaltyAreaMode ban_clean_and_sweep =
    TuyaSettingMsg_PenaltyAreaMode_ban_clean_and_sweep;
  static constexpr PenaltyAreaMode ban_clean =
    TuyaSettingMsg_PenaltyAreaMode_ban_clean;
  static constexpr PenaltyAreaMode ban_sweep =
    TuyaSettingMsg_PenaltyAreaMode_ban_sweep;
  static inline bool PenaltyAreaMode_IsValid(int value) {
    return TuyaSettingMsg_PenaltyAreaMode_IsValid(value);
  }
  static constexpr PenaltyAreaMode PenaltyAreaMode_MIN =
    TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_MIN;
  static constexpr PenaltyAreaMode PenaltyAreaMode_MAX =
    TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_MAX;
  static constexpr int PenaltyAreaMode_ARRAYSIZE =
    TuyaSettingMsg_PenaltyAreaMode_PenaltyAreaMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PenaltyAreaMode_descriptor() {
    return TuyaSettingMsg_PenaltyAreaMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PenaltyAreaMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PenaltyAreaMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PenaltyAreaMode_Name.");
    return TuyaSettingMsg_PenaltyAreaMode_Name(enum_t_value);
  }
  static inline bool PenaltyAreaMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PenaltyAreaMode* value) {
    return TuyaSettingMsg_PenaltyAreaMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualWallPointsFieldNumber = 3,
    kCleanTimeNumberFieldNumber = 4,
    kRoomNumberFieldNumber = 5,
    kRoomIdFieldNumber = 6,
    kPartitionSegmentationPointsFieldNumber = 7,
    kBanSweepPenaltyAreaPointsFieldNumber = 9,
    kBanCleanAndSweepPenaltyAreaPointsFieldNumber = 11,
    kFanMotorLevelFieldNumber = 12,
    kWaterBoxLevelFieldNumber = 13,
    kYtypeSweepFieldNumber = 14,
    kNameLengthFieldNumber = 15,
    kRoomNameFieldNumber = 17,
    kTimingOpenOrCloseFieldNumber = 26,
    kTimingWeekFieldNumber = 27,
    kTimingStartTimeFieldNumber = 28,
    kTimingCleanModeFieldNumber = 29,
    kQuietDayFieldNumber = 30,
    kCleanSetFieldNumber = 1,
    kVirtualWallNumberFieldNumber = 2,
    kBanSweepPenaltyAreaNumberFieldNumber = 8,
    kBanCleanAndSweepPenaltyAreaNumberFieldNumber = 10,
    kTimeZoneFieldNumber = 18,
    kTimingNumberFieldNumber = 25,
    kQuietStartTimeFieldNumber = 31,
    kQuietEndTimeFieldNumber = 32,
    kCurrentFanMotorLevelFieldNumber = 34,
    kCurrentWaterBoxLevelFieldNumber = 35,
    kDoNotDisturbSwitchOpenFieldNumber = 33,
    kBreakpointContinueToSweepFieldNumber = 37,
    kVolumeFieldNumber = 36,
    kSetResultFieldNumber = 38,
  };
  // repeated .LSLAM.Points virtual_wall_points = 3;
  int virtual_wall_points_size() const;
  private:
  int _internal_virtual_wall_points_size() const;
  public:
  void clear_virtual_wall_points();
  ::LSLAM::Points* mutable_virtual_wall_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_virtual_wall_points();
  private:
  const ::LSLAM::Points& _internal_virtual_wall_points(int index) const;
  ::LSLAM::Points* _internal_add_virtual_wall_points();
  public:
  const ::LSLAM::Points& virtual_wall_points(int index) const;
  ::LSLAM::Points* add_virtual_wall_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      virtual_wall_points() const;

  // repeated int32 clean_time_number = 4;
  int clean_time_number_size() const;
  private:
  int _internal_clean_time_number_size() const;
  public:
  void clear_clean_time_number();
  private:
  int32_t _internal_clean_time_number(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_clean_time_number() const;
  void _internal_add_clean_time_number(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_clean_time_number();
  public:
  int32_t clean_time_number(int index) const;
  void set_clean_time_number(int index, int32_t value);
  void add_clean_time_number(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      clean_time_number() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_clean_time_number();

  // repeated int32 room_number = 5;
  int room_number_size() const;
  private:
  int _internal_room_number_size() const;
  public:
  void clear_room_number();
  private:
  int32_t _internal_room_number(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_room_number() const;
  void _internal_add_room_number(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_room_number();
  public:
  int32_t room_number(int index) const;
  void set_room_number(int index, int32_t value);
  void add_room_number(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      room_number() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_room_number();

  // repeated int32 room_id = 6;
  int room_id_size() const;
  private:
  int _internal_room_id_size() const;
  public:
  void clear_room_id();
  private:
  int32_t _internal_room_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_room_id() const;
  void _internal_add_room_id(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_room_id();
  public:
  int32_t room_id(int index) const;
  void set_room_id(int index, int32_t value);
  void add_room_id(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      room_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_room_id();

  // repeated .LSLAM.Points partition_segmentation_points = 7;
  int partition_segmentation_points_size() const;
  private:
  int _internal_partition_segmentation_points_size() const;
  public:
  void clear_partition_segmentation_points();
  ::LSLAM::Points* mutable_partition_segmentation_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_partition_segmentation_points();
  private:
  const ::LSLAM::Points& _internal_partition_segmentation_points(int index) const;
  ::LSLAM::Points* _internal_add_partition_segmentation_points();
  public:
  const ::LSLAM::Points& partition_segmentation_points(int index) const;
  ::LSLAM::Points* add_partition_segmentation_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      partition_segmentation_points() const;

  // repeated .LSLAM.Points ban_sweep_penalty_area_points = 9;
  int ban_sweep_penalty_area_points_size() const;
  private:
  int _internal_ban_sweep_penalty_area_points_size() const;
  public:
  void clear_ban_sweep_penalty_area_points();
  ::LSLAM::Points* mutable_ban_sweep_penalty_area_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_ban_sweep_penalty_area_points();
  private:
  const ::LSLAM::Points& _internal_ban_sweep_penalty_area_points(int index) const;
  ::LSLAM::Points* _internal_add_ban_sweep_penalty_area_points();
  public:
  const ::LSLAM::Points& ban_sweep_penalty_area_points(int index) const;
  ::LSLAM::Points* add_ban_sweep_penalty_area_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      ban_sweep_penalty_area_points() const;

  // repeated .LSLAM.Points ban_clean_and_sweep_penalty_area_points = 11;
  int ban_clean_and_sweep_penalty_area_points_size() const;
  private:
  int _internal_ban_clean_and_sweep_penalty_area_points_size() const;
  public:
  void clear_ban_clean_and_sweep_penalty_area_points();
  ::LSLAM::Points* mutable_ban_clean_and_sweep_penalty_area_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
      mutable_ban_clean_and_sweep_penalty_area_points();
  private:
  const ::LSLAM::Points& _internal_ban_clean_and_sweep_penalty_area_points(int index) const;
  ::LSLAM::Points* _internal_add_ban_clean_and_sweep_penalty_area_points();
  public:
  const ::LSLAM::Points& ban_clean_and_sweep_penalty_area_points(int index) const;
  ::LSLAM::Points* add_ban_clean_and_sweep_penalty_area_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
      ban_clean_and_sweep_penalty_area_points() const;

  // repeated .LSLAM.TuyaSettingMsg.FanMotorLevel fan_motor_level = 12;
  int fan_motor_level_size() const;
  private:
  int _internal_fan_motor_level_size() const;
  public:
  void clear_fan_motor_level();
  private:
  ::LSLAM::TuyaSettingMsg_FanMotorLevel _internal_fan_motor_level(int index) const;
  void _internal_add_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_fan_motor_level();
  public:
  ::LSLAM::TuyaSettingMsg_FanMotorLevel fan_motor_level(int index) const;
  void set_fan_motor_level(int index, ::LSLAM::TuyaSettingMsg_FanMotorLevel value);
  void add_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& fan_motor_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_fan_motor_level();

  // repeated .LSLAM.TuyaSettingMsg.WaterBoxLevel water_box_level = 13;
  int water_box_level_size() const;
  private:
  int _internal_water_box_level_size() const;
  public:
  void clear_water_box_level();
  private:
  ::LSLAM::TuyaSettingMsg_WaterBoxLevel _internal_water_box_level(int index) const;
  void _internal_add_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_water_box_level();
  public:
  ::LSLAM::TuyaSettingMsg_WaterBoxLevel water_box_level(int index) const;
  void set_water_box_level(int index, ::LSLAM::TuyaSettingMsg_WaterBoxLevel value);
  void add_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& water_box_level() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_water_box_level();

  // repeated .LSLAM.TuyaSettingMsg.YtypeSweep ytype_sweep = 14;
  int ytype_sweep_size() const;
  private:
  int _internal_ytype_sweep_size() const;
  public:
  void clear_ytype_sweep();
  private:
  ::LSLAM::TuyaSettingMsg_YtypeSweep _internal_ytype_sweep(int index) const;
  void _internal_add_ytype_sweep(::LSLAM::TuyaSettingMsg_YtypeSweep value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ytype_sweep();
  public:
  ::LSLAM::TuyaSettingMsg_YtypeSweep ytype_sweep(int index) const;
  void set_ytype_sweep(int index, ::LSLAM::TuyaSettingMsg_YtypeSweep value);
  void add_ytype_sweep(::LSLAM::TuyaSettingMsg_YtypeSweep value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ytype_sweep() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ytype_sweep();

  // repeated int32 name_length = 15;
  int name_length_size() const;
  private:
  int _internal_name_length_size() const;
  public:
  void clear_name_length();
  private:
  int32_t _internal_name_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_name_length() const;
  void _internal_add_name_length(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_name_length();
  public:
  int32_t name_length(int index) const;
  void set_name_length(int index, int32_t value);
  void add_name_length(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      name_length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_name_length();

  // repeated string room_name = 17;
  int room_name_size() const;
  private:
  int _internal_room_name_size() const;
  public:
  void clear_room_name();
  const std::string& room_name(int index) const;
  std::string* mutable_room_name(int index);
  void set_room_name(int index, const std::string& value);
  void set_room_name(int index, std::string&& value);
  void set_room_name(int index, const char* value);
  void set_room_name(int index, const char* value, size_t size);
  std::string* add_room_name();
  void add_room_name(const std::string& value);
  void add_room_name(std::string&& value);
  void add_room_name(const char* value);
  void add_room_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& room_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_room_name();
  private:
  const std::string& _internal_room_name(int index) const;
  std::string* _internal_add_room_name();
  public:

  // repeated int32 timing_open_or_close = 26;
  int timing_open_or_close_size() const;
  private:
  int _internal_timing_open_or_close_size() const;
  public:
  void clear_timing_open_or_close();
  private:
  int32_t _internal_timing_open_or_close(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_timing_open_or_close() const;
  void _internal_add_timing_open_or_close(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_timing_open_or_close();
  public:
  int32_t timing_open_or_close(int index) const;
  void set_timing_open_or_close(int index, int32_t value);
  void add_timing_open_or_close(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      timing_open_or_close() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_timing_open_or_close();

  // repeated int32 timing_week = 27;
  int timing_week_size() const;
  private:
  int _internal_timing_week_size() const;
  public:
  void clear_timing_week();
  private:
  int32_t _internal_timing_week(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_timing_week() const;
  void _internal_add_timing_week(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_timing_week();
  public:
  int32_t timing_week(int index) const;
  void set_timing_week(int index, int32_t value);
  void add_timing_week(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      timing_week() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_timing_week();

  // repeated int32 timing_start_time = 28;
  int timing_start_time_size() const;
  private:
  int _internal_timing_start_time_size() const;
  public:
  void clear_timing_start_time();
  private:
  int32_t _internal_timing_start_time(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_timing_start_time() const;
  void _internal_add_timing_start_time(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_timing_start_time();
  public:
  int32_t timing_start_time(int index) const;
  void set_timing_start_time(int index, int32_t value);
  void add_timing_start_time(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      timing_start_time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_timing_start_time();

  // repeated .LSLAM.TuyaSettingMsg.CleanMode timing_clean_mode = 29;
  int timing_clean_mode_size() const;
  private:
  int _internal_timing_clean_mode_size() const;
  public:
  void clear_timing_clean_mode();
  private:
  ::LSLAM::TuyaSettingMsg_CleanMode _internal_timing_clean_mode(int index) const;
  void _internal_add_timing_clean_mode(::LSLAM::TuyaSettingMsg_CleanMode value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_timing_clean_mode();
  public:
  ::LSLAM::TuyaSettingMsg_CleanMode timing_clean_mode(int index) const;
  void set_timing_clean_mode(int index, ::LSLAM::TuyaSettingMsg_CleanMode value);
  void add_timing_clean_mode(::LSLAM::TuyaSettingMsg_CleanMode value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& timing_clean_mode() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_timing_clean_mode();

  // repeated int32 quiet_day = 30;
  int quiet_day_size() const;
  private:
  int _internal_quiet_day_size() const;
  public:
  void clear_quiet_day();
  private:
  int32_t _internal_quiet_day(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_quiet_day() const;
  void _internal_add_quiet_day(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_quiet_day();
  public:
  int32_t quiet_day(int index) const;
  void set_quiet_day(int index, int32_t value);
  void add_quiet_day(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      quiet_day() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_quiet_day();

  // .LSLAM.TuyaSettingMsg.SET clean_set = 1;
  void clear_clean_set();
  ::LSLAM::TuyaSettingMsg_SET clean_set() const;
  void set_clean_set(::LSLAM::TuyaSettingMsg_SET value);
  private:
  ::LSLAM::TuyaSettingMsg_SET _internal_clean_set() const;
  void _internal_set_clean_set(::LSLAM::TuyaSettingMsg_SET value);
  public:

  // int32 virtual_wall_number = 2;
  void clear_virtual_wall_number();
  int32_t virtual_wall_number() const;
  void set_virtual_wall_number(int32_t value);
  private:
  int32_t _internal_virtual_wall_number() const;
  void _internal_set_virtual_wall_number(int32_t value);
  public:

  // int32 ban_sweep_penalty_area_number = 8;
  void clear_ban_sweep_penalty_area_number();
  int32_t ban_sweep_penalty_area_number() const;
  void set_ban_sweep_penalty_area_number(int32_t value);
  private:
  int32_t _internal_ban_sweep_penalty_area_number() const;
  void _internal_set_ban_sweep_penalty_area_number(int32_t value);
  public:

  // int32 ban_clean_and_sweep_penalty_area_number = 10;
  void clear_ban_clean_and_sweep_penalty_area_number();
  int32_t ban_clean_and_sweep_penalty_area_number() const;
  void set_ban_clean_and_sweep_penalty_area_number(int32_t value);
  private:
  int32_t _internal_ban_clean_and_sweep_penalty_area_number() const;
  void _internal_set_ban_clean_and_sweep_penalty_area_number(int32_t value);
  public:

  // int32 time_zone = 18;
  void clear_time_zone();
  int32_t time_zone() const;
  void set_time_zone(int32_t value);
  private:
  int32_t _internal_time_zone() const;
  void _internal_set_time_zone(int32_t value);
  public:

  // int32 timing_number = 25;
  void clear_timing_number();
  int32_t timing_number() const;
  void set_timing_number(int32_t value);
  private:
  int32_t _internal_timing_number() const;
  void _internal_set_timing_number(int32_t value);
  public:

  // int32 quiet_start_time = 31;
  void clear_quiet_start_time();
  int32_t quiet_start_time() const;
  void set_quiet_start_time(int32_t value);
  private:
  int32_t _internal_quiet_start_time() const;
  void _internal_set_quiet_start_time(int32_t value);
  public:

  // int32 quiet_end_time = 32;
  void clear_quiet_end_time();
  int32_t quiet_end_time() const;
  void set_quiet_end_time(int32_t value);
  private:
  int32_t _internal_quiet_end_time() const;
  void _internal_set_quiet_end_time(int32_t value);
  public:

  // .LSLAM.TuyaSettingMsg.FanMotorLevel current_fan_motor_level = 34;
  void clear_current_fan_motor_level();
  ::LSLAM::TuyaSettingMsg_FanMotorLevel current_fan_motor_level() const;
  void set_current_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value);
  private:
  ::LSLAM::TuyaSettingMsg_FanMotorLevel _internal_current_fan_motor_level() const;
  void _internal_set_current_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value);
  public:

  // .LSLAM.TuyaSettingMsg.WaterBoxLevel current_water_box_level = 35;
  void clear_current_water_box_level();
  ::LSLAM::TuyaSettingMsg_WaterBoxLevel current_water_box_level() const;
  void set_current_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value);
  private:
  ::LSLAM::TuyaSettingMsg_WaterBoxLevel _internal_current_water_box_level() const;
  void _internal_set_current_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value);
  public:

  // bool do_not_disturb_switch_open = 33;
  void clear_do_not_disturb_switch_open();
  bool do_not_disturb_switch_open() const;
  void set_do_not_disturb_switch_open(bool value);
  private:
  bool _internal_do_not_disturb_switch_open() const;
  void _internal_set_do_not_disturb_switch_open(bool value);
  public:

  // bool breakpoint_continue_to_sweep = 37;
  void clear_breakpoint_continue_to_sweep();
  bool breakpoint_continue_to_sweep() const;
  void set_breakpoint_continue_to_sweep(bool value);
  private:
  bool _internal_breakpoint_continue_to_sweep() const;
  void _internal_set_breakpoint_continue_to_sweep(bool value);
  public:

  // int32 volume = 36;
  void clear_volume();
  int32_t volume() const;
  void set_volume(int32_t value);
  private:
  int32_t _internal_volume() const;
  void _internal_set_volume(int32_t value);
  public:

  // int32 set_result = 38;
  void clear_set_result();
  int32_t set_result() const;
  void set_set_result(int32_t value);
  private:
  int32_t _internal_set_result() const;
  void _internal_set_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.TuyaSettingMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > virtual_wall_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > clean_time_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _clean_time_number_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > room_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _room_number_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _room_id_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > partition_segmentation_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > ban_sweep_penalty_area_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points > ban_clean_and_sweep_penalty_area_points_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> fan_motor_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _fan_motor_level_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> water_box_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _water_box_level_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ytype_sweep_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _ytype_sweep_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > name_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _name_length_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> room_name_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > timing_open_or_close_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _timing_open_or_close_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > timing_week_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _timing_week_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > timing_start_time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _timing_start_time_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> timing_clean_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _timing_clean_mode_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > quiet_day_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _quiet_day_cached_byte_size_;
    int clean_set_;
    int32_t virtual_wall_number_;
    int32_t ban_sweep_penalty_area_number_;
    int32_t ban_clean_and_sweep_penalty_area_number_;
    int32_t time_zone_;
    int32_t timing_number_;
    int32_t quiet_start_time_;
    int32_t quiet_end_time_;
    int current_fan_motor_level_;
    int current_water_box_level_;
    bool do_not_disturb_switch_open_;
    bool breakpoint_continue_to_sweep_;
    int32_t volume_;
    int32_t set_result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class RobotStatusMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.RobotStatusMsg) */ {
 public:
  inline RobotStatusMsg() : RobotStatusMsg(nullptr) {}
  ~RobotStatusMsg() override;
  explicit PROTOBUF_CONSTEXPR RobotStatusMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotStatusMsg(const RobotStatusMsg& from);
  RobotStatusMsg(RobotStatusMsg&& from) noexcept
    : RobotStatusMsg() {
    *this = ::std::move(from);
  }

  inline RobotStatusMsg& operator=(const RobotStatusMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStatusMsg& operator=(RobotStatusMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotStatusMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotStatusMsg* internal_default_instance() {
    return reinterpret_cast<const RobotStatusMsg*>(
               &_RobotStatusMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotStatusMsg& a, RobotStatusMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStatusMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStatusMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotStatusMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotStatusMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotStatusMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotStatusMsg& from) {
    RobotStatusMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStatusMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.RobotStatusMsg";
  }
  protected:
  explicit RobotStatusMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RobotStatusMsg_STATUS STATUS;
  static constexpr STATUS initial =
    RobotStatusMsg_STATUS_initial;
  static constexpr STATUS smart =
    RobotStatusMsg_STATUS_smart;
  static constexpr STATUS zone_clean =
    RobotStatusMsg_STATUS_zone_clean;
  static constexpr STATUS part_clean =
    RobotStatusMsg_STATUS_part_clean;
  static constexpr STATUS cleaning =
    RobotStatusMsg_STATUS_cleaning;
  static constexpr STATUS paused =
    RobotStatusMsg_STATUS_paused;
  static constexpr STATUS goto_pos =
    RobotStatusMsg_STATUS_goto_pos;
  static constexpr STATUS pos_arrived =
    RobotStatusMsg_STATUS_pos_arrived;
  static constexpr STATUS pos_unarrive =
    RobotStatusMsg_STATUS_pos_unarrive;
  static constexpr STATUS goto_charge =
    RobotStatusMsg_STATUS_goto_charge;
  static constexpr STATUS charging =
    RobotStatusMsg_STATUS_charging;
  static constexpr STATUS charge_done =
    RobotStatusMsg_STATUS_charge_done;
  static constexpr STATUS sleep =
    RobotStatusMsg_STATUS_sleep;
  static constexpr STATUS select_room =
    RobotStatusMsg_STATUS_select_room;
  static constexpr STATUS aim_clean =
    RobotStatusMsg_STATUS_aim_clean;
  static constexpr STATUS control_clean =
    RobotStatusMsg_STATUS_control_clean;
  static constexpr STATUS explore =
    RobotStatusMsg_STATUS_explore;
  static constexpr STATUS come_down_from_partner =
    RobotStatusMsg_STATUS_come_down_from_partner;
  static constexpr STATUS standby =
    RobotStatusMsg_STATUS_standby;
  static inline bool STATUS_IsValid(int value) {
    return RobotStatusMsg_STATUS_IsValid(value);
  }
  static constexpr STATUS STATUS_MIN =
    RobotStatusMsg_STATUS_STATUS_MIN;
  static constexpr STATUS STATUS_MAX =
    RobotStatusMsg_STATUS_STATUS_MAX;
  static constexpr int STATUS_ARRAYSIZE =
    RobotStatusMsg_STATUS_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  STATUS_descriptor() {
    return RobotStatusMsg_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function STATUS_Name.");
    return RobotStatusMsg_STATUS_Name(enum_t_value);
  }
  static inline bool STATUS_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      STATUS* value) {
    return RobotStatusMsg_STATUS_Parse(name, value);
  }

  typedef RobotStatusMsg_Fault Fault;
  static constexpr Fault no_fault =
    RobotStatusMsg_Fault_no_fault;
  static constexpr Fault edge_sweep_fault =
    RobotStatusMsg_Fault_edge_sweep_fault;
  static constexpr Fault middle_sweel_fault =
    RobotStatusMsg_Fault_middle_sweel_fault;
  static constexpr Fault left_wheel_fault =
    RobotStatusMsg_Fault_left_wheel_fault;
  static constexpr Fault right_wheel_fault =
    RobotStatusMsg_Fault_right_wheel_fault;
  static constexpr Fault garbage_box_fault =
    RobotStatusMsg_Fault_garbage_box_fault;
  static constexpr Fault land_check_fault =
    RobotStatusMsg_Fault_land_check_fault;
  static constexpr Fault collision_fault =
    RobotStatusMsg_Fault_collision_fault;
  static constexpr Fault laser_ranging_sensor_fault =
    RobotStatusMsg_Fault_laser_ranging_sensor_fault;
  static constexpr Fault D_TOF_fault =
    RobotStatusMsg_Fault_D_TOF_fault;
  static constexpr Fault edge_sensor_fault =
    RobotStatusMsg_Fault_edge_sensor_fault;
  static constexpr Fault low_water_volume_of_water_tank =
    RobotStatusMsg_Fault_low_water_volume_of_water_tank;
  static constexpr Fault dust_box_is_full =
    RobotStatusMsg_Fault_dust_box_is_full;
  static constexpr Fault dust_box_removed =
    RobotStatusMsg_Fault_dust_box_removed;
  static constexpr Fault abnormal_installation_of_dust_box =
    RobotStatusMsg_Fault_abnormal_installation_of_dust_box;
  static constexpr Fault abnormal_installation_of_roller_brush =
    RobotStatusMsg_Fault_abnormal_installation_of_roller_brush;
  static constexpr Fault the_drive_wheel_is_entangled =
    RobotStatusMsg_Fault_the_drive_wheel_is_entangled;
  static constexpr Fault fan_blocked =
    RobotStatusMsg_Fault_fan_blocked;
  static constexpr Fault battery_is_too_low_return_to_charging =
    RobotStatusMsg_Fault_battery_is_too_low_return_to_charging;
  static constexpr Fault battery_is_too_low_stop_cleaning =
    RobotStatusMsg_Fault_battery_is_too_low_stop_cleaning;
  static constexpr Fault power_is_less_than_20 =
    RobotStatusMsg_Fault_power_is_less_than_20;
  static constexpr Fault charging_electrode_of_base_station_is_dirty =
    RobotStatusMsg_Fault_charging_electrode_of_base_station_is_dirty;
  static constexpr Fault complete_the_cleaning_task =
    RobotStatusMsg_Fault_complete_the_cleaning_task;
  static constexpr Fault sweeping_area_blocked =
    RobotStatusMsg_Fault_sweeping_area_blocked;
  static constexpr Fault start_in_restricted_area =
    RobotStatusMsg_Fault_start_in_restricted_area;
  static constexpr Fault cleaning_area_does_not_exist =
    RobotStatusMsg_Fault_cleaning_area_does_not_exist;
  static constexpr Fault positioning_abnormality =
    RobotStatusMsg_Fault_positioning_abnormality;
  static constexpr Fault unable_to_continue_working =
    RobotStatusMsg_Fault_unable_to_continue_working;
  static constexpr Fault unable_to_return_to_base_station =
    RobotStatusMsg_Fault_unable_to_return_to_base_station;
  static constexpr Fault water_shortage_in_water_tank =
    RobotStatusMsg_Fault_water_shortage_in_water_tank;
  static constexpr Fault water_tank_not_installed_in_place =
    RobotStatusMsg_Fault_water_tank_not_installed_in_place;
  static constexpr Fault water_tank_is_full =
    RobotStatusMsg_Fault_water_tank_is_full;
  static constexpr Fault dust_collection_bag_is_full =
    RobotStatusMsg_Fault_dust_collection_bag_is_full;
  static constexpr Fault dust_collection_failed =
    RobotStatusMsg_Fault_dust_collection_failed;
  static constexpr Fault sewage_tank_is_full =
    RobotStatusMsg_Fault_sewage_tank_is_full;
  static constexpr Fault sewage_tank_cannot_be_recycled =
    RobotStatusMsg_Fault_sewage_tank_cannot_be_recycled;
  static constexpr Fault heating_system_fault =
    RobotStatusMsg_Fault_heating_system_fault;
  static constexpr Fault mop_drying_tips =
    RobotStatusMsg_Fault_mop_drying_tips;
  static constexpr Fault enclosure_tank_cover_not_fully_closed =
    RobotStatusMsg_Fault_enclosure_tank_cover_not_fully_closed;
  static constexpr Fault housing_dust_box_not_fully_closed =
    RobotStatusMsg_Fault_housing_dust_box_not_fully_closed;
  static constexpr Fault broom_water =
    RobotStatusMsg_Fault_broom_water;
  static constexpr Fault sweeping_machine_pumping =
    RobotStatusMsg_Fault_sweeping_machine_pumping;
  static constexpr Fault host_start =
    RobotStatusMsg_Fault_host_start;
  static constexpr Fault host_pause =
    RobotStatusMsg_Fault_host_pause;
  static constexpr Fault suspension_sensor_fault =
    RobotStatusMsg_Fault_suspension_sensor_fault;
  static constexpr Fault not_in_horizontal_plane =
    RobotStatusMsg_Fault_not_in_horizontal_plane;
  static constexpr Fault check_the_radar_upper_cover =
    RobotStatusMsg_Fault_check_the_radar_upper_cover;
  static constexpr Fault abnormal_noise_of_main_engine =
    RobotStatusMsg_Fault_abnormal_noise_of_main_engine;
  static constexpr Fault sudden_stop =
    RobotStatusMsg_Fault_sudden_stop;
  static constexpr Fault not_start_after_charging =
    RobotStatusMsg_Fault_not_start_after_charging;
  static constexpr Fault rebuild_drawing =
    RobotStatusMsg_Fault_rebuild_drawing;
  static constexpr Fault pause_during_running =
    RobotStatusMsg_Fault_pause_during_running;
  static constexpr Fault dust_duct_blockage =
    RobotStatusMsg_Fault_dust_duct_blockage;
  static constexpr Fault excessive_dust =
    RobotStatusMsg_Fault_excessive_dust;
  static constexpr Fault pick_up =
    RobotStatusMsg_Fault_pick_up;
  static constexpr Fault dangling_handling =
    RobotStatusMsg_Fault_dangling_handling;
  static constexpr Fault trapped =
    RobotStatusMsg_Fault_trapped;
  static constexpr Fault mop_brush_motor_is_not_setup =
    RobotStatusMsg_Fault_mop_brush_motor_is_not_setup;
  static constexpr Fault edge_brush_motor_is_not_setuo =
    RobotStatusMsg_Fault_edge_brush_motor_is_not_setuo;
  static constexpr Fault edge_sweep_err =
    RobotStatusMsg_Fault_edge_sweep_err;
  static constexpr Fault middle_sweel_err =
    RobotStatusMsg_Fault_middle_sweel_err;
  static constexpr Fault battery_error =
    RobotStatusMsg_Fault_battery_error;
  static constexpr Fault fan_motor_error =
    RobotStatusMsg_Fault_fan_motor_error;
  static constexpr Fault mop_brush_motor_is_twine =
    RobotStatusMsg_Fault_mop_brush_motor_is_twine;
  static constexpr Fault mop_brush_motor_is_err =
    RobotStatusMsg_Fault_mop_brush_motor_is_err;
  static constexpr Fault partner_clean_water_box_is_not_exist =
    RobotStatusMsg_Fault_partner_clean_water_box_is_not_exist;
  static constexpr Fault partner_waste_water_box_is_not_exist =
    RobotStatusMsg_Fault_partner_waste_water_box_is_not_exist;
  static constexpr Fault partner_water_overflow =
    RobotStatusMsg_Fault_partner_water_overflow;
  static constexpr Fault partner_dust_collection_err =
    RobotStatusMsg_Fault_partner_dust_collection_err;
  static constexpr Fault partner_clean_mop_err =
    RobotStatusMsg_Fault_partner_clean_mop_err;
  static constexpr Fault partner_drying_mop_err =
    RobotStatusMsg_Fault_partner_drying_mop_err;
  static constexpr Fault partner_air_blower_error_err =
    RobotStatusMsg_Fault_partner_air_blower_error_err;
  static constexpr Fault dry_mop_temperature_err =
    RobotStatusMsg_Fault_dry_mop_temperature_err;
  static constexpr Fault start_up_when_slant =
    RobotStatusMsg_Fault_start_up_when_slant;
  static inline bool Fault_IsValid(int value) {
    return RobotStatusMsg_Fault_IsValid(value);
  }
  static constexpr Fault Fault_MIN =
    RobotStatusMsg_Fault_Fault_MIN;
  static constexpr Fault Fault_MAX =
    RobotStatusMsg_Fault_Fault_MAX;
  static constexpr int Fault_ARRAYSIZE =
    RobotStatusMsg_Fault_Fault_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Fault_descriptor() {
    return RobotStatusMsg_Fault_descriptor();
  }
  template<typename T>
  static inline const std::string& Fault_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Fault>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Fault_Name.");
    return RobotStatusMsg_Fault_Name(enum_t_value);
  }
  static inline bool Fault_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Fault* value) {
    return RobotStatusMsg_Fault_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentStatusFieldNumber = 1,
    kCurrentFaultFieldNumber = 2,
  };
  // .LSLAM.RobotStatusMsg.STATUS current_status = 1;
  void clear_current_status();
  ::LSLAM::RobotStatusMsg_STATUS current_status() const;
  void set_current_status(::LSLAM::RobotStatusMsg_STATUS value);
  private:
  ::LSLAM::RobotStatusMsg_STATUS _internal_current_status() const;
  void _internal_set_current_status(::LSLAM::RobotStatusMsg_STATUS value);
  public:

  // .LSLAM.RobotStatusMsg.Fault current_fault = 2;
  void clear_current_fault();
  ::LSLAM::RobotStatusMsg_Fault current_fault() const;
  void set_current_fault(::LSLAM::RobotStatusMsg_Fault value);
  private:
  ::LSLAM::RobotStatusMsg_Fault _internal_current_fault() const;
  void _internal_set_current_fault(::LSLAM::RobotStatusMsg_Fault value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.RobotStatusMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int current_status_;
    int current_fault_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class DeviceMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.DeviceMsg) */ {
 public:
  inline DeviceMsg() : DeviceMsg(nullptr) {}
  ~DeviceMsg() override;
  explicit PROTOBUF_CONSTEXPR DeviceMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMsg(const DeviceMsg& from);
  DeviceMsg(DeviceMsg&& from) noexcept
    : DeviceMsg() {
    *this = ::std::move(from);
  }

  inline DeviceMsg& operator=(const DeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMsg& operator=(DeviceMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceMsg* internal_default_instance() {
    return reinterpret_cast<const DeviceMsg*>(
               &_DeviceMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeviceMsg& a, DeviceMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceMsg& from) {
    DeviceMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.DeviceMsg";
  }
  protected:
  explicit DeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWifiNameFieldNumber = 1,
    kIDFieldNumber = 3,
    kMacFieldNumber = 4,
    kMCUVerssionFieldNumber = 5,
    kFirmwareVersionFieldNumber = 6,
    kDeviceSNFieldNumber = 7,
    kModuleUUIDFieldNumber = 8,
    kRSSIFieldNumber = 2,
  };
  // string Wifi_name = 1;
  void clear_wifi_name();
  const std::string& wifi_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wifi_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wifi_name();
  PROTOBUF_NODISCARD std::string* release_wifi_name();
  void set_allocated_wifi_name(std::string* wifi_name);
  private:
  const std::string& _internal_wifi_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wifi_name(const std::string& value);
  std::string* _internal_mutable_wifi_name();
  public:

  // string ID = 3;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string Mac = 4;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string MCU_Verssion = 5;
  void clear_mcu_verssion();
  const std::string& mcu_verssion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcu_verssion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcu_verssion();
  PROTOBUF_NODISCARD std::string* release_mcu_verssion();
  void set_allocated_mcu_verssion(std::string* mcu_verssion);
  private:
  const std::string& _internal_mcu_verssion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcu_verssion(const std::string& value);
  std::string* _internal_mutable_mcu_verssion();
  public:

  // string Firmware_Version = 6;
  void clear_firmware_version();
  const std::string& firmware_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_version();
  PROTOBUF_NODISCARD std::string* release_firmware_version();
  void set_allocated_firmware_version(std::string* firmware_version);
  private:
  const std::string& _internal_firmware_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(const std::string& value);
  std::string* _internal_mutable_firmware_version();
  public:

  // string device_SN = 7;
  void clear_device_sn();
  const std::string& device_sn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_sn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_sn();
  PROTOBUF_NODISCARD std::string* release_device_sn();
  void set_allocated_device_sn(std::string* device_sn);
  private:
  const std::string& _internal_device_sn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_sn(const std::string& value);
  std::string* _internal_mutable_device_sn();
  public:

  // string module_UUID = 8;
  void clear_module_uuid();
  const std::string& module_uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_uuid();
  PROTOBUF_NODISCARD std::string* release_module_uuid();
  void set_allocated_module_uuid(std::string* module_uuid);
  private:
  const std::string& _internal_module_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_uuid(const std::string& value);
  std::string* _internal_mutable_module_uuid();
  public:

  // int32 RSSI = 2;
  void clear_rssi();
  int32_t rssi() const;
  void set_rssi(int32_t value);
  private:
  int32_t _internal_rssi() const;
  void _internal_set_rssi(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.DeviceMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wifi_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcu_verssion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_sn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_uuid_;
    int32_t rssi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class CleanRecordMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.CleanRecordMsg) */ {
 public:
  inline CleanRecordMsg() : CleanRecordMsg(nullptr) {}
  ~CleanRecordMsg() override;
  explicit PROTOBUF_CONSTEXPR CleanRecordMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanRecordMsg(const CleanRecordMsg& from);
  CleanRecordMsg(CleanRecordMsg&& from) noexcept
    : CleanRecordMsg() {
    *this = ::std::move(from);
  }

  inline CleanRecordMsg& operator=(const CleanRecordMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanRecordMsg& operator=(CleanRecordMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanRecordMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanRecordMsg* internal_default_instance() {
    return reinterpret_cast<const CleanRecordMsg*>(
               &_CleanRecordMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CleanRecordMsg& a, CleanRecordMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanRecordMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanRecordMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanRecordMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanRecordMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanRecordMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanRecordMsg& from) {
    CleanRecordMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanRecordMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.CleanRecordMsg";
  }
  protected:
  explicit CleanRecordMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCleanTimeFieldNumber = 1,
    kCleanAreaFieldNumber = 2,
    kAllCleanTimeFieldNumber = 4,
    kCleanTimeNumberFieldNumber = 3,
    kAllCleanTimeNumberFieldNumber = 6,
    kAllCleanAreaFieldNumber = 5,
    kCleanPercentageFieldNumber = 7,
  };
  // double clean_time = 1;
  void clear_clean_time();
  double clean_time() const;
  void set_clean_time(double value);
  private:
  double _internal_clean_time() const;
  void _internal_set_clean_time(double value);
  public:

  // double clean_area = 2;
  void clear_clean_area();
  double clean_area() const;
  void set_clean_area(double value);
  private:
  double _internal_clean_area() const;
  void _internal_set_clean_area(double value);
  public:

  // double all_clean_time = 4;
  void clear_all_clean_time();
  double all_clean_time() const;
  void set_all_clean_time(double value);
  private:
  double _internal_all_clean_time() const;
  void _internal_set_all_clean_time(double value);
  public:

  // int32 clean_time_number = 3;
  void clear_clean_time_number();
  int32_t clean_time_number() const;
  void set_clean_time_number(int32_t value);
  private:
  int32_t _internal_clean_time_number() const;
  void _internal_set_clean_time_number(int32_t value);
  public:

  // int32 all_clean_time_number = 6;
  void clear_all_clean_time_number();
  int32_t all_clean_time_number() const;
  void set_all_clean_time_number(int32_t value);
  private:
  int32_t _internal_all_clean_time_number() const;
  void _internal_set_all_clean_time_number(int32_t value);
  public:

  // double all_clean_area = 5;
  void clear_all_clean_area();
  double all_clean_area() const;
  void set_all_clean_area(double value);
  private:
  double _internal_all_clean_area() const;
  void _internal_set_all_clean_area(double value);
  public:

  // double clean_percentage = 7;
  void clear_clean_percentage();
  double clean_percentage() const;
  void set_clean_percentage(double value);
  private:
  double _internal_clean_percentage() const;
  void _internal_set_clean_percentage(double value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.CleanRecordMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double clean_time_;
    double clean_area_;
    double all_clean_time_;
    int32_t clean_time_number_;
    int32_t all_clean_time_number_;
    double all_clean_area_;
    double clean_percentage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class CleanDeviceMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.CleanDeviceMsg) */ {
 public:
  inline CleanDeviceMsg() : CleanDeviceMsg(nullptr) {}
  ~CleanDeviceMsg() override;
  explicit PROTOBUF_CONSTEXPR CleanDeviceMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CleanDeviceMsg(const CleanDeviceMsg& from);
  CleanDeviceMsg(CleanDeviceMsg&& from) noexcept
    : CleanDeviceMsg() {
    *this = ::std::move(from);
  }

  inline CleanDeviceMsg& operator=(const CleanDeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanDeviceMsg& operator=(CleanDeviceMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CleanDeviceMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CleanDeviceMsg* internal_default_instance() {
    return reinterpret_cast<const CleanDeviceMsg*>(
               &_CleanDeviceMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CleanDeviceMsg& a, CleanDeviceMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanDeviceMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CleanDeviceMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CleanDeviceMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CleanDeviceMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CleanDeviceMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CleanDeviceMsg& from) {
    CleanDeviceMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanDeviceMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.CleanDeviceMsg";
  }
  protected:
  explicit CleanDeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgeBrushLifeFieldNumber = 1,
    kRollBrushLifeFieldNumber = 2,
    kFilterLifeFieldNumber = 3,
    kRagLifeFieldNumber = 4,
  };
  // int32 edge_brush_life = 1;
  void clear_edge_brush_life();
  int32_t edge_brush_life() const;
  void set_edge_brush_life(int32_t value);
  private:
  int32_t _internal_edge_brush_life() const;
  void _internal_set_edge_brush_life(int32_t value);
  public:

  // int32 roll_brush_life = 2;
  void clear_roll_brush_life();
  int32_t roll_brush_life() const;
  void set_roll_brush_life(int32_t value);
  private:
  int32_t _internal_roll_brush_life() const;
  void _internal_set_roll_brush_life(int32_t value);
  public:

  // int32 filter_life = 3;
  void clear_filter_life();
  int32_t filter_life() const;
  void set_filter_life(int32_t value);
  private:
  int32_t _internal_filter_life() const;
  void _internal_set_filter_life(int32_t value);
  public:

  // int32 rag_life = 4;
  void clear_rag_life();
  int32_t rag_life() const;
  void set_rag_life(int32_t value);
  private:
  int32_t _internal_rag_life() const;
  void _internal_set_rag_life(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.CleanDeviceMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t edge_brush_life_;
    int32_t roll_brush_life_;
    int32_t filter_life_;
    int32_t rag_life_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class LanguagePackMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.LanguagePackMsg) */ {
 public:
  inline LanguagePackMsg() : LanguagePackMsg(nullptr) {}
  ~LanguagePackMsg() override;
  explicit PROTOBUF_CONSTEXPR LanguagePackMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LanguagePackMsg(const LanguagePackMsg& from);
  LanguagePackMsg(LanguagePackMsg&& from) noexcept
    : LanguagePackMsg() {
    *this = ::std::move(from);
  }

  inline LanguagePackMsg& operator=(const LanguagePackMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanguagePackMsg& operator=(LanguagePackMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanguagePackMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const LanguagePackMsg* internal_default_instance() {
    return reinterpret_cast<const LanguagePackMsg*>(
               &_LanguagePackMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LanguagePackMsg& a, LanguagePackMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(LanguagePackMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanguagePackMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanguagePackMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LanguagePackMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LanguagePackMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LanguagePackMsg& from) {
    LanguagePackMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanguagePackMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.LanguagePackMsg";
  }
  protected:
  explicit LanguagePackMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LanguagePackMsg_DownloadStatus DownloadStatus;
  static constexpr DownloadStatus DOWNLOAD_FAILED =
    LanguagePackMsg_DownloadStatus_DOWNLOAD_FAILED;
  static constexpr DownloadStatus INSTALLING =
    LanguagePackMsg_DownloadStatus_INSTALLING;
  static constexpr DownloadStatus INSTALL_SUCCESS =
    LanguagePackMsg_DownloadStatus_INSTALL_SUCCESS;
  static constexpr DownloadStatus USING =
    LanguagePackMsg_DownloadStatus_USING;
  static inline bool DownloadStatus_IsValid(int value) {
    return LanguagePackMsg_DownloadStatus_IsValid(value);
  }
  static constexpr DownloadStatus DownloadStatus_MIN =
    LanguagePackMsg_DownloadStatus_DownloadStatus_MIN;
  static constexpr DownloadStatus DownloadStatus_MAX =
    LanguagePackMsg_DownloadStatus_DownloadStatus_MAX;
  static constexpr int DownloadStatus_ARRAYSIZE =
    LanguagePackMsg_DownloadStatus_DownloadStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DownloadStatus_descriptor() {
    return LanguagePackMsg_DownloadStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& DownloadStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DownloadStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DownloadStatus_Name.");
    return LanguagePackMsg_DownloadStatus_Name(enum_t_value);
  }
  static inline bool DownloadStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DownloadStatus* value) {
    return LanguagePackMsg_DownloadStatus_Parse(name, value);
  }

  typedef LanguagePackMsg_LanguageType LanguageType;
  static constexpr LanguageType SIMPLIFIED_CHINESE =
    LanguagePackMsg_LanguageType_SIMPLIFIED_CHINESE;
  static constexpr LanguageType TRADITIONAL_CHINESE =
    LanguagePackMsg_LanguageType_TRADITIONAL_CHINESE;
  static constexpr LanguageType ENGLISH =
    LanguagePackMsg_LanguageType_ENGLISH;
  static constexpr LanguageType GRTMAN =
    LanguagePackMsg_LanguageType_GRTMAN;
  static constexpr LanguageType FRENCH =
    LanguagePackMsg_LanguageType_FRENCH;
  static constexpr LanguageType RUSSIAN =
    LanguagePackMsg_LanguageType_RUSSIAN;
  static constexpr LanguageType SPANISH =
    LanguagePackMsg_LanguageType_SPANISH;
  static constexpr LanguageType KOREAN =
    LanguagePackMsg_LanguageType_KOREAN;
  static constexpr LanguageType LATIN =
    LanguagePackMsg_LanguageType_LATIN;
  static constexpr LanguageType PORTUGUESE =
    LanguagePackMsg_LanguageType_PORTUGUESE;
  static constexpr LanguageType JAPANESE =
    LanguagePackMsg_LanguageType_JAPANESE;
  static constexpr LanguageType ITALIAN =
    LanguagePackMsg_LanguageType_ITALIAN;
  static inline bool LanguageType_IsValid(int value) {
    return LanguagePackMsg_LanguageType_IsValid(value);
  }
  static constexpr LanguageType LanguageType_MIN =
    LanguagePackMsg_LanguageType_LanguageType_MIN;
  static constexpr LanguageType LanguageType_MAX =
    LanguagePackMsg_LanguageType_LanguageType_MAX;
  static constexpr int LanguageType_ARRAYSIZE =
    LanguagePackMsg_LanguageType_LanguageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LanguageType_descriptor() {
    return LanguagePackMsg_LanguageType_descriptor();
  }
  template<typename T>
  static inline const std::string& LanguageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LanguageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LanguageType_Name.");
    return LanguagePackMsg_LanguageType_Name(enum_t_value);
  }
  static inline bool LanguageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LanguageType* value) {
    return LanguagePackMsg_LanguageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCheckCodeFieldNumber = 5,
    kLanguagePackUrlFieldNumber = 7,
    kDownloadStatusFieldNumber = 1,
    kDownloadAndInstallScheduFieldNumber = 2,
    kLanguageFieldNumber = 3,
    kCheckCodeLengthFieldNumber = 4,
    kLanguagePackUrlLengthFieldNumber = 6,
  };
  // string check_code = 5;
  void clear_check_code();
  const std::string& check_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_code();
  PROTOBUF_NODISCARD std::string* release_check_code();
  void set_allocated_check_code(std::string* check_code);
  private:
  const std::string& _internal_check_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_code(const std::string& value);
  std::string* _internal_mutable_check_code();
  public:

  // string language_pack_url = 7;
  void clear_language_pack_url();
  const std::string& language_pack_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_pack_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_pack_url();
  PROTOBUF_NODISCARD std::string* release_language_pack_url();
  void set_allocated_language_pack_url(std::string* language_pack_url);
  private:
  const std::string& _internal_language_pack_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_pack_url(const std::string& value);
  std::string* _internal_mutable_language_pack_url();
  public:

  // .LSLAM.LanguagePackMsg.DownloadStatus download_status = 1;
  void clear_download_status();
  ::LSLAM::LanguagePackMsg_DownloadStatus download_status() const;
  void set_download_status(::LSLAM::LanguagePackMsg_DownloadStatus value);
  private:
  ::LSLAM::LanguagePackMsg_DownloadStatus _internal_download_status() const;
  void _internal_set_download_status(::LSLAM::LanguagePackMsg_DownloadStatus value);
  public:

  // int32 download_and_install_schedu = 2;
  void clear_download_and_install_schedu();
  int32_t download_and_install_schedu() const;
  void set_download_and_install_schedu(int32_t value);
  private:
  int32_t _internal_download_and_install_schedu() const;
  void _internal_set_download_and_install_schedu(int32_t value);
  public:

  // .LSLAM.LanguagePackMsg.LanguageType language = 3;
  void clear_language();
  ::LSLAM::LanguagePackMsg_LanguageType language() const;
  void set_language(::LSLAM::LanguagePackMsg_LanguageType value);
  private:
  ::LSLAM::LanguagePackMsg_LanguageType _internal_language() const;
  void _internal_set_language(::LSLAM::LanguagePackMsg_LanguageType value);
  public:

  // int32 check_code_length = 4;
  void clear_check_code_length();
  int32_t check_code_length() const;
  void set_check_code_length(int32_t value);
  private:
  int32_t _internal_check_code_length() const;
  void _internal_set_check_code_length(int32_t value);
  public:

  // int32 language_pack_url_length = 6;
  void clear_language_pack_url_length();
  int32_t language_pack_url_length() const;
  void set_language_pack_url_length(int32_t value);
  private:
  int32_t _internal_language_pack_url_length() const;
  void _internal_set_language_pack_url_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.LanguagePackMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_pack_url_;
    int download_status_;
    int32_t download_and_install_schedu_;
    int language_;
    int32_t check_code_length_;
    int32_t language_pack_url_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// -------------------------------------------------------------------

class TuyaDpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.TuyaDpMsg) */ {
 public:
  inline TuyaDpMsg() : TuyaDpMsg(nullptr) {}
  ~TuyaDpMsg() override;
  explicit PROTOBUF_CONSTEXPR TuyaDpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TuyaDpMsg(const TuyaDpMsg& from);
  TuyaDpMsg(TuyaDpMsg&& from) noexcept
    : TuyaDpMsg() {
    *this = ::std::move(from);
  }

  inline TuyaDpMsg& operator=(const TuyaDpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TuyaDpMsg& operator=(TuyaDpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TuyaDpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TuyaDpMsg* internal_default_instance() {
    return reinterpret_cast<const TuyaDpMsg*>(
               &_TuyaDpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TuyaDpMsg& a, TuyaDpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TuyaDpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TuyaDpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TuyaDpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TuyaDpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TuyaDpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TuyaDpMsg& from) {
    TuyaDpMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TuyaDpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.TuyaDpMsg";
  }
  protected:
  explicit TuyaDpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCleanDeviceMsgFieldNumber = 1,
    kCleanRecordMsgFieldNumber = 2,
    kDeviceMsgFieldNumber = 3,
    kRobotStatusMsgFieldNumber = 5,
    kLanguagePackMsgFieldNumber = 6,
    kTuyaSettingMsgFieldNumber = 7,
    kTuyaCommandMsgFieldNumber = 8,
    kBatteryPercentageFieldNumber = 4,
    kCommandOrSettingFieldNumber = 9,
    kStartupModeFieldNumber = 10,
  };
  // .LSLAM.CleanDeviceMsg clean_device_msg = 1;
  bool has_clean_device_msg() const;
  private:
  bool _internal_has_clean_device_msg() const;
  public:
  void clear_clean_device_msg();
  const ::LSLAM::CleanDeviceMsg& clean_device_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::CleanDeviceMsg* release_clean_device_msg();
  ::LSLAM::CleanDeviceMsg* mutable_clean_device_msg();
  void set_allocated_clean_device_msg(::LSLAM::CleanDeviceMsg* clean_device_msg);
  private:
  const ::LSLAM::CleanDeviceMsg& _internal_clean_device_msg() const;
  ::LSLAM::CleanDeviceMsg* _internal_mutable_clean_device_msg();
  public:
  void unsafe_arena_set_allocated_clean_device_msg(
      ::LSLAM::CleanDeviceMsg* clean_device_msg);
  ::LSLAM::CleanDeviceMsg* unsafe_arena_release_clean_device_msg();

  // .LSLAM.CleanRecordMsg clean_record_msg = 2;
  bool has_clean_record_msg() const;
  private:
  bool _internal_has_clean_record_msg() const;
  public:
  void clear_clean_record_msg();
  const ::LSLAM::CleanRecordMsg& clean_record_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::CleanRecordMsg* release_clean_record_msg();
  ::LSLAM::CleanRecordMsg* mutable_clean_record_msg();
  void set_allocated_clean_record_msg(::LSLAM::CleanRecordMsg* clean_record_msg);
  private:
  const ::LSLAM::CleanRecordMsg& _internal_clean_record_msg() const;
  ::LSLAM::CleanRecordMsg* _internal_mutable_clean_record_msg();
  public:
  void unsafe_arena_set_allocated_clean_record_msg(
      ::LSLAM::CleanRecordMsg* clean_record_msg);
  ::LSLAM::CleanRecordMsg* unsafe_arena_release_clean_record_msg();

  // .LSLAM.DeviceMsg device_msg = 3;
  bool has_device_msg() const;
  private:
  bool _internal_has_device_msg() const;
  public:
  void clear_device_msg();
  const ::LSLAM::DeviceMsg& device_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::DeviceMsg* release_device_msg();
  ::LSLAM::DeviceMsg* mutable_device_msg();
  void set_allocated_device_msg(::LSLAM::DeviceMsg* device_msg);
  private:
  const ::LSLAM::DeviceMsg& _internal_device_msg() const;
  ::LSLAM::DeviceMsg* _internal_mutable_device_msg();
  public:
  void unsafe_arena_set_allocated_device_msg(
      ::LSLAM::DeviceMsg* device_msg);
  ::LSLAM::DeviceMsg* unsafe_arena_release_device_msg();

  // .LSLAM.RobotStatusMsg robot_status_msg = 5;
  bool has_robot_status_msg() const;
  private:
  bool _internal_has_robot_status_msg() const;
  public:
  void clear_robot_status_msg();
  const ::LSLAM::RobotStatusMsg& robot_status_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::RobotStatusMsg* release_robot_status_msg();
  ::LSLAM::RobotStatusMsg* mutable_robot_status_msg();
  void set_allocated_robot_status_msg(::LSLAM::RobotStatusMsg* robot_status_msg);
  private:
  const ::LSLAM::RobotStatusMsg& _internal_robot_status_msg() const;
  ::LSLAM::RobotStatusMsg* _internal_mutable_robot_status_msg();
  public:
  void unsafe_arena_set_allocated_robot_status_msg(
      ::LSLAM::RobotStatusMsg* robot_status_msg);
  ::LSLAM::RobotStatusMsg* unsafe_arena_release_robot_status_msg();

  // .LSLAM.LanguagePackMsg language_pack_msg = 6;
  bool has_language_pack_msg() const;
  private:
  bool _internal_has_language_pack_msg() const;
  public:
  void clear_language_pack_msg();
  const ::LSLAM::LanguagePackMsg& language_pack_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::LanguagePackMsg* release_language_pack_msg();
  ::LSLAM::LanguagePackMsg* mutable_language_pack_msg();
  void set_allocated_language_pack_msg(::LSLAM::LanguagePackMsg* language_pack_msg);
  private:
  const ::LSLAM::LanguagePackMsg& _internal_language_pack_msg() const;
  ::LSLAM::LanguagePackMsg* _internal_mutable_language_pack_msg();
  public:
  void unsafe_arena_set_allocated_language_pack_msg(
      ::LSLAM::LanguagePackMsg* language_pack_msg);
  ::LSLAM::LanguagePackMsg* unsafe_arena_release_language_pack_msg();

  // .LSLAM.TuyaSettingMsg tuya_setting_msg = 7;
  bool has_tuya_setting_msg() const;
  private:
  bool _internal_has_tuya_setting_msg() const;
  public:
  void clear_tuya_setting_msg();
  const ::LSLAM::TuyaSettingMsg& tuya_setting_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::TuyaSettingMsg* release_tuya_setting_msg();
  ::LSLAM::TuyaSettingMsg* mutable_tuya_setting_msg();
  void set_allocated_tuya_setting_msg(::LSLAM::TuyaSettingMsg* tuya_setting_msg);
  private:
  const ::LSLAM::TuyaSettingMsg& _internal_tuya_setting_msg() const;
  ::LSLAM::TuyaSettingMsg* _internal_mutable_tuya_setting_msg();
  public:
  void unsafe_arena_set_allocated_tuya_setting_msg(
      ::LSLAM::TuyaSettingMsg* tuya_setting_msg);
  ::LSLAM::TuyaSettingMsg* unsafe_arena_release_tuya_setting_msg();

  // .LSLAM.TuyaCommandMsg tuya_command_msg = 8;
  bool has_tuya_command_msg() const;
  private:
  bool _internal_has_tuya_command_msg() const;
  public:
  void clear_tuya_command_msg();
  const ::LSLAM::TuyaCommandMsg& tuya_command_msg() const;
  PROTOBUF_NODISCARD ::LSLAM::TuyaCommandMsg* release_tuya_command_msg();
  ::LSLAM::TuyaCommandMsg* mutable_tuya_command_msg();
  void set_allocated_tuya_command_msg(::LSLAM::TuyaCommandMsg* tuya_command_msg);
  private:
  const ::LSLAM::TuyaCommandMsg& _internal_tuya_command_msg() const;
  ::LSLAM::TuyaCommandMsg* _internal_mutable_tuya_command_msg();
  public:
  void unsafe_arena_set_allocated_tuya_command_msg(
      ::LSLAM::TuyaCommandMsg* tuya_command_msg);
  ::LSLAM::TuyaCommandMsg* unsafe_arena_release_tuya_command_msg();

  // int32 battery_percentage = 4;
  void clear_battery_percentage();
  int32_t battery_percentage() const;
  void set_battery_percentage(int32_t value);
  private:
  int32_t _internal_battery_percentage() const;
  void _internal_set_battery_percentage(int32_t value);
  public:

  // int32 command_or_setting = 9;
  void clear_command_or_setting();
  int32_t command_or_setting() const;
  void set_command_or_setting(int32_t value);
  private:
  int32_t _internal_command_or_setting() const;
  void _internal_set_command_or_setting(int32_t value);
  public:

  // .LSLAM.TuyaStartupMode startup_mode = 10;
  void clear_startup_mode();
  ::LSLAM::TuyaStartupMode startup_mode() const;
  void set_startup_mode(::LSLAM::TuyaStartupMode value);
  private:
  ::LSLAM::TuyaStartupMode _internal_startup_mode() const;
  void _internal_set_startup_mode(::LSLAM::TuyaStartupMode value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.TuyaDpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::LSLAM::CleanDeviceMsg* clean_device_msg_;
    ::LSLAM::CleanRecordMsg* clean_record_msg_;
    ::LSLAM::DeviceMsg* device_msg_;
    ::LSLAM::RobotStatusMsg* robot_status_msg_;
    ::LSLAM::LanguagePackMsg* language_pack_msg_;
    ::LSLAM::TuyaSettingMsg* tuya_setting_msg_;
    ::LSLAM::TuyaCommandMsg* tuya_command_msg_;
    int32_t battery_percentage_;
    int32_t command_or_setting_;
    int startup_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TuyaDpMessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TuyaCommandMsg

// .LSLAM.TuyaCommandMsg.COMMAND current_command = 1;
inline void TuyaCommandMsg::clear_current_command() {
  _impl_.current_command_ = 0;
}
inline ::LSLAM::TuyaCommandMsg_COMMAND TuyaCommandMsg::_internal_current_command() const {
  return static_cast< ::LSLAM::TuyaCommandMsg_COMMAND >(_impl_.current_command_);
}
inline ::LSLAM::TuyaCommandMsg_COMMAND TuyaCommandMsg::current_command() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.current_command)
  return _internal_current_command();
}
inline void TuyaCommandMsg::_internal_set_current_command(::LSLAM::TuyaCommandMsg_COMMAND value) {
  
  _impl_.current_command_ = value;
}
inline void TuyaCommandMsg::set_current_command(::LSLAM::TuyaCommandMsg_COMMAND value) {
  _internal_set_current_command(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.current_command)
}

// repeated .LSLAM.Points plan_area_clean_points = 2;
inline int TuyaCommandMsg::_internal_plan_area_clean_points_size() const {
  return _impl_.plan_area_clean_points_.size();
}
inline int TuyaCommandMsg::plan_area_clean_points_size() const {
  return _internal_plan_area_clean_points_size();
}
inline ::LSLAM::Points* TuyaCommandMsg::mutable_plan_area_clean_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaCommandMsg.plan_area_clean_points)
  return _impl_.plan_area_clean_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaCommandMsg::mutable_plan_area_clean_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaCommandMsg.plan_area_clean_points)
  return &_impl_.plan_area_clean_points_;
}
inline const ::LSLAM::Points& TuyaCommandMsg::_internal_plan_area_clean_points(int index) const {
  return _impl_.plan_area_clean_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaCommandMsg::plan_area_clean_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.plan_area_clean_points)
  return _internal_plan_area_clean_points(index);
}
inline ::LSLAM::Points* TuyaCommandMsg::_internal_add_plan_area_clean_points() {
  return _impl_.plan_area_clean_points_.Add();
}
inline ::LSLAM::Points* TuyaCommandMsg::add_plan_area_clean_points() {
  ::LSLAM::Points* _add = _internal_add_plan_area_clean_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaCommandMsg.plan_area_clean_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaCommandMsg::plan_area_clean_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaCommandMsg.plan_area_clean_points)
  return _impl_.plan_area_clean_points_;
}

// repeated .LSLAM.Points partition_segmentation_points = 3;
inline int TuyaCommandMsg::_internal_partition_segmentation_points_size() const {
  return _impl_.partition_segmentation_points_.size();
}
inline int TuyaCommandMsg::partition_segmentation_points_size() const {
  return _internal_partition_segmentation_points_size();
}
inline ::LSLAM::Points* TuyaCommandMsg::mutable_partition_segmentation_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaCommandMsg.partition_segmentation_points)
  return _impl_.partition_segmentation_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaCommandMsg::mutable_partition_segmentation_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaCommandMsg.partition_segmentation_points)
  return &_impl_.partition_segmentation_points_;
}
inline const ::LSLAM::Points& TuyaCommandMsg::_internal_partition_segmentation_points(int index) const {
  return _impl_.partition_segmentation_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaCommandMsg::partition_segmentation_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.partition_segmentation_points)
  return _internal_partition_segmentation_points(index);
}
inline ::LSLAM::Points* TuyaCommandMsg::_internal_add_partition_segmentation_points() {
  return _impl_.partition_segmentation_points_.Add();
}
inline ::LSLAM::Points* TuyaCommandMsg::add_partition_segmentation_points() {
  ::LSLAM::Points* _add = _internal_add_partition_segmentation_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaCommandMsg.partition_segmentation_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaCommandMsg::partition_segmentation_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaCommandMsg.partition_segmentation_points)
  return _impl_.partition_segmentation_points_;
}

// .LSLAM.Points aim_point_clean_points = 4;
inline bool TuyaCommandMsg::_internal_has_aim_point_clean_points() const {
  return this != internal_default_instance() && _impl_.aim_point_clean_points_ != nullptr;
}
inline bool TuyaCommandMsg::has_aim_point_clean_points() const {
  return _internal_has_aim_point_clean_points();
}
inline const ::LSLAM::Points& TuyaCommandMsg::_internal_aim_point_clean_points() const {
  const ::LSLAM::Points* p = _impl_.aim_point_clean_points_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::Points&>(
      ::LSLAM::_Points_default_instance_);
}
inline const ::LSLAM::Points& TuyaCommandMsg::aim_point_clean_points() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.aim_point_clean_points)
  return _internal_aim_point_clean_points();
}
inline void TuyaCommandMsg::unsafe_arena_set_allocated_aim_point_clean_points(
    ::LSLAM::Points* aim_point_clean_points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aim_point_clean_points_);
  }
  _impl_.aim_point_clean_points_ = aim_point_clean_points;
  if (aim_point_clean_points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaCommandMsg.aim_point_clean_points)
}
inline ::LSLAM::Points* TuyaCommandMsg::release_aim_point_clean_points() {
  
  ::LSLAM::Points* temp = _impl_.aim_point_clean_points_;
  _impl_.aim_point_clean_points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::Points* TuyaCommandMsg::unsafe_arena_release_aim_point_clean_points() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaCommandMsg.aim_point_clean_points)
  
  ::LSLAM::Points* temp = _impl_.aim_point_clean_points_;
  _impl_.aim_point_clean_points_ = nullptr;
  return temp;
}
inline ::LSLAM::Points* TuyaCommandMsg::_internal_mutable_aim_point_clean_points() {
  
  if (_impl_.aim_point_clean_points_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::Points>(GetArenaForAllocation());
    _impl_.aim_point_clean_points_ = p;
  }
  return _impl_.aim_point_clean_points_;
}
inline ::LSLAM::Points* TuyaCommandMsg::mutable_aim_point_clean_points() {
  ::LSLAM::Points* _msg = _internal_mutable_aim_point_clean_points();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaCommandMsg.aim_point_clean_points)
  return _msg;
}
inline void TuyaCommandMsg::set_allocated_aim_point_clean_points(::LSLAM::Points* aim_point_clean_points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aim_point_clean_points_);
  }
  if (aim_point_clean_points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aim_point_clean_points));
    if (message_arena != submessage_arena) {
      aim_point_clean_points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aim_point_clean_points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.aim_point_clean_points_ = aim_point_clean_points;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaCommandMsg.aim_point_clean_points)
}

// repeated int32 room_id = 5;
inline int TuyaCommandMsg::_internal_room_id_size() const {
  return _impl_.room_id_.size();
}
inline int TuyaCommandMsg::room_id_size() const {
  return _internal_room_id_size();
}
inline void TuyaCommandMsg::clear_room_id() {
  _impl_.room_id_.Clear();
}
inline int32_t TuyaCommandMsg::_internal_room_id(int index) const {
  return _impl_.room_id_.Get(index);
}
inline int32_t TuyaCommandMsg::room_id(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.room_id)
  return _internal_room_id(index);
}
inline void TuyaCommandMsg::set_room_id(int index, int32_t value) {
  _impl_.room_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.room_id)
}
inline void TuyaCommandMsg::_internal_add_room_id(int32_t value) {
  _impl_.room_id_.Add(value);
}
inline void TuyaCommandMsg::add_room_id(int32_t value) {
  _internal_add_room_id(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaCommandMsg.room_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaCommandMsg::_internal_room_id() const {
  return _impl_.room_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaCommandMsg::room_id() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaCommandMsg.room_id)
  return _internal_room_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaCommandMsg::_internal_mutable_room_id() {
  return &_impl_.room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaCommandMsg::mutable_room_id() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaCommandMsg.room_id)
  return _internal_mutable_room_id();
}

// int32 select_area_clean_time_number = 6;
inline void TuyaCommandMsg::clear_select_area_clean_time_number() {
  _impl_.select_area_clean_time_number_ = 0;
}
inline int32_t TuyaCommandMsg::_internal_select_area_clean_time_number() const {
  return _impl_.select_area_clean_time_number_;
}
inline int32_t TuyaCommandMsg::select_area_clean_time_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.select_area_clean_time_number)
  return _internal_select_area_clean_time_number();
}
inline void TuyaCommandMsg::_internal_set_select_area_clean_time_number(int32_t value) {
  
  _impl_.select_area_clean_time_number_ = value;
}
inline void TuyaCommandMsg::set_select_area_clean_time_number(int32_t value) {
  _internal_set_select_area_clean_time_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.select_area_clean_time_number)
}

// int32 room_number = 7;
inline void TuyaCommandMsg::clear_room_number() {
  _impl_.room_number_ = 0;
}
inline int32_t TuyaCommandMsg::_internal_room_number() const {
  return _impl_.room_number_;
}
inline int32_t TuyaCommandMsg::room_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.room_number)
  return _internal_room_number();
}
inline void TuyaCommandMsg::_internal_set_room_number(int32_t value) {
  
  _impl_.room_number_ = value;
}
inline void TuyaCommandMsg::set_room_number(int32_t value) {
  _internal_set_room_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.room_number)
}

// int32 area_number = 8;
inline void TuyaCommandMsg::clear_area_number() {
  _impl_.area_number_ = 0;
}
inline int32_t TuyaCommandMsg::_internal_area_number() const {
  return _impl_.area_number_;
}
inline int32_t TuyaCommandMsg::area_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.area_number)
  return _internal_area_number();
}
inline void TuyaCommandMsg::_internal_set_area_number(int32_t value) {
  
  _impl_.area_number_ = value;
}
inline void TuyaCommandMsg::set_area_number(int32_t value) {
  _internal_set_area_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.area_number)
}

// .LSLAM.TuyaCommandMsg.RemoteControlDirection direction = 9;
inline void TuyaCommandMsg::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::LSLAM::TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::_internal_direction() const {
  return static_cast< ::LSLAM::TuyaCommandMsg_RemoteControlDirection >(_impl_.direction_);
}
inline ::LSLAM::TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::direction() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.direction)
  return _internal_direction();
}
inline void TuyaCommandMsg::_internal_set_direction(::LSLAM::TuyaCommandMsg_RemoteControlDirection value) {
  
  _impl_.direction_ = value;
}
inline void TuyaCommandMsg::set_direction(::LSLAM::TuyaCommandMsg_RemoteControlDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.direction)
}

// .LSLAM.TuyaCommandMsg.SuctionLevel suction_level = 18;
inline void TuyaCommandMsg::clear_suction_level() {
  _impl_.suction_level_ = 0;
}
inline ::LSLAM::TuyaCommandMsg_SuctionLevel TuyaCommandMsg::_internal_suction_level() const {
  return static_cast< ::LSLAM::TuyaCommandMsg_SuctionLevel >(_impl_.suction_level_);
}
inline ::LSLAM::TuyaCommandMsg_SuctionLevel TuyaCommandMsg::suction_level() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.suction_level)
  return _internal_suction_level();
}
inline void TuyaCommandMsg::_internal_set_suction_level(::LSLAM::TuyaCommandMsg_SuctionLevel value) {
  
  _impl_.suction_level_ = value;
}
inline void TuyaCommandMsg::set_suction_level(::LSLAM::TuyaCommandMsg_SuctionLevel value) {
  _internal_set_suction_level(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.suction_level)
}

// .LSLAM.TuyaCommandMsg.WaterVolumeLevel water_volume_level = 19;
inline void TuyaCommandMsg::clear_water_volume_level() {
  _impl_.water_volume_level_ = 0;
}
inline ::LSLAM::TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::_internal_water_volume_level() const {
  return static_cast< ::LSLAM::TuyaCommandMsg_WaterVolumeLevel >(_impl_.water_volume_level_);
}
inline ::LSLAM::TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::water_volume_level() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.water_volume_level)
  return _internal_water_volume_level();
}
inline void TuyaCommandMsg::_internal_set_water_volume_level(::LSLAM::TuyaCommandMsg_WaterVolumeLevel value) {
  
  _impl_.water_volume_level_ = value;
}
inline void TuyaCommandMsg::set_water_volume_level(::LSLAM::TuyaCommandMsg_WaterVolumeLevel value) {
  _internal_set_water_volume_level(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.water_volume_level)
}

// int32 plan_area_clean_time_number = 20;
inline void TuyaCommandMsg::clear_plan_area_clean_time_number() {
  _impl_.plan_area_clean_time_number_ = 0;
}
inline int32_t TuyaCommandMsg::_internal_plan_area_clean_time_number() const {
  return _impl_.plan_area_clean_time_number_;
}
inline int32_t TuyaCommandMsg::plan_area_clean_time_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaCommandMsg.plan_area_clean_time_number)
  return _internal_plan_area_clean_time_number();
}
inline void TuyaCommandMsg::_internal_set_plan_area_clean_time_number(int32_t value) {
  
  _impl_.plan_area_clean_time_number_ = value;
}
inline void TuyaCommandMsg::set_plan_area_clean_time_number(int32_t value) {
  _internal_set_plan_area_clean_time_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaCommandMsg.plan_area_clean_time_number)
}

// -------------------------------------------------------------------

// TuyaSettingMsg

// .LSLAM.TuyaSettingMsg.SET clean_set = 1;
inline void TuyaSettingMsg::clear_clean_set() {
  _impl_.clean_set_ = 0;
}
inline ::LSLAM::TuyaSettingMsg_SET TuyaSettingMsg::_internal_clean_set() const {
  return static_cast< ::LSLAM::TuyaSettingMsg_SET >(_impl_.clean_set_);
}
inline ::LSLAM::TuyaSettingMsg_SET TuyaSettingMsg::clean_set() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.clean_set)
  return _internal_clean_set();
}
inline void TuyaSettingMsg::_internal_set_clean_set(::LSLAM::TuyaSettingMsg_SET value) {
  
  _impl_.clean_set_ = value;
}
inline void TuyaSettingMsg::set_clean_set(::LSLAM::TuyaSettingMsg_SET value) {
  _internal_set_clean_set(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.clean_set)
}

// int32 virtual_wall_number = 2;
inline void TuyaSettingMsg::clear_virtual_wall_number() {
  _impl_.virtual_wall_number_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_virtual_wall_number() const {
  return _impl_.virtual_wall_number_;
}
inline int32_t TuyaSettingMsg::virtual_wall_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.virtual_wall_number)
  return _internal_virtual_wall_number();
}
inline void TuyaSettingMsg::_internal_set_virtual_wall_number(int32_t value) {
  
  _impl_.virtual_wall_number_ = value;
}
inline void TuyaSettingMsg::set_virtual_wall_number(int32_t value) {
  _internal_set_virtual_wall_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.virtual_wall_number)
}

// repeated .LSLAM.Points virtual_wall_points = 3;
inline int TuyaSettingMsg::_internal_virtual_wall_points_size() const {
  return _impl_.virtual_wall_points_.size();
}
inline int TuyaSettingMsg::virtual_wall_points_size() const {
  return _internal_virtual_wall_points_size();
}
inline ::LSLAM::Points* TuyaSettingMsg::mutable_virtual_wall_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaSettingMsg.virtual_wall_points)
  return _impl_.virtual_wall_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaSettingMsg::mutable_virtual_wall_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.virtual_wall_points)
  return &_impl_.virtual_wall_points_;
}
inline const ::LSLAM::Points& TuyaSettingMsg::_internal_virtual_wall_points(int index) const {
  return _impl_.virtual_wall_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaSettingMsg::virtual_wall_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.virtual_wall_points)
  return _internal_virtual_wall_points(index);
}
inline ::LSLAM::Points* TuyaSettingMsg::_internal_add_virtual_wall_points() {
  return _impl_.virtual_wall_points_.Add();
}
inline ::LSLAM::Points* TuyaSettingMsg::add_virtual_wall_points() {
  ::LSLAM::Points* _add = _internal_add_virtual_wall_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.virtual_wall_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaSettingMsg::virtual_wall_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.virtual_wall_points)
  return _impl_.virtual_wall_points_;
}

// repeated int32 clean_time_number = 4;
inline int TuyaSettingMsg::_internal_clean_time_number_size() const {
  return _impl_.clean_time_number_.size();
}
inline int TuyaSettingMsg::clean_time_number_size() const {
  return _internal_clean_time_number_size();
}
inline void TuyaSettingMsg::clear_clean_time_number() {
  _impl_.clean_time_number_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_clean_time_number(int index) const {
  return _impl_.clean_time_number_.Get(index);
}
inline int32_t TuyaSettingMsg::clean_time_number(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.clean_time_number)
  return _internal_clean_time_number(index);
}
inline void TuyaSettingMsg::set_clean_time_number(int index, int32_t value) {
  _impl_.clean_time_number_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.clean_time_number)
}
inline void TuyaSettingMsg::_internal_add_clean_time_number(int32_t value) {
  _impl_.clean_time_number_.Add(value);
}
inline void TuyaSettingMsg::add_clean_time_number(int32_t value) {
  _internal_add_clean_time_number(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.clean_time_number)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_clean_time_number() const {
  return _impl_.clean_time_number_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::clean_time_number() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.clean_time_number)
  return _internal_clean_time_number();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_clean_time_number() {
  return &_impl_.clean_time_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_clean_time_number() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.clean_time_number)
  return _internal_mutable_clean_time_number();
}

// repeated int32 room_number = 5;
inline int TuyaSettingMsg::_internal_room_number_size() const {
  return _impl_.room_number_.size();
}
inline int TuyaSettingMsg::room_number_size() const {
  return _internal_room_number_size();
}
inline void TuyaSettingMsg::clear_room_number() {
  _impl_.room_number_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_room_number(int index) const {
  return _impl_.room_number_.Get(index);
}
inline int32_t TuyaSettingMsg::room_number(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.room_number)
  return _internal_room_number(index);
}
inline void TuyaSettingMsg::set_room_number(int index, int32_t value) {
  _impl_.room_number_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.room_number)
}
inline void TuyaSettingMsg::_internal_add_room_number(int32_t value) {
  _impl_.room_number_.Add(value);
}
inline void TuyaSettingMsg::add_room_number(int32_t value) {
  _internal_add_room_number(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.room_number)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_room_number() const {
  return _impl_.room_number_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::room_number() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.room_number)
  return _internal_room_number();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_room_number() {
  return &_impl_.room_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_room_number() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.room_number)
  return _internal_mutable_room_number();
}

// repeated int32 room_id = 6;
inline int TuyaSettingMsg::_internal_room_id_size() const {
  return _impl_.room_id_.size();
}
inline int TuyaSettingMsg::room_id_size() const {
  return _internal_room_id_size();
}
inline void TuyaSettingMsg::clear_room_id() {
  _impl_.room_id_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_room_id(int index) const {
  return _impl_.room_id_.Get(index);
}
inline int32_t TuyaSettingMsg::room_id(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.room_id)
  return _internal_room_id(index);
}
inline void TuyaSettingMsg::set_room_id(int index, int32_t value) {
  _impl_.room_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.room_id)
}
inline void TuyaSettingMsg::_internal_add_room_id(int32_t value) {
  _impl_.room_id_.Add(value);
}
inline void TuyaSettingMsg::add_room_id(int32_t value) {
  _internal_add_room_id(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.room_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_room_id() const {
  return _impl_.room_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::room_id() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.room_id)
  return _internal_room_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_room_id() {
  return &_impl_.room_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_room_id() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.room_id)
  return _internal_mutable_room_id();
}

// repeated .LSLAM.Points partition_segmentation_points = 7;
inline int TuyaSettingMsg::_internal_partition_segmentation_points_size() const {
  return _impl_.partition_segmentation_points_.size();
}
inline int TuyaSettingMsg::partition_segmentation_points_size() const {
  return _internal_partition_segmentation_points_size();
}
inline ::LSLAM::Points* TuyaSettingMsg::mutable_partition_segmentation_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaSettingMsg.partition_segmentation_points)
  return _impl_.partition_segmentation_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaSettingMsg::mutable_partition_segmentation_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.partition_segmentation_points)
  return &_impl_.partition_segmentation_points_;
}
inline const ::LSLAM::Points& TuyaSettingMsg::_internal_partition_segmentation_points(int index) const {
  return _impl_.partition_segmentation_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaSettingMsg::partition_segmentation_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.partition_segmentation_points)
  return _internal_partition_segmentation_points(index);
}
inline ::LSLAM::Points* TuyaSettingMsg::_internal_add_partition_segmentation_points() {
  return _impl_.partition_segmentation_points_.Add();
}
inline ::LSLAM::Points* TuyaSettingMsg::add_partition_segmentation_points() {
  ::LSLAM::Points* _add = _internal_add_partition_segmentation_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.partition_segmentation_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaSettingMsg::partition_segmentation_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.partition_segmentation_points)
  return _impl_.partition_segmentation_points_;
}

// int32 ban_sweep_penalty_area_number = 8;
inline void TuyaSettingMsg::clear_ban_sweep_penalty_area_number() {
  _impl_.ban_sweep_penalty_area_number_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_ban_sweep_penalty_area_number() const {
  return _impl_.ban_sweep_penalty_area_number_;
}
inline int32_t TuyaSettingMsg::ban_sweep_penalty_area_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_number)
  return _internal_ban_sweep_penalty_area_number();
}
inline void TuyaSettingMsg::_internal_set_ban_sweep_penalty_area_number(int32_t value) {
  
  _impl_.ban_sweep_penalty_area_number_ = value;
}
inline void TuyaSettingMsg::set_ban_sweep_penalty_area_number(int32_t value) {
  _internal_set_ban_sweep_penalty_area_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_number)
}

// repeated .LSLAM.Points ban_sweep_penalty_area_points = 9;
inline int TuyaSettingMsg::_internal_ban_sweep_penalty_area_points_size() const {
  return _impl_.ban_sweep_penalty_area_points_.size();
}
inline int TuyaSettingMsg::ban_sweep_penalty_area_points_size() const {
  return _internal_ban_sweep_penalty_area_points_size();
}
inline ::LSLAM::Points* TuyaSettingMsg::mutable_ban_sweep_penalty_area_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_points)
  return _impl_.ban_sweep_penalty_area_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaSettingMsg::mutable_ban_sweep_penalty_area_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_points)
  return &_impl_.ban_sweep_penalty_area_points_;
}
inline const ::LSLAM::Points& TuyaSettingMsg::_internal_ban_sweep_penalty_area_points(int index) const {
  return _impl_.ban_sweep_penalty_area_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaSettingMsg::ban_sweep_penalty_area_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_points)
  return _internal_ban_sweep_penalty_area_points(index);
}
inline ::LSLAM::Points* TuyaSettingMsg::_internal_add_ban_sweep_penalty_area_points() {
  return _impl_.ban_sweep_penalty_area_points_.Add();
}
inline ::LSLAM::Points* TuyaSettingMsg::add_ban_sweep_penalty_area_points() {
  ::LSLAM::Points* _add = _internal_add_ban_sweep_penalty_area_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaSettingMsg::ban_sweep_penalty_area_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.ban_sweep_penalty_area_points)
  return _impl_.ban_sweep_penalty_area_points_;
}

// int32 ban_clean_and_sweep_penalty_area_number = 10;
inline void TuyaSettingMsg::clear_ban_clean_and_sweep_penalty_area_number() {
  _impl_.ban_clean_and_sweep_penalty_area_number_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_ban_clean_and_sweep_penalty_area_number() const {
  return _impl_.ban_clean_and_sweep_penalty_area_number_;
}
inline int32_t TuyaSettingMsg::ban_clean_and_sweep_penalty_area_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_number)
  return _internal_ban_clean_and_sweep_penalty_area_number();
}
inline void TuyaSettingMsg::_internal_set_ban_clean_and_sweep_penalty_area_number(int32_t value) {
  
  _impl_.ban_clean_and_sweep_penalty_area_number_ = value;
}
inline void TuyaSettingMsg::set_ban_clean_and_sweep_penalty_area_number(int32_t value) {
  _internal_set_ban_clean_and_sweep_penalty_area_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_number)
}

// repeated .LSLAM.Points ban_clean_and_sweep_penalty_area_points = 11;
inline int TuyaSettingMsg::_internal_ban_clean_and_sweep_penalty_area_points_size() const {
  return _impl_.ban_clean_and_sweep_penalty_area_points_.size();
}
inline int TuyaSettingMsg::ban_clean_and_sweep_penalty_area_points_size() const {
  return _internal_ban_clean_and_sweep_penalty_area_points_size();
}
inline ::LSLAM::Points* TuyaSettingMsg::mutable_ban_clean_and_sweep_penalty_area_points(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_points)
  return _impl_.ban_clean_and_sweep_penalty_area_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >*
TuyaSettingMsg::mutable_ban_clean_and_sweep_penalty_area_points() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_points)
  return &_impl_.ban_clean_and_sweep_penalty_area_points_;
}
inline const ::LSLAM::Points& TuyaSettingMsg::_internal_ban_clean_and_sweep_penalty_area_points(int index) const {
  return _impl_.ban_clean_and_sweep_penalty_area_points_.Get(index);
}
inline const ::LSLAM::Points& TuyaSettingMsg::ban_clean_and_sweep_penalty_area_points(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_points)
  return _internal_ban_clean_and_sweep_penalty_area_points(index);
}
inline ::LSLAM::Points* TuyaSettingMsg::_internal_add_ban_clean_and_sweep_penalty_area_points() {
  return _impl_.ban_clean_and_sweep_penalty_area_points_.Add();
}
inline ::LSLAM::Points* TuyaSettingMsg::add_ban_clean_and_sweep_penalty_area_points() {
  ::LSLAM::Points* _add = _internal_add_ban_clean_and_sweep_penalty_area_points();
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Points >&
TuyaSettingMsg::ban_clean_and_sweep_penalty_area_points() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.ban_clean_and_sweep_penalty_area_points)
  return _impl_.ban_clean_and_sweep_penalty_area_points_;
}

// repeated .LSLAM.TuyaSettingMsg.FanMotorLevel fan_motor_level = 12;
inline int TuyaSettingMsg::_internal_fan_motor_level_size() const {
  return _impl_.fan_motor_level_.size();
}
inline int TuyaSettingMsg::fan_motor_level_size() const {
  return _internal_fan_motor_level_size();
}
inline void TuyaSettingMsg::clear_fan_motor_level() {
  _impl_.fan_motor_level_.Clear();
}
inline ::LSLAM::TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::_internal_fan_motor_level(int index) const {
  return static_cast< ::LSLAM::TuyaSettingMsg_FanMotorLevel >(_impl_.fan_motor_level_.Get(index));
}
inline ::LSLAM::TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::fan_motor_level(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.fan_motor_level)
  return _internal_fan_motor_level(index);
}
inline void TuyaSettingMsg::set_fan_motor_level(int index, ::LSLAM::TuyaSettingMsg_FanMotorLevel value) {
  _impl_.fan_motor_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.fan_motor_level)
}
inline void TuyaSettingMsg::_internal_add_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value) {
  _impl_.fan_motor_level_.Add(value);
}
inline void TuyaSettingMsg::add_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value) {
  _internal_add_fan_motor_level(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.fan_motor_level)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TuyaSettingMsg::fan_motor_level() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.fan_motor_level)
  return _impl_.fan_motor_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::_internal_mutable_fan_motor_level() {
  return &_impl_.fan_motor_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::mutable_fan_motor_level() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.fan_motor_level)
  return _internal_mutable_fan_motor_level();
}

// repeated .LSLAM.TuyaSettingMsg.WaterBoxLevel water_box_level = 13;
inline int TuyaSettingMsg::_internal_water_box_level_size() const {
  return _impl_.water_box_level_.size();
}
inline int TuyaSettingMsg::water_box_level_size() const {
  return _internal_water_box_level_size();
}
inline void TuyaSettingMsg::clear_water_box_level() {
  _impl_.water_box_level_.Clear();
}
inline ::LSLAM::TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::_internal_water_box_level(int index) const {
  return static_cast< ::LSLAM::TuyaSettingMsg_WaterBoxLevel >(_impl_.water_box_level_.Get(index));
}
inline ::LSLAM::TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::water_box_level(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.water_box_level)
  return _internal_water_box_level(index);
}
inline void TuyaSettingMsg::set_water_box_level(int index, ::LSLAM::TuyaSettingMsg_WaterBoxLevel value) {
  _impl_.water_box_level_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.water_box_level)
}
inline void TuyaSettingMsg::_internal_add_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value) {
  _impl_.water_box_level_.Add(value);
}
inline void TuyaSettingMsg::add_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value) {
  _internal_add_water_box_level(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.water_box_level)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TuyaSettingMsg::water_box_level() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.water_box_level)
  return _impl_.water_box_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::_internal_mutable_water_box_level() {
  return &_impl_.water_box_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::mutable_water_box_level() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.water_box_level)
  return _internal_mutable_water_box_level();
}

// repeated .LSLAM.TuyaSettingMsg.YtypeSweep ytype_sweep = 14;
inline int TuyaSettingMsg::_internal_ytype_sweep_size() const {
  return _impl_.ytype_sweep_.size();
}
inline int TuyaSettingMsg::ytype_sweep_size() const {
  return _internal_ytype_sweep_size();
}
inline void TuyaSettingMsg::clear_ytype_sweep() {
  _impl_.ytype_sweep_.Clear();
}
inline ::LSLAM::TuyaSettingMsg_YtypeSweep TuyaSettingMsg::_internal_ytype_sweep(int index) const {
  return static_cast< ::LSLAM::TuyaSettingMsg_YtypeSweep >(_impl_.ytype_sweep_.Get(index));
}
inline ::LSLAM::TuyaSettingMsg_YtypeSweep TuyaSettingMsg::ytype_sweep(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.ytype_sweep)
  return _internal_ytype_sweep(index);
}
inline void TuyaSettingMsg::set_ytype_sweep(int index, ::LSLAM::TuyaSettingMsg_YtypeSweep value) {
  _impl_.ytype_sweep_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.ytype_sweep)
}
inline void TuyaSettingMsg::_internal_add_ytype_sweep(::LSLAM::TuyaSettingMsg_YtypeSweep value) {
  _impl_.ytype_sweep_.Add(value);
}
inline void TuyaSettingMsg::add_ytype_sweep(::LSLAM::TuyaSettingMsg_YtypeSweep value) {
  _internal_add_ytype_sweep(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.ytype_sweep)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TuyaSettingMsg::ytype_sweep() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.ytype_sweep)
  return _impl_.ytype_sweep_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::_internal_mutable_ytype_sweep() {
  return &_impl_.ytype_sweep_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::mutable_ytype_sweep() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.ytype_sweep)
  return _internal_mutable_ytype_sweep();
}

// repeated int32 name_length = 15;
inline int TuyaSettingMsg::_internal_name_length_size() const {
  return _impl_.name_length_.size();
}
inline int TuyaSettingMsg::name_length_size() const {
  return _internal_name_length_size();
}
inline void TuyaSettingMsg::clear_name_length() {
  _impl_.name_length_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_name_length(int index) const {
  return _impl_.name_length_.Get(index);
}
inline int32_t TuyaSettingMsg::name_length(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.name_length)
  return _internal_name_length(index);
}
inline void TuyaSettingMsg::set_name_length(int index, int32_t value) {
  _impl_.name_length_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.name_length)
}
inline void TuyaSettingMsg::_internal_add_name_length(int32_t value) {
  _impl_.name_length_.Add(value);
}
inline void TuyaSettingMsg::add_name_length(int32_t value) {
  _internal_add_name_length(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.name_length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_name_length() const {
  return _impl_.name_length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::name_length() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.name_length)
  return _internal_name_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_name_length() {
  return &_impl_.name_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_name_length() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.name_length)
  return _internal_mutable_name_length();
}

// repeated string room_name = 17;
inline int TuyaSettingMsg::_internal_room_name_size() const {
  return _impl_.room_name_.size();
}
inline int TuyaSettingMsg::room_name_size() const {
  return _internal_room_name_size();
}
inline void TuyaSettingMsg::clear_room_name() {
  _impl_.room_name_.Clear();
}
inline std::string* TuyaSettingMsg::add_room_name() {
  std::string* _s = _internal_add_room_name();
  // @@protoc_insertion_point(field_add_mutable:LSLAM.TuyaSettingMsg.room_name)
  return _s;
}
inline const std::string& TuyaSettingMsg::_internal_room_name(int index) const {
  return _impl_.room_name_.Get(index);
}
inline const std::string& TuyaSettingMsg::room_name(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.room_name)
  return _internal_room_name(index);
}
inline std::string* TuyaSettingMsg::mutable_room_name(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaSettingMsg.room_name)
  return _impl_.room_name_.Mutable(index);
}
inline void TuyaSettingMsg::set_room_name(int index, const std::string& value) {
  _impl_.room_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::set_room_name(int index, std::string&& value) {
  _impl_.room_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::set_room_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.room_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::set_room_name(int index, const char* value, size_t size) {
  _impl_.room_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LSLAM.TuyaSettingMsg.room_name)
}
inline std::string* TuyaSettingMsg::_internal_add_room_name() {
  return _impl_.room_name_.Add();
}
inline void TuyaSettingMsg::add_room_name(const std::string& value) {
  _impl_.room_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::add_room_name(std::string&& value) {
  _impl_.room_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::add_room_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.room_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LSLAM.TuyaSettingMsg.room_name)
}
inline void TuyaSettingMsg::add_room_name(const char* value, size_t size) {
  _impl_.room_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LSLAM.TuyaSettingMsg.room_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TuyaSettingMsg::room_name() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.room_name)
  return _impl_.room_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TuyaSettingMsg::mutable_room_name() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.room_name)
  return &_impl_.room_name_;
}

// int32 time_zone = 18;
inline void TuyaSettingMsg::clear_time_zone() {
  _impl_.time_zone_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_time_zone() const {
  return _impl_.time_zone_;
}
inline int32_t TuyaSettingMsg::time_zone() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.time_zone)
  return _internal_time_zone();
}
inline void TuyaSettingMsg::_internal_set_time_zone(int32_t value) {
  
  _impl_.time_zone_ = value;
}
inline void TuyaSettingMsg::set_time_zone(int32_t value) {
  _internal_set_time_zone(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.time_zone)
}

// int32 timing_number = 25;
inline void TuyaSettingMsg::clear_timing_number() {
  _impl_.timing_number_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_timing_number() const {
  return _impl_.timing_number_;
}
inline int32_t TuyaSettingMsg::timing_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.timing_number)
  return _internal_timing_number();
}
inline void TuyaSettingMsg::_internal_set_timing_number(int32_t value) {
  
  _impl_.timing_number_ = value;
}
inline void TuyaSettingMsg::set_timing_number(int32_t value) {
  _internal_set_timing_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.timing_number)
}

// repeated int32 timing_open_or_close = 26;
inline int TuyaSettingMsg::_internal_timing_open_or_close_size() const {
  return _impl_.timing_open_or_close_.size();
}
inline int TuyaSettingMsg::timing_open_or_close_size() const {
  return _internal_timing_open_or_close_size();
}
inline void TuyaSettingMsg::clear_timing_open_or_close() {
  _impl_.timing_open_or_close_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_timing_open_or_close(int index) const {
  return _impl_.timing_open_or_close_.Get(index);
}
inline int32_t TuyaSettingMsg::timing_open_or_close(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.timing_open_or_close)
  return _internal_timing_open_or_close(index);
}
inline void TuyaSettingMsg::set_timing_open_or_close(int index, int32_t value) {
  _impl_.timing_open_or_close_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.timing_open_or_close)
}
inline void TuyaSettingMsg::_internal_add_timing_open_or_close(int32_t value) {
  _impl_.timing_open_or_close_.Add(value);
}
inline void TuyaSettingMsg::add_timing_open_or_close(int32_t value) {
  _internal_add_timing_open_or_close(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.timing_open_or_close)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_timing_open_or_close() const {
  return _impl_.timing_open_or_close_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::timing_open_or_close() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.timing_open_or_close)
  return _internal_timing_open_or_close();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_timing_open_or_close() {
  return &_impl_.timing_open_or_close_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_timing_open_or_close() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.timing_open_or_close)
  return _internal_mutable_timing_open_or_close();
}

// repeated int32 timing_week = 27;
inline int TuyaSettingMsg::_internal_timing_week_size() const {
  return _impl_.timing_week_.size();
}
inline int TuyaSettingMsg::timing_week_size() const {
  return _internal_timing_week_size();
}
inline void TuyaSettingMsg::clear_timing_week() {
  _impl_.timing_week_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_timing_week(int index) const {
  return _impl_.timing_week_.Get(index);
}
inline int32_t TuyaSettingMsg::timing_week(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.timing_week)
  return _internal_timing_week(index);
}
inline void TuyaSettingMsg::set_timing_week(int index, int32_t value) {
  _impl_.timing_week_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.timing_week)
}
inline void TuyaSettingMsg::_internal_add_timing_week(int32_t value) {
  _impl_.timing_week_.Add(value);
}
inline void TuyaSettingMsg::add_timing_week(int32_t value) {
  _internal_add_timing_week(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.timing_week)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_timing_week() const {
  return _impl_.timing_week_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::timing_week() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.timing_week)
  return _internal_timing_week();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_timing_week() {
  return &_impl_.timing_week_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_timing_week() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.timing_week)
  return _internal_mutable_timing_week();
}

// repeated int32 timing_start_time = 28;
inline int TuyaSettingMsg::_internal_timing_start_time_size() const {
  return _impl_.timing_start_time_.size();
}
inline int TuyaSettingMsg::timing_start_time_size() const {
  return _internal_timing_start_time_size();
}
inline void TuyaSettingMsg::clear_timing_start_time() {
  _impl_.timing_start_time_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_timing_start_time(int index) const {
  return _impl_.timing_start_time_.Get(index);
}
inline int32_t TuyaSettingMsg::timing_start_time(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.timing_start_time)
  return _internal_timing_start_time(index);
}
inline void TuyaSettingMsg::set_timing_start_time(int index, int32_t value) {
  _impl_.timing_start_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.timing_start_time)
}
inline void TuyaSettingMsg::_internal_add_timing_start_time(int32_t value) {
  _impl_.timing_start_time_.Add(value);
}
inline void TuyaSettingMsg::add_timing_start_time(int32_t value) {
  _internal_add_timing_start_time(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.timing_start_time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_timing_start_time() const {
  return _impl_.timing_start_time_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::timing_start_time() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.timing_start_time)
  return _internal_timing_start_time();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_timing_start_time() {
  return &_impl_.timing_start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_timing_start_time() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.timing_start_time)
  return _internal_mutable_timing_start_time();
}

// repeated .LSLAM.TuyaSettingMsg.CleanMode timing_clean_mode = 29;
inline int TuyaSettingMsg::_internal_timing_clean_mode_size() const {
  return _impl_.timing_clean_mode_.size();
}
inline int TuyaSettingMsg::timing_clean_mode_size() const {
  return _internal_timing_clean_mode_size();
}
inline void TuyaSettingMsg::clear_timing_clean_mode() {
  _impl_.timing_clean_mode_.Clear();
}
inline ::LSLAM::TuyaSettingMsg_CleanMode TuyaSettingMsg::_internal_timing_clean_mode(int index) const {
  return static_cast< ::LSLAM::TuyaSettingMsg_CleanMode >(_impl_.timing_clean_mode_.Get(index));
}
inline ::LSLAM::TuyaSettingMsg_CleanMode TuyaSettingMsg::timing_clean_mode(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.timing_clean_mode)
  return _internal_timing_clean_mode(index);
}
inline void TuyaSettingMsg::set_timing_clean_mode(int index, ::LSLAM::TuyaSettingMsg_CleanMode value) {
  _impl_.timing_clean_mode_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.timing_clean_mode)
}
inline void TuyaSettingMsg::_internal_add_timing_clean_mode(::LSLAM::TuyaSettingMsg_CleanMode value) {
  _impl_.timing_clean_mode_.Add(value);
}
inline void TuyaSettingMsg::add_timing_clean_mode(::LSLAM::TuyaSettingMsg_CleanMode value) {
  _internal_add_timing_clean_mode(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.timing_clean_mode)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TuyaSettingMsg::timing_clean_mode() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.timing_clean_mode)
  return _impl_.timing_clean_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::_internal_mutable_timing_clean_mode() {
  return &_impl_.timing_clean_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TuyaSettingMsg::mutable_timing_clean_mode() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.timing_clean_mode)
  return _internal_mutable_timing_clean_mode();
}

// repeated int32 quiet_day = 30;
inline int TuyaSettingMsg::_internal_quiet_day_size() const {
  return _impl_.quiet_day_.size();
}
inline int TuyaSettingMsg::quiet_day_size() const {
  return _internal_quiet_day_size();
}
inline void TuyaSettingMsg::clear_quiet_day() {
  _impl_.quiet_day_.Clear();
}
inline int32_t TuyaSettingMsg::_internal_quiet_day(int index) const {
  return _impl_.quiet_day_.Get(index);
}
inline int32_t TuyaSettingMsg::quiet_day(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.quiet_day)
  return _internal_quiet_day(index);
}
inline void TuyaSettingMsg::set_quiet_day(int index, int32_t value) {
  _impl_.quiet_day_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.quiet_day)
}
inline void TuyaSettingMsg::_internal_add_quiet_day(int32_t value) {
  _impl_.quiet_day_.Add(value);
}
inline void TuyaSettingMsg::add_quiet_day(int32_t value) {
  _internal_add_quiet_day(value);
  // @@protoc_insertion_point(field_add:LSLAM.TuyaSettingMsg.quiet_day)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::_internal_quiet_day() const {
  return _impl_.quiet_day_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TuyaSettingMsg::quiet_day() const {
  // @@protoc_insertion_point(field_list:LSLAM.TuyaSettingMsg.quiet_day)
  return _internal_quiet_day();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::_internal_mutable_quiet_day() {
  return &_impl_.quiet_day_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TuyaSettingMsg::mutable_quiet_day() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.TuyaSettingMsg.quiet_day)
  return _internal_mutable_quiet_day();
}

// int32 quiet_start_time = 31;
inline void TuyaSettingMsg::clear_quiet_start_time() {
  _impl_.quiet_start_time_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_quiet_start_time() const {
  return _impl_.quiet_start_time_;
}
inline int32_t TuyaSettingMsg::quiet_start_time() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.quiet_start_time)
  return _internal_quiet_start_time();
}
inline void TuyaSettingMsg::_internal_set_quiet_start_time(int32_t value) {
  
  _impl_.quiet_start_time_ = value;
}
inline void TuyaSettingMsg::set_quiet_start_time(int32_t value) {
  _internal_set_quiet_start_time(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.quiet_start_time)
}

// int32 quiet_end_time = 32;
inline void TuyaSettingMsg::clear_quiet_end_time() {
  _impl_.quiet_end_time_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_quiet_end_time() const {
  return _impl_.quiet_end_time_;
}
inline int32_t TuyaSettingMsg::quiet_end_time() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.quiet_end_time)
  return _internal_quiet_end_time();
}
inline void TuyaSettingMsg::_internal_set_quiet_end_time(int32_t value) {
  
  _impl_.quiet_end_time_ = value;
}
inline void TuyaSettingMsg::set_quiet_end_time(int32_t value) {
  _internal_set_quiet_end_time(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.quiet_end_time)
}

// bool do_not_disturb_switch_open = 33;
inline void TuyaSettingMsg::clear_do_not_disturb_switch_open() {
  _impl_.do_not_disturb_switch_open_ = false;
}
inline bool TuyaSettingMsg::_internal_do_not_disturb_switch_open() const {
  return _impl_.do_not_disturb_switch_open_;
}
inline bool TuyaSettingMsg::do_not_disturb_switch_open() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.do_not_disturb_switch_open)
  return _internal_do_not_disturb_switch_open();
}
inline void TuyaSettingMsg::_internal_set_do_not_disturb_switch_open(bool value) {
  
  _impl_.do_not_disturb_switch_open_ = value;
}
inline void TuyaSettingMsg::set_do_not_disturb_switch_open(bool value) {
  _internal_set_do_not_disturb_switch_open(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.do_not_disturb_switch_open)
}

// .LSLAM.TuyaSettingMsg.FanMotorLevel current_fan_motor_level = 34;
inline void TuyaSettingMsg::clear_current_fan_motor_level() {
  _impl_.current_fan_motor_level_ = 0;
}
inline ::LSLAM::TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::_internal_current_fan_motor_level() const {
  return static_cast< ::LSLAM::TuyaSettingMsg_FanMotorLevel >(_impl_.current_fan_motor_level_);
}
inline ::LSLAM::TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::current_fan_motor_level() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.current_fan_motor_level)
  return _internal_current_fan_motor_level();
}
inline void TuyaSettingMsg::_internal_set_current_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value) {
  
  _impl_.current_fan_motor_level_ = value;
}
inline void TuyaSettingMsg::set_current_fan_motor_level(::LSLAM::TuyaSettingMsg_FanMotorLevel value) {
  _internal_set_current_fan_motor_level(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.current_fan_motor_level)
}

// .LSLAM.TuyaSettingMsg.WaterBoxLevel current_water_box_level = 35;
inline void TuyaSettingMsg::clear_current_water_box_level() {
  _impl_.current_water_box_level_ = 0;
}
inline ::LSLAM::TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::_internal_current_water_box_level() const {
  return static_cast< ::LSLAM::TuyaSettingMsg_WaterBoxLevel >(_impl_.current_water_box_level_);
}
inline ::LSLAM::TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::current_water_box_level() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.current_water_box_level)
  return _internal_current_water_box_level();
}
inline void TuyaSettingMsg::_internal_set_current_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value) {
  
  _impl_.current_water_box_level_ = value;
}
inline void TuyaSettingMsg::set_current_water_box_level(::LSLAM::TuyaSettingMsg_WaterBoxLevel value) {
  _internal_set_current_water_box_level(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.current_water_box_level)
}

// int32 volume = 36;
inline void TuyaSettingMsg::clear_volume() {
  _impl_.volume_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_volume() const {
  return _impl_.volume_;
}
inline int32_t TuyaSettingMsg::volume() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.volume)
  return _internal_volume();
}
inline void TuyaSettingMsg::_internal_set_volume(int32_t value) {
  
  _impl_.volume_ = value;
}
inline void TuyaSettingMsg::set_volume(int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.volume)
}

// bool breakpoint_continue_to_sweep = 37;
inline void TuyaSettingMsg::clear_breakpoint_continue_to_sweep() {
  _impl_.breakpoint_continue_to_sweep_ = false;
}
inline bool TuyaSettingMsg::_internal_breakpoint_continue_to_sweep() const {
  return _impl_.breakpoint_continue_to_sweep_;
}
inline bool TuyaSettingMsg::breakpoint_continue_to_sweep() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.breakpoint_continue_to_sweep)
  return _internal_breakpoint_continue_to_sweep();
}
inline void TuyaSettingMsg::_internal_set_breakpoint_continue_to_sweep(bool value) {
  
  _impl_.breakpoint_continue_to_sweep_ = value;
}
inline void TuyaSettingMsg::set_breakpoint_continue_to_sweep(bool value) {
  _internal_set_breakpoint_continue_to_sweep(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.breakpoint_continue_to_sweep)
}

// int32 set_result = 38;
inline void TuyaSettingMsg::clear_set_result() {
  _impl_.set_result_ = 0;
}
inline int32_t TuyaSettingMsg::_internal_set_result() const {
  return _impl_.set_result_;
}
inline int32_t TuyaSettingMsg::set_result() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaSettingMsg.set_result)
  return _internal_set_result();
}
inline void TuyaSettingMsg::_internal_set_set_result(int32_t value) {
  
  _impl_.set_result_ = value;
}
inline void TuyaSettingMsg::set_set_result(int32_t value) {
  _internal_set_set_result(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaSettingMsg.set_result)
}

// -------------------------------------------------------------------

// RobotStatusMsg

// .LSLAM.RobotStatusMsg.STATUS current_status = 1;
inline void RobotStatusMsg::clear_current_status() {
  _impl_.current_status_ = 0;
}
inline ::LSLAM::RobotStatusMsg_STATUS RobotStatusMsg::_internal_current_status() const {
  return static_cast< ::LSLAM::RobotStatusMsg_STATUS >(_impl_.current_status_);
}
inline ::LSLAM::RobotStatusMsg_STATUS RobotStatusMsg::current_status() const {
  // @@protoc_insertion_point(field_get:LSLAM.RobotStatusMsg.current_status)
  return _internal_current_status();
}
inline void RobotStatusMsg::_internal_set_current_status(::LSLAM::RobotStatusMsg_STATUS value) {
  
  _impl_.current_status_ = value;
}
inline void RobotStatusMsg::set_current_status(::LSLAM::RobotStatusMsg_STATUS value) {
  _internal_set_current_status(value);
  // @@protoc_insertion_point(field_set:LSLAM.RobotStatusMsg.current_status)
}

// .LSLAM.RobotStatusMsg.Fault current_fault = 2;
inline void RobotStatusMsg::clear_current_fault() {
  _impl_.current_fault_ = 0;
}
inline ::LSLAM::RobotStatusMsg_Fault RobotStatusMsg::_internal_current_fault() const {
  return static_cast< ::LSLAM::RobotStatusMsg_Fault >(_impl_.current_fault_);
}
inline ::LSLAM::RobotStatusMsg_Fault RobotStatusMsg::current_fault() const {
  // @@protoc_insertion_point(field_get:LSLAM.RobotStatusMsg.current_fault)
  return _internal_current_fault();
}
inline void RobotStatusMsg::_internal_set_current_fault(::LSLAM::RobotStatusMsg_Fault value) {
  
  _impl_.current_fault_ = value;
}
inline void RobotStatusMsg::set_current_fault(::LSLAM::RobotStatusMsg_Fault value) {
  _internal_set_current_fault(value);
  // @@protoc_insertion_point(field_set:LSLAM.RobotStatusMsg.current_fault)
}

// -------------------------------------------------------------------

// DeviceMsg

// string Wifi_name = 1;
inline void DeviceMsg::clear_wifi_name() {
  _impl_.wifi_name_.ClearToEmpty();
}
inline const std::string& DeviceMsg::wifi_name() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.Wifi_name)
  return _internal_wifi_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_wifi_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wifi_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.Wifi_name)
}
inline std::string* DeviceMsg::mutable_wifi_name() {
  std::string* _s = _internal_mutable_wifi_name();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.Wifi_name)
  return _s;
}
inline const std::string& DeviceMsg::_internal_wifi_name() const {
  return _impl_.wifi_name_.Get();
}
inline void DeviceMsg::_internal_set_wifi_name(const std::string& value) {
  
  _impl_.wifi_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_wifi_name() {
  
  return _impl_.wifi_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_wifi_name() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.Wifi_name)
  return _impl_.wifi_name_.Release();
}
inline void DeviceMsg::set_allocated_wifi_name(std::string* wifi_name) {
  if (wifi_name != nullptr) {
    
  } else {
    
  }
  _impl_.wifi_name_.SetAllocated(wifi_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wifi_name_.IsDefault()) {
    _impl_.wifi_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.Wifi_name)
}

// int32 RSSI = 2;
inline void DeviceMsg::clear_rssi() {
  _impl_.rssi_ = 0;
}
inline int32_t DeviceMsg::_internal_rssi() const {
  return _impl_.rssi_;
}
inline int32_t DeviceMsg::rssi() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.RSSI)
  return _internal_rssi();
}
inline void DeviceMsg::_internal_set_rssi(int32_t value) {
  
  _impl_.rssi_ = value;
}
inline void DeviceMsg::set_rssi(int32_t value) {
  _internal_set_rssi(value);
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.RSSI)
}

// string ID = 3;
inline void DeviceMsg::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeviceMsg::id() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.ID)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.ID)
}
inline std::string* DeviceMsg::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.ID)
  return _s;
}
inline const std::string& DeviceMsg::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeviceMsg::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_id() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.ID)
  return _impl_.id_.Release();
}
inline void DeviceMsg::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.ID)
}

// string Mac = 4;
inline void DeviceMsg::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& DeviceMsg::mac() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.Mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.Mac)
}
inline std::string* DeviceMsg::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.Mac)
  return _s;
}
inline const std::string& DeviceMsg::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void DeviceMsg::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_mac() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.Mac)
  return _impl_.mac_.Release();
}
inline void DeviceMsg::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.Mac)
}

// string MCU_Verssion = 5;
inline void DeviceMsg::clear_mcu_verssion() {
  _impl_.mcu_verssion_.ClearToEmpty();
}
inline const std::string& DeviceMsg::mcu_verssion() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.MCU_Verssion)
  return _internal_mcu_verssion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_mcu_verssion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mcu_verssion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.MCU_Verssion)
}
inline std::string* DeviceMsg::mutable_mcu_verssion() {
  std::string* _s = _internal_mutable_mcu_verssion();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.MCU_Verssion)
  return _s;
}
inline const std::string& DeviceMsg::_internal_mcu_verssion() const {
  return _impl_.mcu_verssion_.Get();
}
inline void DeviceMsg::_internal_set_mcu_verssion(const std::string& value) {
  
  _impl_.mcu_verssion_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_mcu_verssion() {
  
  return _impl_.mcu_verssion_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_mcu_verssion() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.MCU_Verssion)
  return _impl_.mcu_verssion_.Release();
}
inline void DeviceMsg::set_allocated_mcu_verssion(std::string* mcu_verssion) {
  if (mcu_verssion != nullptr) {
    
  } else {
    
  }
  _impl_.mcu_verssion_.SetAllocated(mcu_verssion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mcu_verssion_.IsDefault()) {
    _impl_.mcu_verssion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.MCU_Verssion)
}

// string Firmware_Version = 6;
inline void DeviceMsg::clear_firmware_version() {
  _impl_.firmware_version_.ClearToEmpty();
}
inline const std::string& DeviceMsg::firmware_version() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.Firmware_Version)
  return _internal_firmware_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_firmware_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.firmware_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.Firmware_Version)
}
inline std::string* DeviceMsg::mutable_firmware_version() {
  std::string* _s = _internal_mutable_firmware_version();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.Firmware_Version)
  return _s;
}
inline const std::string& DeviceMsg::_internal_firmware_version() const {
  return _impl_.firmware_version_.Get();
}
inline void DeviceMsg::_internal_set_firmware_version(const std::string& value) {
  
  _impl_.firmware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_firmware_version() {
  
  return _impl_.firmware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_firmware_version() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.Firmware_Version)
  return _impl_.firmware_version_.Release();
}
inline void DeviceMsg::set_allocated_firmware_version(std::string* firmware_version) {
  if (firmware_version != nullptr) {
    
  } else {
    
  }
  _impl_.firmware_version_.SetAllocated(firmware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_version_.IsDefault()) {
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.Firmware_Version)
}

// string device_SN = 7;
inline void DeviceMsg::clear_device_sn() {
  _impl_.device_sn_.ClearToEmpty();
}
inline const std::string& DeviceMsg::device_sn() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.device_SN)
  return _internal_device_sn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_device_sn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_sn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.device_SN)
}
inline std::string* DeviceMsg::mutable_device_sn() {
  std::string* _s = _internal_mutable_device_sn();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.device_SN)
  return _s;
}
inline const std::string& DeviceMsg::_internal_device_sn() const {
  return _impl_.device_sn_.Get();
}
inline void DeviceMsg::_internal_set_device_sn(const std::string& value) {
  
  _impl_.device_sn_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_device_sn() {
  
  return _impl_.device_sn_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_device_sn() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.device_SN)
  return _impl_.device_sn_.Release();
}
inline void DeviceMsg::set_allocated_device_sn(std::string* device_sn) {
  if (device_sn != nullptr) {
    
  } else {
    
  }
  _impl_.device_sn_.SetAllocated(device_sn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_sn_.IsDefault()) {
    _impl_.device_sn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.device_SN)
}

// string module_UUID = 8;
inline void DeviceMsg::clear_module_uuid() {
  _impl_.module_uuid_.ClearToEmpty();
}
inline const std::string& DeviceMsg::module_uuid() const {
  // @@protoc_insertion_point(field_get:LSLAM.DeviceMsg.module_UUID)
  return _internal_module_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMsg::set_module_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.DeviceMsg.module_UUID)
}
inline std::string* DeviceMsg::mutable_module_uuid() {
  std::string* _s = _internal_mutable_module_uuid();
  // @@protoc_insertion_point(field_mutable:LSLAM.DeviceMsg.module_UUID)
  return _s;
}
inline const std::string& DeviceMsg::_internal_module_uuid() const {
  return _impl_.module_uuid_.Get();
}
inline void DeviceMsg::_internal_set_module_uuid(const std::string& value) {
  
  _impl_.module_uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMsg::_internal_mutable_module_uuid() {
  
  return _impl_.module_uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMsg::release_module_uuid() {
  // @@protoc_insertion_point(field_release:LSLAM.DeviceMsg.module_UUID)
  return _impl_.module_uuid_.Release();
}
inline void DeviceMsg::set_allocated_module_uuid(std::string* module_uuid) {
  if (module_uuid != nullptr) {
    
  } else {
    
  }
  _impl_.module_uuid_.SetAllocated(module_uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_uuid_.IsDefault()) {
    _impl_.module_uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.DeviceMsg.module_UUID)
}

// -------------------------------------------------------------------

// CleanRecordMsg

// double clean_time = 1;
inline void CleanRecordMsg::clear_clean_time() {
  _impl_.clean_time_ = 0;
}
inline double CleanRecordMsg::_internal_clean_time() const {
  return _impl_.clean_time_;
}
inline double CleanRecordMsg::clean_time() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.clean_time)
  return _internal_clean_time();
}
inline void CleanRecordMsg::_internal_set_clean_time(double value) {
  
  _impl_.clean_time_ = value;
}
inline void CleanRecordMsg::set_clean_time(double value) {
  _internal_set_clean_time(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.clean_time)
}

// double clean_area = 2;
inline void CleanRecordMsg::clear_clean_area() {
  _impl_.clean_area_ = 0;
}
inline double CleanRecordMsg::_internal_clean_area() const {
  return _impl_.clean_area_;
}
inline double CleanRecordMsg::clean_area() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.clean_area)
  return _internal_clean_area();
}
inline void CleanRecordMsg::_internal_set_clean_area(double value) {
  
  _impl_.clean_area_ = value;
}
inline void CleanRecordMsg::set_clean_area(double value) {
  _internal_set_clean_area(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.clean_area)
}

// int32 clean_time_number = 3;
inline void CleanRecordMsg::clear_clean_time_number() {
  _impl_.clean_time_number_ = 0;
}
inline int32_t CleanRecordMsg::_internal_clean_time_number() const {
  return _impl_.clean_time_number_;
}
inline int32_t CleanRecordMsg::clean_time_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.clean_time_number)
  return _internal_clean_time_number();
}
inline void CleanRecordMsg::_internal_set_clean_time_number(int32_t value) {
  
  _impl_.clean_time_number_ = value;
}
inline void CleanRecordMsg::set_clean_time_number(int32_t value) {
  _internal_set_clean_time_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.clean_time_number)
}

// double all_clean_time = 4;
inline void CleanRecordMsg::clear_all_clean_time() {
  _impl_.all_clean_time_ = 0;
}
inline double CleanRecordMsg::_internal_all_clean_time() const {
  return _impl_.all_clean_time_;
}
inline double CleanRecordMsg::all_clean_time() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.all_clean_time)
  return _internal_all_clean_time();
}
inline void CleanRecordMsg::_internal_set_all_clean_time(double value) {
  
  _impl_.all_clean_time_ = value;
}
inline void CleanRecordMsg::set_all_clean_time(double value) {
  _internal_set_all_clean_time(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.all_clean_time)
}

// double all_clean_area = 5;
inline void CleanRecordMsg::clear_all_clean_area() {
  _impl_.all_clean_area_ = 0;
}
inline double CleanRecordMsg::_internal_all_clean_area() const {
  return _impl_.all_clean_area_;
}
inline double CleanRecordMsg::all_clean_area() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.all_clean_area)
  return _internal_all_clean_area();
}
inline void CleanRecordMsg::_internal_set_all_clean_area(double value) {
  
  _impl_.all_clean_area_ = value;
}
inline void CleanRecordMsg::set_all_clean_area(double value) {
  _internal_set_all_clean_area(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.all_clean_area)
}

// int32 all_clean_time_number = 6;
inline void CleanRecordMsg::clear_all_clean_time_number() {
  _impl_.all_clean_time_number_ = 0;
}
inline int32_t CleanRecordMsg::_internal_all_clean_time_number() const {
  return _impl_.all_clean_time_number_;
}
inline int32_t CleanRecordMsg::all_clean_time_number() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.all_clean_time_number)
  return _internal_all_clean_time_number();
}
inline void CleanRecordMsg::_internal_set_all_clean_time_number(int32_t value) {
  
  _impl_.all_clean_time_number_ = value;
}
inline void CleanRecordMsg::set_all_clean_time_number(int32_t value) {
  _internal_set_all_clean_time_number(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.all_clean_time_number)
}

// double clean_percentage = 7;
inline void CleanRecordMsg::clear_clean_percentage() {
  _impl_.clean_percentage_ = 0;
}
inline double CleanRecordMsg::_internal_clean_percentage() const {
  return _impl_.clean_percentage_;
}
inline double CleanRecordMsg::clean_percentage() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanRecordMsg.clean_percentage)
  return _internal_clean_percentage();
}
inline void CleanRecordMsg::_internal_set_clean_percentage(double value) {
  
  _impl_.clean_percentage_ = value;
}
inline void CleanRecordMsg::set_clean_percentage(double value) {
  _internal_set_clean_percentage(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanRecordMsg.clean_percentage)
}

// -------------------------------------------------------------------

// CleanDeviceMsg

// int32 edge_brush_life = 1;
inline void CleanDeviceMsg::clear_edge_brush_life() {
  _impl_.edge_brush_life_ = 0;
}
inline int32_t CleanDeviceMsg::_internal_edge_brush_life() const {
  return _impl_.edge_brush_life_;
}
inline int32_t CleanDeviceMsg::edge_brush_life() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanDeviceMsg.edge_brush_life)
  return _internal_edge_brush_life();
}
inline void CleanDeviceMsg::_internal_set_edge_brush_life(int32_t value) {
  
  _impl_.edge_brush_life_ = value;
}
inline void CleanDeviceMsg::set_edge_brush_life(int32_t value) {
  _internal_set_edge_brush_life(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanDeviceMsg.edge_brush_life)
}

// int32 roll_brush_life = 2;
inline void CleanDeviceMsg::clear_roll_brush_life() {
  _impl_.roll_brush_life_ = 0;
}
inline int32_t CleanDeviceMsg::_internal_roll_brush_life() const {
  return _impl_.roll_brush_life_;
}
inline int32_t CleanDeviceMsg::roll_brush_life() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanDeviceMsg.roll_brush_life)
  return _internal_roll_brush_life();
}
inline void CleanDeviceMsg::_internal_set_roll_brush_life(int32_t value) {
  
  _impl_.roll_brush_life_ = value;
}
inline void CleanDeviceMsg::set_roll_brush_life(int32_t value) {
  _internal_set_roll_brush_life(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanDeviceMsg.roll_brush_life)
}

// int32 filter_life = 3;
inline void CleanDeviceMsg::clear_filter_life() {
  _impl_.filter_life_ = 0;
}
inline int32_t CleanDeviceMsg::_internal_filter_life() const {
  return _impl_.filter_life_;
}
inline int32_t CleanDeviceMsg::filter_life() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanDeviceMsg.filter_life)
  return _internal_filter_life();
}
inline void CleanDeviceMsg::_internal_set_filter_life(int32_t value) {
  
  _impl_.filter_life_ = value;
}
inline void CleanDeviceMsg::set_filter_life(int32_t value) {
  _internal_set_filter_life(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanDeviceMsg.filter_life)
}

// int32 rag_life = 4;
inline void CleanDeviceMsg::clear_rag_life() {
  _impl_.rag_life_ = 0;
}
inline int32_t CleanDeviceMsg::_internal_rag_life() const {
  return _impl_.rag_life_;
}
inline int32_t CleanDeviceMsg::rag_life() const {
  // @@protoc_insertion_point(field_get:LSLAM.CleanDeviceMsg.rag_life)
  return _internal_rag_life();
}
inline void CleanDeviceMsg::_internal_set_rag_life(int32_t value) {
  
  _impl_.rag_life_ = value;
}
inline void CleanDeviceMsg::set_rag_life(int32_t value) {
  _internal_set_rag_life(value);
  // @@protoc_insertion_point(field_set:LSLAM.CleanDeviceMsg.rag_life)
}

// -------------------------------------------------------------------

// LanguagePackMsg

// .LSLAM.LanguagePackMsg.DownloadStatus download_status = 1;
inline void LanguagePackMsg::clear_download_status() {
  _impl_.download_status_ = 0;
}
inline ::LSLAM::LanguagePackMsg_DownloadStatus LanguagePackMsg::_internal_download_status() const {
  return static_cast< ::LSLAM::LanguagePackMsg_DownloadStatus >(_impl_.download_status_);
}
inline ::LSLAM::LanguagePackMsg_DownloadStatus LanguagePackMsg::download_status() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.download_status)
  return _internal_download_status();
}
inline void LanguagePackMsg::_internal_set_download_status(::LSLAM::LanguagePackMsg_DownloadStatus value) {
  
  _impl_.download_status_ = value;
}
inline void LanguagePackMsg::set_download_status(::LSLAM::LanguagePackMsg_DownloadStatus value) {
  _internal_set_download_status(value);
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.download_status)
}

// int32 download_and_install_schedu = 2;
inline void LanguagePackMsg::clear_download_and_install_schedu() {
  _impl_.download_and_install_schedu_ = 0;
}
inline int32_t LanguagePackMsg::_internal_download_and_install_schedu() const {
  return _impl_.download_and_install_schedu_;
}
inline int32_t LanguagePackMsg::download_and_install_schedu() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.download_and_install_schedu)
  return _internal_download_and_install_schedu();
}
inline void LanguagePackMsg::_internal_set_download_and_install_schedu(int32_t value) {
  
  _impl_.download_and_install_schedu_ = value;
}
inline void LanguagePackMsg::set_download_and_install_schedu(int32_t value) {
  _internal_set_download_and_install_schedu(value);
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.download_and_install_schedu)
}

// .LSLAM.LanguagePackMsg.LanguageType language = 3;
inline void LanguagePackMsg::clear_language() {
  _impl_.language_ = 0;
}
inline ::LSLAM::LanguagePackMsg_LanguageType LanguagePackMsg::_internal_language() const {
  return static_cast< ::LSLAM::LanguagePackMsg_LanguageType >(_impl_.language_);
}
inline ::LSLAM::LanguagePackMsg_LanguageType LanguagePackMsg::language() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.language)
  return _internal_language();
}
inline void LanguagePackMsg::_internal_set_language(::LSLAM::LanguagePackMsg_LanguageType value) {
  
  _impl_.language_ = value;
}
inline void LanguagePackMsg::set_language(::LSLAM::LanguagePackMsg_LanguageType value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.language)
}

// int32 check_code_length = 4;
inline void LanguagePackMsg::clear_check_code_length() {
  _impl_.check_code_length_ = 0;
}
inline int32_t LanguagePackMsg::_internal_check_code_length() const {
  return _impl_.check_code_length_;
}
inline int32_t LanguagePackMsg::check_code_length() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.check_code_length)
  return _internal_check_code_length();
}
inline void LanguagePackMsg::_internal_set_check_code_length(int32_t value) {
  
  _impl_.check_code_length_ = value;
}
inline void LanguagePackMsg::set_check_code_length(int32_t value) {
  _internal_set_check_code_length(value);
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.check_code_length)
}

// string check_code = 5;
inline void LanguagePackMsg::clear_check_code() {
  _impl_.check_code_.ClearToEmpty();
}
inline const std::string& LanguagePackMsg::check_code() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.check_code)
  return _internal_check_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LanguagePackMsg::set_check_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.check_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.check_code)
}
inline std::string* LanguagePackMsg::mutable_check_code() {
  std::string* _s = _internal_mutable_check_code();
  // @@protoc_insertion_point(field_mutable:LSLAM.LanguagePackMsg.check_code)
  return _s;
}
inline const std::string& LanguagePackMsg::_internal_check_code() const {
  return _impl_.check_code_.Get();
}
inline void LanguagePackMsg::_internal_set_check_code(const std::string& value) {
  
  _impl_.check_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LanguagePackMsg::_internal_mutable_check_code() {
  
  return _impl_.check_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LanguagePackMsg::release_check_code() {
  // @@protoc_insertion_point(field_release:LSLAM.LanguagePackMsg.check_code)
  return _impl_.check_code_.Release();
}
inline void LanguagePackMsg::set_allocated_check_code(std::string* check_code) {
  if (check_code != nullptr) {
    
  } else {
    
  }
  _impl_.check_code_.SetAllocated(check_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.check_code_.IsDefault()) {
    _impl_.check_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.LanguagePackMsg.check_code)
}

// int32 language_pack_url_length = 6;
inline void LanguagePackMsg::clear_language_pack_url_length() {
  _impl_.language_pack_url_length_ = 0;
}
inline int32_t LanguagePackMsg::_internal_language_pack_url_length() const {
  return _impl_.language_pack_url_length_;
}
inline int32_t LanguagePackMsg::language_pack_url_length() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.language_pack_url_length)
  return _internal_language_pack_url_length();
}
inline void LanguagePackMsg::_internal_set_language_pack_url_length(int32_t value) {
  
  _impl_.language_pack_url_length_ = value;
}
inline void LanguagePackMsg::set_language_pack_url_length(int32_t value) {
  _internal_set_language_pack_url_length(value);
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.language_pack_url_length)
}

// string language_pack_url = 7;
inline void LanguagePackMsg::clear_language_pack_url() {
  _impl_.language_pack_url_.ClearToEmpty();
}
inline const std::string& LanguagePackMsg::language_pack_url() const {
  // @@protoc_insertion_point(field_get:LSLAM.LanguagePackMsg.language_pack_url)
  return _internal_language_pack_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LanguagePackMsg::set_language_pack_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_pack_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.LanguagePackMsg.language_pack_url)
}
inline std::string* LanguagePackMsg::mutable_language_pack_url() {
  std::string* _s = _internal_mutable_language_pack_url();
  // @@protoc_insertion_point(field_mutable:LSLAM.LanguagePackMsg.language_pack_url)
  return _s;
}
inline const std::string& LanguagePackMsg::_internal_language_pack_url() const {
  return _impl_.language_pack_url_.Get();
}
inline void LanguagePackMsg::_internal_set_language_pack_url(const std::string& value) {
  
  _impl_.language_pack_url_.Set(value, GetArenaForAllocation());
}
inline std::string* LanguagePackMsg::_internal_mutable_language_pack_url() {
  
  return _impl_.language_pack_url_.Mutable(GetArenaForAllocation());
}
inline std::string* LanguagePackMsg::release_language_pack_url() {
  // @@protoc_insertion_point(field_release:LSLAM.LanguagePackMsg.language_pack_url)
  return _impl_.language_pack_url_.Release();
}
inline void LanguagePackMsg::set_allocated_language_pack_url(std::string* language_pack_url) {
  if (language_pack_url != nullptr) {
    
  } else {
    
  }
  _impl_.language_pack_url_.SetAllocated(language_pack_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_pack_url_.IsDefault()) {
    _impl_.language_pack_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.LanguagePackMsg.language_pack_url)
}

// -------------------------------------------------------------------

// TuyaDpMsg

// .LSLAM.CleanDeviceMsg clean_device_msg = 1;
inline bool TuyaDpMsg::_internal_has_clean_device_msg() const {
  return this != internal_default_instance() && _impl_.clean_device_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_clean_device_msg() const {
  return _internal_has_clean_device_msg();
}
inline void TuyaDpMsg::clear_clean_device_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.clean_device_msg_ != nullptr) {
    delete _impl_.clean_device_msg_;
  }
  _impl_.clean_device_msg_ = nullptr;
}
inline const ::LSLAM::CleanDeviceMsg& TuyaDpMsg::_internal_clean_device_msg() const {
  const ::LSLAM::CleanDeviceMsg* p = _impl_.clean_device_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::CleanDeviceMsg&>(
      ::LSLAM::_CleanDeviceMsg_default_instance_);
}
inline const ::LSLAM::CleanDeviceMsg& TuyaDpMsg::clean_device_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.clean_device_msg)
  return _internal_clean_device_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_clean_device_msg(
    ::LSLAM::CleanDeviceMsg* clean_device_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clean_device_msg_);
  }
  _impl_.clean_device_msg_ = clean_device_msg;
  if (clean_device_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.clean_device_msg)
}
inline ::LSLAM::CleanDeviceMsg* TuyaDpMsg::release_clean_device_msg() {
  
  ::LSLAM::CleanDeviceMsg* temp = _impl_.clean_device_msg_;
  _impl_.clean_device_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::CleanDeviceMsg* TuyaDpMsg::unsafe_arena_release_clean_device_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.clean_device_msg)
  
  ::LSLAM::CleanDeviceMsg* temp = _impl_.clean_device_msg_;
  _impl_.clean_device_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::CleanDeviceMsg* TuyaDpMsg::_internal_mutable_clean_device_msg() {
  
  if (_impl_.clean_device_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::CleanDeviceMsg>(GetArenaForAllocation());
    _impl_.clean_device_msg_ = p;
  }
  return _impl_.clean_device_msg_;
}
inline ::LSLAM::CleanDeviceMsg* TuyaDpMsg::mutable_clean_device_msg() {
  ::LSLAM::CleanDeviceMsg* _msg = _internal_mutable_clean_device_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.clean_device_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_clean_device_msg(::LSLAM::CleanDeviceMsg* clean_device_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clean_device_msg_;
  }
  if (clean_device_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clean_device_msg);
    if (message_arena != submessage_arena) {
      clean_device_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clean_device_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clean_device_msg_ = clean_device_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.clean_device_msg)
}

// .LSLAM.CleanRecordMsg clean_record_msg = 2;
inline bool TuyaDpMsg::_internal_has_clean_record_msg() const {
  return this != internal_default_instance() && _impl_.clean_record_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_clean_record_msg() const {
  return _internal_has_clean_record_msg();
}
inline void TuyaDpMsg::clear_clean_record_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.clean_record_msg_ != nullptr) {
    delete _impl_.clean_record_msg_;
  }
  _impl_.clean_record_msg_ = nullptr;
}
inline const ::LSLAM::CleanRecordMsg& TuyaDpMsg::_internal_clean_record_msg() const {
  const ::LSLAM::CleanRecordMsg* p = _impl_.clean_record_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::CleanRecordMsg&>(
      ::LSLAM::_CleanRecordMsg_default_instance_);
}
inline const ::LSLAM::CleanRecordMsg& TuyaDpMsg::clean_record_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.clean_record_msg)
  return _internal_clean_record_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_clean_record_msg(
    ::LSLAM::CleanRecordMsg* clean_record_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clean_record_msg_);
  }
  _impl_.clean_record_msg_ = clean_record_msg;
  if (clean_record_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.clean_record_msg)
}
inline ::LSLAM::CleanRecordMsg* TuyaDpMsg::release_clean_record_msg() {
  
  ::LSLAM::CleanRecordMsg* temp = _impl_.clean_record_msg_;
  _impl_.clean_record_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::CleanRecordMsg* TuyaDpMsg::unsafe_arena_release_clean_record_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.clean_record_msg)
  
  ::LSLAM::CleanRecordMsg* temp = _impl_.clean_record_msg_;
  _impl_.clean_record_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::CleanRecordMsg* TuyaDpMsg::_internal_mutable_clean_record_msg() {
  
  if (_impl_.clean_record_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::CleanRecordMsg>(GetArenaForAllocation());
    _impl_.clean_record_msg_ = p;
  }
  return _impl_.clean_record_msg_;
}
inline ::LSLAM::CleanRecordMsg* TuyaDpMsg::mutable_clean_record_msg() {
  ::LSLAM::CleanRecordMsg* _msg = _internal_mutable_clean_record_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.clean_record_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_clean_record_msg(::LSLAM::CleanRecordMsg* clean_record_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clean_record_msg_;
  }
  if (clean_record_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clean_record_msg);
    if (message_arena != submessage_arena) {
      clean_record_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clean_record_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clean_record_msg_ = clean_record_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.clean_record_msg)
}

// .LSLAM.DeviceMsg device_msg = 3;
inline bool TuyaDpMsg::_internal_has_device_msg() const {
  return this != internal_default_instance() && _impl_.device_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_device_msg() const {
  return _internal_has_device_msg();
}
inline void TuyaDpMsg::clear_device_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.device_msg_ != nullptr) {
    delete _impl_.device_msg_;
  }
  _impl_.device_msg_ = nullptr;
}
inline const ::LSLAM::DeviceMsg& TuyaDpMsg::_internal_device_msg() const {
  const ::LSLAM::DeviceMsg* p = _impl_.device_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::DeviceMsg&>(
      ::LSLAM::_DeviceMsg_default_instance_);
}
inline const ::LSLAM::DeviceMsg& TuyaDpMsg::device_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.device_msg)
  return _internal_device_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_device_msg(
    ::LSLAM::DeviceMsg* device_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_msg_);
  }
  _impl_.device_msg_ = device_msg;
  if (device_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.device_msg)
}
inline ::LSLAM::DeviceMsg* TuyaDpMsg::release_device_msg() {
  
  ::LSLAM::DeviceMsg* temp = _impl_.device_msg_;
  _impl_.device_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::DeviceMsg* TuyaDpMsg::unsafe_arena_release_device_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.device_msg)
  
  ::LSLAM::DeviceMsg* temp = _impl_.device_msg_;
  _impl_.device_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::DeviceMsg* TuyaDpMsg::_internal_mutable_device_msg() {
  
  if (_impl_.device_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::DeviceMsg>(GetArenaForAllocation());
    _impl_.device_msg_ = p;
  }
  return _impl_.device_msg_;
}
inline ::LSLAM::DeviceMsg* TuyaDpMsg::mutable_device_msg() {
  ::LSLAM::DeviceMsg* _msg = _internal_mutable_device_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.device_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_device_msg(::LSLAM::DeviceMsg* device_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.device_msg_;
  }
  if (device_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_msg);
    if (message_arena != submessage_arena) {
      device_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.device_msg_ = device_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.device_msg)
}

// int32 battery_percentage = 4;
inline void TuyaDpMsg::clear_battery_percentage() {
  _impl_.battery_percentage_ = 0;
}
inline int32_t TuyaDpMsg::_internal_battery_percentage() const {
  return _impl_.battery_percentage_;
}
inline int32_t TuyaDpMsg::battery_percentage() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.battery_percentage)
  return _internal_battery_percentage();
}
inline void TuyaDpMsg::_internal_set_battery_percentage(int32_t value) {
  
  _impl_.battery_percentage_ = value;
}
inline void TuyaDpMsg::set_battery_percentage(int32_t value) {
  _internal_set_battery_percentage(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaDpMsg.battery_percentage)
}

// .LSLAM.RobotStatusMsg robot_status_msg = 5;
inline bool TuyaDpMsg::_internal_has_robot_status_msg() const {
  return this != internal_default_instance() && _impl_.robot_status_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_robot_status_msg() const {
  return _internal_has_robot_status_msg();
}
inline void TuyaDpMsg::clear_robot_status_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.robot_status_msg_ != nullptr) {
    delete _impl_.robot_status_msg_;
  }
  _impl_.robot_status_msg_ = nullptr;
}
inline const ::LSLAM::RobotStatusMsg& TuyaDpMsg::_internal_robot_status_msg() const {
  const ::LSLAM::RobotStatusMsg* p = _impl_.robot_status_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::RobotStatusMsg&>(
      ::LSLAM::_RobotStatusMsg_default_instance_);
}
inline const ::LSLAM::RobotStatusMsg& TuyaDpMsg::robot_status_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.robot_status_msg)
  return _internal_robot_status_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_robot_status_msg(
    ::LSLAM::RobotStatusMsg* robot_status_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.robot_status_msg_);
  }
  _impl_.robot_status_msg_ = robot_status_msg;
  if (robot_status_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.robot_status_msg)
}
inline ::LSLAM::RobotStatusMsg* TuyaDpMsg::release_robot_status_msg() {
  
  ::LSLAM::RobotStatusMsg* temp = _impl_.robot_status_msg_;
  _impl_.robot_status_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::RobotStatusMsg* TuyaDpMsg::unsafe_arena_release_robot_status_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.robot_status_msg)
  
  ::LSLAM::RobotStatusMsg* temp = _impl_.robot_status_msg_;
  _impl_.robot_status_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::RobotStatusMsg* TuyaDpMsg::_internal_mutable_robot_status_msg() {
  
  if (_impl_.robot_status_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::RobotStatusMsg>(GetArenaForAllocation());
    _impl_.robot_status_msg_ = p;
  }
  return _impl_.robot_status_msg_;
}
inline ::LSLAM::RobotStatusMsg* TuyaDpMsg::mutable_robot_status_msg() {
  ::LSLAM::RobotStatusMsg* _msg = _internal_mutable_robot_status_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.robot_status_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_robot_status_msg(::LSLAM::RobotStatusMsg* robot_status_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.robot_status_msg_;
  }
  if (robot_status_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_status_msg);
    if (message_arena != submessage_arena) {
      robot_status_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_status_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.robot_status_msg_ = robot_status_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.robot_status_msg)
}

// .LSLAM.LanguagePackMsg language_pack_msg = 6;
inline bool TuyaDpMsg::_internal_has_language_pack_msg() const {
  return this != internal_default_instance() && _impl_.language_pack_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_language_pack_msg() const {
  return _internal_has_language_pack_msg();
}
inline void TuyaDpMsg::clear_language_pack_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.language_pack_msg_ != nullptr) {
    delete _impl_.language_pack_msg_;
  }
  _impl_.language_pack_msg_ = nullptr;
}
inline const ::LSLAM::LanguagePackMsg& TuyaDpMsg::_internal_language_pack_msg() const {
  const ::LSLAM::LanguagePackMsg* p = _impl_.language_pack_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::LanguagePackMsg&>(
      ::LSLAM::_LanguagePackMsg_default_instance_);
}
inline const ::LSLAM::LanguagePackMsg& TuyaDpMsg::language_pack_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.language_pack_msg)
  return _internal_language_pack_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_language_pack_msg(
    ::LSLAM::LanguagePackMsg* language_pack_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.language_pack_msg_);
  }
  _impl_.language_pack_msg_ = language_pack_msg;
  if (language_pack_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.language_pack_msg)
}
inline ::LSLAM::LanguagePackMsg* TuyaDpMsg::release_language_pack_msg() {
  
  ::LSLAM::LanguagePackMsg* temp = _impl_.language_pack_msg_;
  _impl_.language_pack_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::LanguagePackMsg* TuyaDpMsg::unsafe_arena_release_language_pack_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.language_pack_msg)
  
  ::LSLAM::LanguagePackMsg* temp = _impl_.language_pack_msg_;
  _impl_.language_pack_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::LanguagePackMsg* TuyaDpMsg::_internal_mutable_language_pack_msg() {
  
  if (_impl_.language_pack_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::LanguagePackMsg>(GetArenaForAllocation());
    _impl_.language_pack_msg_ = p;
  }
  return _impl_.language_pack_msg_;
}
inline ::LSLAM::LanguagePackMsg* TuyaDpMsg::mutable_language_pack_msg() {
  ::LSLAM::LanguagePackMsg* _msg = _internal_mutable_language_pack_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.language_pack_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_language_pack_msg(::LSLAM::LanguagePackMsg* language_pack_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.language_pack_msg_;
  }
  if (language_pack_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(language_pack_msg);
    if (message_arena != submessage_arena) {
      language_pack_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, language_pack_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.language_pack_msg_ = language_pack_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.language_pack_msg)
}

// .LSLAM.TuyaSettingMsg tuya_setting_msg = 7;
inline bool TuyaDpMsg::_internal_has_tuya_setting_msg() const {
  return this != internal_default_instance() && _impl_.tuya_setting_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_tuya_setting_msg() const {
  return _internal_has_tuya_setting_msg();
}
inline void TuyaDpMsg::clear_tuya_setting_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuya_setting_msg_ != nullptr) {
    delete _impl_.tuya_setting_msg_;
  }
  _impl_.tuya_setting_msg_ = nullptr;
}
inline const ::LSLAM::TuyaSettingMsg& TuyaDpMsg::_internal_tuya_setting_msg() const {
  const ::LSLAM::TuyaSettingMsg* p = _impl_.tuya_setting_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::TuyaSettingMsg&>(
      ::LSLAM::_TuyaSettingMsg_default_instance_);
}
inline const ::LSLAM::TuyaSettingMsg& TuyaDpMsg::tuya_setting_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.tuya_setting_msg)
  return _internal_tuya_setting_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_tuya_setting_msg(
    ::LSLAM::TuyaSettingMsg* tuya_setting_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuya_setting_msg_);
  }
  _impl_.tuya_setting_msg_ = tuya_setting_msg;
  if (tuya_setting_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.tuya_setting_msg)
}
inline ::LSLAM::TuyaSettingMsg* TuyaDpMsg::release_tuya_setting_msg() {
  
  ::LSLAM::TuyaSettingMsg* temp = _impl_.tuya_setting_msg_;
  _impl_.tuya_setting_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::TuyaSettingMsg* TuyaDpMsg::unsafe_arena_release_tuya_setting_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.tuya_setting_msg)
  
  ::LSLAM::TuyaSettingMsg* temp = _impl_.tuya_setting_msg_;
  _impl_.tuya_setting_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::TuyaSettingMsg* TuyaDpMsg::_internal_mutable_tuya_setting_msg() {
  
  if (_impl_.tuya_setting_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::TuyaSettingMsg>(GetArenaForAllocation());
    _impl_.tuya_setting_msg_ = p;
  }
  return _impl_.tuya_setting_msg_;
}
inline ::LSLAM::TuyaSettingMsg* TuyaDpMsg::mutable_tuya_setting_msg() {
  ::LSLAM::TuyaSettingMsg* _msg = _internal_mutable_tuya_setting_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.tuya_setting_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_tuya_setting_msg(::LSLAM::TuyaSettingMsg* tuya_setting_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuya_setting_msg_;
  }
  if (tuya_setting_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuya_setting_msg);
    if (message_arena != submessage_arena) {
      tuya_setting_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuya_setting_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuya_setting_msg_ = tuya_setting_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.tuya_setting_msg)
}

// .LSLAM.TuyaCommandMsg tuya_command_msg = 8;
inline bool TuyaDpMsg::_internal_has_tuya_command_msg() const {
  return this != internal_default_instance() && _impl_.tuya_command_msg_ != nullptr;
}
inline bool TuyaDpMsg::has_tuya_command_msg() const {
  return _internal_has_tuya_command_msg();
}
inline void TuyaDpMsg::clear_tuya_command_msg() {
  if (GetArenaForAllocation() == nullptr && _impl_.tuya_command_msg_ != nullptr) {
    delete _impl_.tuya_command_msg_;
  }
  _impl_.tuya_command_msg_ = nullptr;
}
inline const ::LSLAM::TuyaCommandMsg& TuyaDpMsg::_internal_tuya_command_msg() const {
  const ::LSLAM::TuyaCommandMsg* p = _impl_.tuya_command_msg_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::TuyaCommandMsg&>(
      ::LSLAM::_TuyaCommandMsg_default_instance_);
}
inline const ::LSLAM::TuyaCommandMsg& TuyaDpMsg::tuya_command_msg() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.tuya_command_msg)
  return _internal_tuya_command_msg();
}
inline void TuyaDpMsg::unsafe_arena_set_allocated_tuya_command_msg(
    ::LSLAM::TuyaCommandMsg* tuya_command_msg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tuya_command_msg_);
  }
  _impl_.tuya_command_msg_ = tuya_command_msg;
  if (tuya_command_msg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.TuyaDpMsg.tuya_command_msg)
}
inline ::LSLAM::TuyaCommandMsg* TuyaDpMsg::release_tuya_command_msg() {
  
  ::LSLAM::TuyaCommandMsg* temp = _impl_.tuya_command_msg_;
  _impl_.tuya_command_msg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::TuyaCommandMsg* TuyaDpMsg::unsafe_arena_release_tuya_command_msg() {
  // @@protoc_insertion_point(field_release:LSLAM.TuyaDpMsg.tuya_command_msg)
  
  ::LSLAM::TuyaCommandMsg* temp = _impl_.tuya_command_msg_;
  _impl_.tuya_command_msg_ = nullptr;
  return temp;
}
inline ::LSLAM::TuyaCommandMsg* TuyaDpMsg::_internal_mutable_tuya_command_msg() {
  
  if (_impl_.tuya_command_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::TuyaCommandMsg>(GetArenaForAllocation());
    _impl_.tuya_command_msg_ = p;
  }
  return _impl_.tuya_command_msg_;
}
inline ::LSLAM::TuyaCommandMsg* TuyaDpMsg::mutable_tuya_command_msg() {
  ::LSLAM::TuyaCommandMsg* _msg = _internal_mutable_tuya_command_msg();
  // @@protoc_insertion_point(field_mutable:LSLAM.TuyaDpMsg.tuya_command_msg)
  return _msg;
}
inline void TuyaDpMsg::set_allocated_tuya_command_msg(::LSLAM::TuyaCommandMsg* tuya_command_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tuya_command_msg_;
  }
  if (tuya_command_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tuya_command_msg);
    if (message_arena != submessage_arena) {
      tuya_command_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tuya_command_msg, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tuya_command_msg_ = tuya_command_msg;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.TuyaDpMsg.tuya_command_msg)
}

// int32 command_or_setting = 9;
inline void TuyaDpMsg::clear_command_or_setting() {
  _impl_.command_or_setting_ = 0;
}
inline int32_t TuyaDpMsg::_internal_command_or_setting() const {
  return _impl_.command_or_setting_;
}
inline int32_t TuyaDpMsg::command_or_setting() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.command_or_setting)
  return _internal_command_or_setting();
}
inline void TuyaDpMsg::_internal_set_command_or_setting(int32_t value) {
  
  _impl_.command_or_setting_ = value;
}
inline void TuyaDpMsg::set_command_or_setting(int32_t value) {
  _internal_set_command_or_setting(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaDpMsg.command_or_setting)
}

// .LSLAM.TuyaStartupMode startup_mode = 10;
inline void TuyaDpMsg::clear_startup_mode() {
  _impl_.startup_mode_ = 0;
}
inline ::LSLAM::TuyaStartupMode TuyaDpMsg::_internal_startup_mode() const {
  return static_cast< ::LSLAM::TuyaStartupMode >(_impl_.startup_mode_);
}
inline ::LSLAM::TuyaStartupMode TuyaDpMsg::startup_mode() const {
  // @@protoc_insertion_point(field_get:LSLAM.TuyaDpMsg.startup_mode)
  return _internal_startup_mode();
}
inline void TuyaDpMsg::_internal_set_startup_mode(::LSLAM::TuyaStartupMode value) {
  
  _impl_.startup_mode_ = value;
}
inline void TuyaDpMsg::set_startup_mode(::LSLAM::TuyaStartupMode value) {
  _internal_set_startup_mode(value);
  // @@protoc_insertion_point(field_set:LSLAM.TuyaDpMsg.startup_mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace LSLAM

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LSLAM::TuyaCommandMsg_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaCommandMsg_COMMAND>() {
  return ::LSLAM::TuyaCommandMsg_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaCommandMsg_RemoteControlDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaCommandMsg_RemoteControlDirection>() {
  return ::LSLAM::TuyaCommandMsg_RemoteControlDirection_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaCommandMsg_SuctionLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaCommandMsg_SuctionLevel>() {
  return ::LSLAM::TuyaCommandMsg_SuctionLevel_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaCommandMsg_WaterVolumeLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaCommandMsg_WaterVolumeLevel>() {
  return ::LSLAM::TuyaCommandMsg_WaterVolumeLevel_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_SET> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_SET>() {
  return ::LSLAM::TuyaSettingMsg_SET_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_CleanMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_CleanMode>() {
  return ::LSLAM::TuyaSettingMsg_CleanMode_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_CleanMotorState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_CleanMotorState>() {
  return ::LSLAM::TuyaSettingMsg_CleanMotorState_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_FanMotorLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_FanMotorLevel>() {
  return ::LSLAM::TuyaSettingMsg_FanMotorLevel_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_WaterBoxLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_WaterBoxLevel>() {
  return ::LSLAM::TuyaSettingMsg_WaterBoxLevel_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_YtypeSweep> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_YtypeSweep>() {
  return ::LSLAM::TuyaSettingMsg_YtypeSweep_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaSettingMsg_PenaltyAreaMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaSettingMsg_PenaltyAreaMode>() {
  return ::LSLAM::TuyaSettingMsg_PenaltyAreaMode_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::RobotStatusMsg_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::RobotStatusMsg_STATUS>() {
  return ::LSLAM::RobotStatusMsg_STATUS_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::RobotStatusMsg_Fault> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::RobotStatusMsg_Fault>() {
  return ::LSLAM::RobotStatusMsg_Fault_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::LanguagePackMsg_DownloadStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::LanguagePackMsg_DownloadStatus>() {
  return ::LSLAM::LanguagePackMsg_DownloadStatus_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::LanguagePackMsg_LanguageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::LanguagePackMsg_LanguageType>() {
  return ::LSLAM::LanguagePackMsg_LanguageType_descriptor();
}
template <> struct is_proto_enum< ::LSLAM::TuyaStartupMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::TuyaStartupMode>() {
  return ::LSLAM::TuyaStartupMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TuyaDpMessage_2eproto
