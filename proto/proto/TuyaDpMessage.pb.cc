// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TuyaDpMessage.proto

#include "TuyaDpMessage.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace LSLAM {
PROTOBUF_CONSTEXPR TuyaCommandMsg::TuyaCommandMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.plan_area_clean_points_)*/{}
  , /*decltype(_impl_.partition_segmentation_points_)*/{}
  , /*decltype(_impl_.room_id_)*/{}
  , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
  , /*decltype(_impl_.aim_point_clean_points_)*/nullptr
  , /*decltype(_impl_.current_command_)*/0
  , /*decltype(_impl_.select_area_clean_time_number_)*/0
  , /*decltype(_impl_.room_number_)*/0
  , /*decltype(_impl_.area_number_)*/0
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.suction_level_)*/0
  , /*decltype(_impl_.water_volume_level_)*/0
  , /*decltype(_impl_.plan_area_clean_time_number_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TuyaCommandMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TuyaCommandMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TuyaCommandMsgDefaultTypeInternal() {}
  union {
    TuyaCommandMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TuyaCommandMsgDefaultTypeInternal _TuyaCommandMsg_default_instance_;
PROTOBUF_CONSTEXPR TuyaSettingMsg::TuyaSettingMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.virtual_wall_points_)*/{}
  , /*decltype(_impl_.clean_time_number_)*/{}
  , /*decltype(_impl_._clean_time_number_cached_byte_size_)*/{0}
  , /*decltype(_impl_.room_number_)*/{}
  , /*decltype(_impl_._room_number_cached_byte_size_)*/{0}
  , /*decltype(_impl_.room_id_)*/{}
  , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
  , /*decltype(_impl_.partition_segmentation_points_)*/{}
  , /*decltype(_impl_.ban_sweep_penalty_area_points_)*/{}
  , /*decltype(_impl_.ban_clean_and_sweep_penalty_area_points_)*/{}
  , /*decltype(_impl_.fan_motor_level_)*/{}
  , /*decltype(_impl_._fan_motor_level_cached_byte_size_)*/{0}
  , /*decltype(_impl_.water_box_level_)*/{}
  , /*decltype(_impl_._water_box_level_cached_byte_size_)*/{0}
  , /*decltype(_impl_.ytype_sweep_)*/{}
  , /*decltype(_impl_._ytype_sweep_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_length_)*/{}
  , /*decltype(_impl_._name_length_cached_byte_size_)*/{0}
  , /*decltype(_impl_.room_name_)*/{}
  , /*decltype(_impl_.timing_open_or_close_)*/{}
  , /*decltype(_impl_._timing_open_or_close_cached_byte_size_)*/{0}
  , /*decltype(_impl_.timing_week_)*/{}
  , /*decltype(_impl_._timing_week_cached_byte_size_)*/{0}
  , /*decltype(_impl_.timing_start_time_)*/{}
  , /*decltype(_impl_._timing_start_time_cached_byte_size_)*/{0}
  , /*decltype(_impl_.timing_clean_mode_)*/{}
  , /*decltype(_impl_._timing_clean_mode_cached_byte_size_)*/{0}
  , /*decltype(_impl_.quiet_day_)*/{}
  , /*decltype(_impl_._quiet_day_cached_byte_size_)*/{0}
  , /*decltype(_impl_.clean_set_)*/0
  , /*decltype(_impl_.virtual_wall_number_)*/0
  , /*decltype(_impl_.ban_sweep_penalty_area_number_)*/0
  , /*decltype(_impl_.ban_clean_and_sweep_penalty_area_number_)*/0
  , /*decltype(_impl_.time_zone_)*/0
  , /*decltype(_impl_.timing_number_)*/0
  , /*decltype(_impl_.quiet_start_time_)*/0
  , /*decltype(_impl_.quiet_end_time_)*/0
  , /*decltype(_impl_.current_fan_motor_level_)*/0
  , /*decltype(_impl_.current_water_box_level_)*/0
  , /*decltype(_impl_.do_not_disturb_switch_open_)*/false
  , /*decltype(_impl_.breakpoint_continue_to_sweep_)*/false
  , /*decltype(_impl_.volume_)*/0
  , /*decltype(_impl_.set_result_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TuyaSettingMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TuyaSettingMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TuyaSettingMsgDefaultTypeInternal() {}
  union {
    TuyaSettingMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TuyaSettingMsgDefaultTypeInternal _TuyaSettingMsg_default_instance_;
PROTOBUF_CONSTEXPR RobotStatusMsg::RobotStatusMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.current_status_)*/0
  , /*decltype(_impl_.current_fault_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RobotStatusMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotStatusMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotStatusMsgDefaultTypeInternal() {}
  union {
    RobotStatusMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotStatusMsgDefaultTypeInternal _RobotStatusMsg_default_instance_;
PROTOBUF_CONSTEXPR DeviceMsg::DeviceMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wifi_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mcu_verssion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.firmware_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.device_sn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.module_uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rssi_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceMsgDefaultTypeInternal() {}
  union {
    DeviceMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceMsgDefaultTypeInternal _DeviceMsg_default_instance_;
PROTOBUF_CONSTEXPR CleanRecordMsg::CleanRecordMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clean_time_)*/0
  , /*decltype(_impl_.clean_area_)*/0
  , /*decltype(_impl_.all_clean_time_)*/0
  , /*decltype(_impl_.clean_time_number_)*/0
  , /*decltype(_impl_.all_clean_time_number_)*/0
  , /*decltype(_impl_.all_clean_area_)*/0
  , /*decltype(_impl_.clean_percentage_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CleanRecordMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CleanRecordMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CleanRecordMsgDefaultTypeInternal() {}
  union {
    CleanRecordMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CleanRecordMsgDefaultTypeInternal _CleanRecordMsg_default_instance_;
PROTOBUF_CONSTEXPR CleanDeviceMsg::CleanDeviceMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.edge_brush_life_)*/0
  , /*decltype(_impl_.roll_brush_life_)*/0
  , /*decltype(_impl_.filter_life_)*/0
  , /*decltype(_impl_.rag_life_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CleanDeviceMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CleanDeviceMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CleanDeviceMsgDefaultTypeInternal() {}
  union {
    CleanDeviceMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CleanDeviceMsgDefaultTypeInternal _CleanDeviceMsg_default_instance_;
PROTOBUF_CONSTEXPR LanguagePackMsg::LanguagePackMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.check_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_pack_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.download_status_)*/0
  , /*decltype(_impl_.download_and_install_schedu_)*/0
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_.check_code_length_)*/0
  , /*decltype(_impl_.language_pack_url_length_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LanguagePackMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LanguagePackMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LanguagePackMsgDefaultTypeInternal() {}
  union {
    LanguagePackMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LanguagePackMsgDefaultTypeInternal _LanguagePackMsg_default_instance_;
PROTOBUF_CONSTEXPR TuyaDpMsg::TuyaDpMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clean_device_msg_)*/nullptr
  , /*decltype(_impl_.clean_record_msg_)*/nullptr
  , /*decltype(_impl_.device_msg_)*/nullptr
  , /*decltype(_impl_.robot_status_msg_)*/nullptr
  , /*decltype(_impl_.language_pack_msg_)*/nullptr
  , /*decltype(_impl_.tuya_setting_msg_)*/nullptr
  , /*decltype(_impl_.tuya_command_msg_)*/nullptr
  , /*decltype(_impl_.battery_percentage_)*/0
  , /*decltype(_impl_.command_or_setting_)*/0
  , /*decltype(_impl_.startup_mode_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TuyaDpMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TuyaDpMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TuyaDpMsgDefaultTypeInternal() {}
  union {
    TuyaDpMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TuyaDpMsgDefaultTypeInternal _TuyaDpMsg_default_instance_;
}  // namespace LSLAM
static ::_pb::Metadata file_level_metadata_TuyaDpMessage_2eproto[8];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TuyaDpMessage_2eproto[16];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TuyaDpMessage_2eproto = nullptr;

const uint32_t TableStruct_TuyaDpMessage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.current_command_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.plan_area_clean_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.partition_segmentation_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.aim_point_clean_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.room_id_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.select_area_clean_time_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.room_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.area_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.suction_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.water_volume_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaCommandMsg, _impl_.plan_area_clean_time_number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.clean_set_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.virtual_wall_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.virtual_wall_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.clean_time_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.room_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.room_id_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.partition_segmentation_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.ban_sweep_penalty_area_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.ban_sweep_penalty_area_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.ban_clean_and_sweep_penalty_area_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.ban_clean_and_sweep_penalty_area_points_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.fan_motor_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.water_box_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.ytype_sweep_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.name_length_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.room_name_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.time_zone_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.timing_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.timing_open_or_close_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.timing_week_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.timing_start_time_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.timing_clean_mode_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.quiet_day_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.quiet_start_time_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.quiet_end_time_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.do_not_disturb_switch_open_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.current_fan_motor_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.current_water_box_level_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.breakpoint_continue_to_sweep_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaSettingMsg, _impl_.set_result_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::RobotStatusMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::RobotStatusMsg, _impl_.current_status_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::RobotStatusMsg, _impl_.current_fault_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.wifi_name_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.rssi_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.mac_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.mcu_verssion_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.firmware_version_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.device_sn_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::DeviceMsg, _impl_.module_uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.clean_time_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.clean_area_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.clean_time_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.all_clean_time_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.all_clean_area_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.all_clean_time_number_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanRecordMsg, _impl_.clean_percentage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanDeviceMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanDeviceMsg, _impl_.edge_brush_life_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanDeviceMsg, _impl_.roll_brush_life_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanDeviceMsg, _impl_.filter_life_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::CleanDeviceMsg, _impl_.rag_life_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.download_status_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.download_and_install_schedu_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.check_code_length_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.check_code_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.language_pack_url_length_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::LanguagePackMsg, _impl_.language_pack_url_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _split_
  ~0u,  // no sizeof(Split)
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.clean_device_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.clean_record_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.device_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.battery_percentage_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.robot_status_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.language_pack_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.tuya_setting_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.tuya_command_msg_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.command_or_setting_),
  PROTOBUF_FIELD_OFFSET(::LSLAM::TuyaDpMsg, _impl_.startup_mode_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::LSLAM::TuyaCommandMsg)},
  { 20, -1, -1, sizeof(::LSLAM::TuyaSettingMsg)},
  { 59, -1, -1, sizeof(::LSLAM::RobotStatusMsg)},
  { 69, -1, -1, sizeof(::LSLAM::DeviceMsg)},
  { 85, -1, -1, sizeof(::LSLAM::CleanRecordMsg)},
  { 100, -1, -1, sizeof(::LSLAM::CleanDeviceMsg)},
  { 112, -1, -1, sizeof(::LSLAM::LanguagePackMsg)},
  { 127, -1, -1, sizeof(::LSLAM::TuyaDpMsg)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::LSLAM::_TuyaCommandMsg_default_instance_._instance,
  &::LSLAM::_TuyaSettingMsg_default_instance_._instance,
  &::LSLAM::_RobotStatusMsg_default_instance_._instance,
  &::LSLAM::_DeviceMsg_default_instance_._instance,
  &::LSLAM::_CleanRecordMsg_default_instance_._instance,
  &::LSLAM::_CleanDeviceMsg_default_instance_._instance,
  &::LSLAM::_LanguagePackMsg_default_instance_._instance,
  &::LSLAM::_TuyaDpMsg_default_instance_._instance,
};

const char descriptor_table_protodef_TuyaDpMessage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023TuyaDpMessage.proto\022\005LSLAM\032\014Points.pro"
  "to\"\212\t\n\016TuyaCommandMsg\0226\n\017current_command"
  "\030\001 \001(\0162\035.LSLAM.TuyaCommandMsg.COMMAND\022-\n"
  "\026plan_area_clean_points\030\002 \003(\0132\r.LSLAM.Po"
  "ints\0224\n\035partition_segmentation_points\030\003 "
  "\003(\0132\r.LSLAM.Points\022-\n\026aim_point_clean_po"
  "ints\030\004 \001(\0132\r.LSLAM.Points\022\017\n\007room_id\030\005 \003"
  "(\005\022%\n\035select_area_clean_time_number\030\006 \001("
  "\005\022\023\n\013room_number\030\007 \001(\005\022\023\n\013area_number\030\010 "
  "\001(\005\022\?\n\tdirection\030\t \001(\0162,.LSLAM.TuyaComma"
  "ndMsg.RemoteControlDirection\0229\n\rsuction_"
  "level\030\022 \001(\0162\".LSLAM.TuyaCommandMsg.Sucti"
  "onLevel\022B\n\022water_volume_level\030\023 \001(\0162&.LS"
  "LAM.TuyaCommandMsg.WaterVolumeLevel\022#\n\033p"
  "lan_area_clean_time_number\030\024 \001(\005\"\312\001\n\007COM"
  "MAND\022\021\n\rclean_command\020\000\022\021\n\rpause_command"
  "\020\001\022\024\n\020recharge_command\020\002\022\025\n\021select_area_"
  "clean\020\003\022\023\n\017aim_point_clean\020\004\022\023\n\017plan_are"
  "a_clean\020\005\022\r\n\tover_task\020\006\022\022\n\016remote_contr"
  "ol\020\007\022\022\n\016look_for_robot\020\010\022\013\n\007explore\020\t\"h\n"
  "\026RemoteControlDirection\022\n\n\006DEFAIL\020\000\022\013\n\007F"
  "ORWARD\020\001\022\014\n\010BACKWARD\020\002\022\r\n\tTRUN_LEFT\020\003\022\016\n"
  "\nTURN_RIGHT\020\004\022\010\n\004STOP\020\005\"\223\001\n\014SuctionLevel"
  "\022\027\n\023SUCYION_LEVEL_CLOSE\020\000\022\026\n\022SUCYION_LEV"
  "EL_MUTE\020\001\022\030\n\024SUCYION_LEVEL_NORMAL\020\002\022\030\n\024S"
  "UCYION_LEVEL_STRONG\020\003\022\036\n\032SUCYION_LEVEL_S"
  "UPER_STRONG\020\004\"\227\001\n\020WaterVolumeLevel\022\031\n\025WA"
  "TER_BOX_LEVEL_CLOSE\020\000\022\027\n\023WATER_BOX_LEVEL"
  "_ONE\020\001\022\027\n\023WATER_BOX_LEVEL_TWO\020\002\022\031\n\025WATER"
  "_BOX_LEVEL_THREE\020\003\022\033\n\027WATER_BOX_LEVEL_NO"
  "T_SET\020\004\"\212\022\n\016TuyaSettingMsg\022,\n\tclean_set\030"
  "\001 \001(\0162\031.LSLAM.TuyaSettingMsg.SET\022\033\n\023virt"
  "ual_wall_number\030\002 \001(\005\022*\n\023virtual_wall_po"
  "ints\030\003 \003(\0132\r.LSLAM.Points\022\031\n\021clean_time_"
  "number\030\004 \003(\005\022\023\n\013room_number\030\005 \003(\005\022\017\n\007roo"
  "m_id\030\006 \003(\005\0224\n\035partition_segmentation_poi"
  "nts\030\007 \003(\0132\r.LSLAM.Points\022%\n\035ban_sweep_pe"
  "nalty_area_number\030\010 \001(\005\0224\n\035ban_sweep_pen"
  "alty_area_points\030\t \003(\0132\r.LSLAM.Points\022/\n"
  "\'ban_clean_and_sweep_penalty_area_number"
  "\030\n \001(\005\022>\n\'ban_clean_and_sweep_penalty_ar"
  "ea_points\030\013 \003(\0132\r.LSLAM.Points\022<\n\017fan_mo"
  "tor_level\030\014 \003(\0162#.LSLAM.TuyaSettingMsg.F"
  "anMotorLevel\022<\n\017water_box_level\030\r \003(\0162#."
  "LSLAM.TuyaSettingMsg.WaterBoxLevel\0225\n\013yt"
  "ype_sweep\030\016 \003(\0162 .LSLAM.TuyaSettingMsg.Y"
  "typeSweep\022\023\n\013name_length\030\017 \003(\005\022\021\n\troom_n"
  "ame\030\021 \003(\t\022\021\n\ttime_zone\030\022 \001(\005\022\025\n\rtiming_n"
  "umber\030\031 \001(\005\022\034\n\024timing_open_or_close\030\032 \003("
  "\005\022\023\n\013timing_week\030\033 \003(\005\022\031\n\021timing_start_t"
  "ime\030\034 \003(\005\022:\n\021timing_clean_mode\030\035 \003(\0162\037.L"
  "SLAM.TuyaSettingMsg.CleanMode\022\021\n\tquiet_d"
  "ay\030\036 \003(\005\022\030\n\020quiet_start_time\030\037 \001(\005\022\026\n\016qu"
  "iet_end_time\030  \001(\005\022\"\n\032do_not_disturb_swi"
  "tch_open\030! \001(\010\022D\n\027current_fan_motor_leve"
  "l\030\" \001(\0162#.LSLAM.TuyaSettingMsg.FanMotorL"
  "evel\022D\n\027current_water_box_level\030# \001(\0162#."
  "LSLAM.TuyaSettingMsg.WaterBoxLevel\022\016\n\006vo"
  "lume\030$ \001(\005\022$\n\034breakpoint_continue_to_swe"
  "ep\030% \001(\010\022\022\n\nset_result\030& \001(\005\"\342\003\n\003SET\022\024\n\020"
  "set_virtual_wall\020\000\022\024\n\020set_penalty_area\020\001"
  "\022\032\n\026partition_segmentation\020\002\022\023\n\017partitio"
  "n_merge\020\004\022!\n\035partition_restore_the_defau"
  "lt\020\005\022\027\n\023set_room_properties\020\006\022\016\n\nroom_na"
  "med\020\007\022\017\n\013clean_order\020\010\022\r\n\treset_map\020\t\022\020\n"
  "\014timing_clean\020\n\022\025\n\021save_map_to_cloud\020\013\022\025"
  "\n\021save_map_to_local\020\014\022\022\n\016do_not_disturb\020"
  "\r\022\024\n\020reset_edge_brush\020\016\022\024\n\020reset_roll_br"
  "ush\020\017\022\020\n\014reset_filter\020\020\022\022\n\016rag_life_rese"
  "t\020\021\022\025\n\021set_pack_language\020\022\022\016\n\nvolume_set"
  "\020\023\022\031\n\025do_not_disturb_switch\020\024\022\021\n\rset_fan"
  "_motor\020\025\022\027\n\023set_water_box_motor\020\026\"6\n\tCle"
  "anMode\022\t\n\005CLEAN\020\000\022\t\n\005SWEEP\020\001\022\023\n\017CLEAN_AN"
  "D_SWEEP\020\002\"\201\001\n\017CleanMotorState\022\025\n\021CLEAN_M"
  "OTOR_CLOSE\020\000\022\024\n\020CLEAN_MOTOR_OPEN\020\001\022\023\n\017CL"
  "EAN_MOTOR_LOW\020\002\022\026\n\022CLEAN_MOTOR_MEDIUM\020\003\022"
  "\024\n\020CLEAN_MOTOR_HIGH\020\004\"\227\001\n\rFanMotorLevel\022"
  "\023\n\017FAN_MOTOR_CLOSE\020\000\022\022\n\016FAN_MOTOR_MUTE\020\001"
  "\022\024\n\020FAN_MOTOR_NORMAL\020\002\022\024\n\020FAN_MOTOR_STRO"
  "NG\020\003\022\032\n\026FAN_MOTOR_SUPER_STRONG\020\004\022\025\n\021FAN_"
  "MOTOR_NOT_SET\020\005\"\224\001\n\rWaterBoxLevel\022\031\n\025WAT"
  "ER_BOX_LEVEL_CLOSE\020\000\022\027\n\023WATER_BOX_LEVEL_"
  "ONE\020\001\022\027\n\023WATER_BOX_LEVEL_TWO\020\002\022\031\n\025WATER_"
  "BOX_LEVEL_THREE\020\003\022\033\n\027WATER_BOX_LEVEL_NOT"
  "_SET\020\004\"R\n\nYtypeSweep\022\025\n\021YTYPE_SWEEP_CLOS"
  "E\020\000\022\024\n\020YTYPE_SWEEP_OPEN\020\001\022\027\n\023YTYPE_SWEEP"
  "_NOT_SET\020\002\"H\n\017PenaltyAreaMode\022\027\n\023ban_cle"
  "an_and_sweep\020\000\022\r\n\tban_clean\020\001\022\r\n\tban_swe"
  "ep\020\002\"\316\023\n\016RobotStatusMsg\0224\n\016current_statu"
  "s\030\001 \001(\0162\034.LSLAM.RobotStatusMsg.STATUS\0222\n"
  "\rcurrent_fault\030\002 \001(\0162\033.LSLAM.RobotStatus"
  "Msg.Fault\"\257\002\n\006STATUS\022\013\n\007initial\020\000\022\t\n\005sma"
  "rt\020\001\022\016\n\nzone_clean\020\002\022\016\n\npart_clean\020\003\022\014\n\010"
  "cleaning\020\004\022\n\n\006paused\020\005\022\014\n\010goto_pos\020\006\022\017\n\013"
  "pos_arrived\020\007\022\020\n\014pos_unarrive\020\010\022\017\n\013goto_"
  "charge\020\t\022\014\n\010charging\020\n\022\017\n\013charge_done\020\013\022"
  "\t\n\005sleep\020\014\022\017\n\013select_room\020\r\022\r\n\taim_clean"
  "\020\016\022\021\n\rcontrol_clean\020\017\022\013\n\007explore\020\020\022\032\n\026co"
  "me_down_from_partner\020\021\022\013\n\007standby\020\022\"\237\020\n\005"
  "Fault\022\014\n\010no_fault\020\000\022\024\n\020edge_sweep_fault\020"
  "\001\022\026\n\022middle_sweel_fault\020\002\022\024\n\020left_wheel_"
  "fault\020\003\022\025\n\021right_wheel_fault\020\004\022\025\n\021garbag"
  "e_box_fault\020\005\022\024\n\020land_check_fault\020\006\022\023\n\017c"
  "ollision_fault\020\007\022\036\n\032laser_ranging_sensor"
  "_fault\020\010\022\017\n\013D_TOF_fault\020\t\022\025\n\021edge_sensor"
  "_fault\020\n\022\"\n\036low_water_volume_of_water_ta"
  "nk\020\013\022\024\n\020dust_box_is_full\020\014\022\024\n\020dust_box_r"
  "emoved\020\r\022%\n!abnormal_installation_of_dus"
  "t_box\020\016\022)\n%abnormal_installation_of_roll"
  "er_brush\020\017\022 \n\034the_drive_wheel_is_entangl"
  "ed\020\020\022\017\n\013fan_blocked\020\021\022)\n%battery_is_too_"
  "low_return_to_charging\020\022\022$\n battery_is_t"
  "oo_low_stop_cleaning\020\023\022\031\n\025power_is_less_"
  "than_20\020\024\022/\n+charging_electrode_of_base_"
  "station_is_dirty\020\025\022\036\n\032complete_the_clean"
  "ing_task\020\026\022\031\n\025sweeping_area_blocked\020\027\022\034\n"
  "\030start_in_restricted_area\020\030\022 \n\034cleaning_"
  "area_does_not_exist\020\031\022\033\n\027positioning_abn"
  "ormality\020\032\022\036\n\032unable_to_continue_working"
  "\020\033\022$\n unable_to_return_to_base_station\020\034"
  "\022 \n\034water_shortage_in_water_tank\020\035\022%\n!wa"
  "ter_tank_not_installed_in_place\020\036\022\026\n\022wat"
  "er_tank_is_full\020\037\022\037\n\033dust_collection_bag"
  "_is_full\020 \022\032\n\026dust_collection_failed\020!\022\027"
  "\n\023sewage_tank_is_full\020\"\022\"\n\036sewage_tank_c"
  "annot_be_recycled\020#\022\030\n\024heating_system_fa"
  "ult\020$\022\023\n\017mop_drying_tips\020%\022)\n%enclosure_"
  "tank_cover_not_fully_closed\020&\022%\n!housing"
  "_dust_box_not_fully_closed\020\'\022\017\n\013broom_wa"
  "ter\020(\022\034\n\030sweeping_machine_pumping\020)\022\016\n\nh"
  "ost_start\020*\022\016\n\nhost_pause\020+\022\033\n\027suspensio"
  "n_sensor_fault\020,\022\033\n\027not_in_horizontal_pl"
  "ane\020-\022\037\n\033check_the_radar_upper_cover\020.\022!"
  "\n\035abnormal_noise_of_main_engine\020/\022\017\n\013sud"
  "den_stop\0200\022\034\n\030not_start_after_charging\0201"
  "\022\023\n\017rebuild_drawing\0202\022\030\n\024pause_during_ru"
  "nning\0203\022\026\n\022dust_duct_blockage\0205\022\022\n\016exces"
  "sive_dust\0206\022\013\n\007pick_up\0208\022\025\n\021dangling_han"
  "dling\0209\022\013\n\007trapped\020:\022 \n\034mop_brush_motor_"
  "is_not_setup\020;\022!\n\035edge_brush_motor_is_no"
  "t_setuo\020<\022\022\n\016edge_sweep_err\020=\022\024\n\020middle_"
  "sweel_err\020>\022\021\n\rbattery_error\020\?\022\023\n\017fan_mo"
  "tor_error\020@\022\034\n\030mop_brush_motor_is_twine\020"
  "A\022\032\n\026mop_brush_motor_is_err\020B\022(\n$partner"
  "_clean_water_box_is_not_exist\020C\022(\n$partn"
  "er_waste_water_box_is_not_exist\020D\022\032\n\026par"
  "tner_water_overflow\020E\022\037\n\033partner_dust_co"
  "llection_err\020F\022\031\n\025partner_clean_mop_err\020"
  "G\022\032\n\026partner_drying_mop_err\020H\022 \n\034partner"
  "_air_blower_error_err\020I\022\033\n\027dry_mop_tempe"
  "rature_err\020J\022\027\n\023start_up_when_slant\020K\"\235\001"
  "\n\tDeviceMsg\022\021\n\tWifi_name\030\001 \001(\t\022\014\n\004RSSI\030\002"
  " \001(\005\022\n\n\002ID\030\003 \001(\t\022\013\n\003Mac\030\004 \001(\t\022\024\n\014MCU_Ver"
  "ssion\030\005 \001(\t\022\030\n\020Firmware_Version\030\006 \001(\t\022\021\n"
  "\tdevice_SN\030\007 \001(\t\022\023\n\013module_UUID\030\010 \001(\t\"\274\001"
  "\n\016CleanRecordMsg\022\022\n\nclean_time\030\001 \001(\001\022\022\n\n"
  "clean_area\030\002 \001(\001\022\031\n\021clean_time_number\030\003 "
  "\001(\005\022\026\n\016all_clean_time\030\004 \001(\001\022\026\n\016all_clean"
  "_area\030\005 \001(\001\022\035\n\025all_clean_time_number\030\006 \001"
  "(\005\022\030\n\020clean_percentage\030\007 \001(\001\"i\n\016CleanDev"
  "iceMsg\022\027\n\017edge_brush_life\030\001 \001(\005\022\027\n\017roll_"
  "brush_life\030\002 \001(\005\022\023\n\013filter_life\030\003 \001(\005\022\020\n"
  "\010rag_life\030\004 \001(\005\"\263\004\n\017LanguagePackMsg\022>\n\017d"
  "ownload_status\030\001 \001(\0162%.LSLAM.LanguagePac"
  "kMsg.DownloadStatus\022#\n\033download_and_inst"
  "all_schedu\030\002 \001(\005\0225\n\010language\030\003 \001(\0162#.LSL"
  "AM.LanguagePackMsg.LanguageType\022\031\n\021check"
  "_code_length\030\004 \001(\005\022\022\n\ncheck_code\030\005 \001(\t\022 "
  "\n\030language_pack_url_length\030\006 \001(\005\022\031\n\021lang"
  "uage_pack_url\030\007 \001(\t\"U\n\016DownloadStatus\022\023\n"
  "\017DOWNLOAD_FAILED\020\000\022\016\n\nINSTALLING\020\001\022\023\n\017IN"
  "STALL_SUCCESS\020\002\022\t\n\005USING\020\003\"\300\001\n\014LanguageT"
  "ype\022\026\n\022SIMPLIFIED_CHINESE\020\000\022\027\n\023TRADITION"
  "AL_CHINESE\020\001\022\013\n\007ENGLISH\020\002\022\n\n\006GRTMAN\020\003\022\n\n"
  "\006FRENCH\020\004\022\013\n\007RUSSIAN\020\005\022\013\n\007SPANISH\020\006\022\n\n\006K"
  "OREAN\020\007\022\t\n\005LATIN\020\010\022\016\n\nPORTUGUESE\020\t\022\014\n\010JA"
  "PANESE\020\n\022\013\n\007ITALIAN\020\013\"\277\003\n\tTuyaDpMsg\022/\n\020c"
  "lean_device_msg\030\001 \001(\0132\025.LSLAM.CleanDevic"
  "eMsg\022/\n\020clean_record_msg\030\002 \001(\0132\025.LSLAM.C"
  "leanRecordMsg\022$\n\ndevice_msg\030\003 \001(\0132\020.LSLA"
  "M.DeviceMsg\022\032\n\022battery_percentage\030\004 \001(\005\022"
  "/\n\020robot_status_msg\030\005 \001(\0132\025.LSLAM.RobotS"
  "tatusMsg\0221\n\021language_pack_msg\030\006 \001(\0132\026.LS"
  "LAM.LanguagePackMsg\022/\n\020tuya_setting_msg\030"
  "\007 \001(\0132\025.LSLAM.TuyaSettingMsg\022/\n\020tuya_com"
  "mand_msg\030\010 \001(\0132\025.LSLAM.TuyaCommandMsg\022\032\n"
  "\022command_or_setting\030\t \001(\005\022,\n\014startup_mod"
  "e\030\n \001(\0162\026.LSLAM.TuyaStartupMode*\303\001\n\017Tuya"
  "StartupMode\022\n\n\006unused\020\000\022\020\n\014explore_mode\020"
  "\001\022\016\n\nclean_mode\020\002\022\016\n\nsweep_mode\020\003\022\030\n\024cle"
  "an_and_sweep_mode\020\004\022\021\n\rrecharge_mode\020\005\022\017"
  "\n\013timing_mode\020\006\022\r\n\taim_point\020\007\022\025\n\021select"
  "_area_clean\020\010\022\016\n\nedge_clean\020\tb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TuyaDpMessage_2eproto_deps[1] = {
  &::descriptor_table_Points_2eproto,
};
static ::_pbi::once_flag descriptor_table_TuyaDpMessage_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TuyaDpMessage_2eproto = {
    false, false, 7717, descriptor_table_protodef_TuyaDpMessage_2eproto,
    "TuyaDpMessage.proto",
    &descriptor_table_TuyaDpMessage_2eproto_once, descriptor_table_TuyaDpMessage_2eproto_deps, 1, 8,
    schemas, file_default_instances, TableStruct_TuyaDpMessage_2eproto::offsets,
    file_level_metadata_TuyaDpMessage_2eproto, file_level_enum_descriptors_TuyaDpMessage_2eproto,
    file_level_service_descriptors_TuyaDpMessage_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TuyaDpMessage_2eproto_getter() {
  return &descriptor_table_TuyaDpMessage_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TuyaDpMessage_2eproto(&descriptor_table_TuyaDpMessage_2eproto);
namespace LSLAM {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_COMMAND_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[0];
}
bool TuyaCommandMsg_COMMAND_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::clean_command;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::pause_command;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::recharge_command;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::select_area_clean;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::aim_point_clean;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::plan_area_clean;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::over_task;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::remote_control;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::look_for_robot;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::explore;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::COMMAND_MIN;
constexpr TuyaCommandMsg_COMMAND TuyaCommandMsg::COMMAND_MAX;
constexpr int TuyaCommandMsg::COMMAND_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_RemoteControlDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[1];
}
bool TuyaCommandMsg_RemoteControlDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::DEFAIL;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::FORWARD;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::BACKWARD;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::TRUN_LEFT;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::TURN_RIGHT;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::STOP;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::RemoteControlDirection_MIN;
constexpr TuyaCommandMsg_RemoteControlDirection TuyaCommandMsg::RemoteControlDirection_MAX;
constexpr int TuyaCommandMsg::RemoteControlDirection_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_SuctionLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[2];
}
bool TuyaCommandMsg_SuctionLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SUCYION_LEVEL_CLOSE;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SUCYION_LEVEL_MUTE;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SUCYION_LEVEL_NORMAL;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SUCYION_LEVEL_STRONG;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SUCYION_LEVEL_SUPER_STRONG;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SuctionLevel_MIN;
constexpr TuyaCommandMsg_SuctionLevel TuyaCommandMsg::SuctionLevel_MAX;
constexpr int TuyaCommandMsg::SuctionLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaCommandMsg_WaterVolumeLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[3];
}
bool TuyaCommandMsg_WaterVolumeLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WATER_BOX_LEVEL_CLOSE;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WATER_BOX_LEVEL_ONE;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WATER_BOX_LEVEL_TWO;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WATER_BOX_LEVEL_THREE;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WATER_BOX_LEVEL_NOT_SET;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WaterVolumeLevel_MIN;
constexpr TuyaCommandMsg_WaterVolumeLevel TuyaCommandMsg::WaterVolumeLevel_MAX;
constexpr int TuyaCommandMsg::WaterVolumeLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_SET_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[4];
}
bool TuyaSettingMsg_SET_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_virtual_wall;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_penalty_area;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::partition_segmentation;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::partition_merge;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::partition_restore_the_default;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_room_properties;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::room_named;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::clean_order;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::reset_map;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::timing_clean;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::save_map_to_cloud;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::save_map_to_local;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::do_not_disturb;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::reset_edge_brush;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::reset_roll_brush;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::reset_filter;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::rag_life_reset;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_pack_language;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::volume_set;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::do_not_disturb_switch;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_fan_motor;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::set_water_box_motor;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::SET_MIN;
constexpr TuyaSettingMsg_SET TuyaSettingMsg::SET_MAX;
constexpr int TuyaSettingMsg::SET_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_CleanMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[5];
}
bool TuyaSettingMsg_CleanMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg::CLEAN;
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg::SWEEP;
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg::CLEAN_AND_SWEEP;
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg::CleanMode_MIN;
constexpr TuyaSettingMsg_CleanMode TuyaSettingMsg::CleanMode_MAX;
constexpr int TuyaSettingMsg::CleanMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_CleanMotorState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[6];
}
bool TuyaSettingMsg_CleanMotorState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CLEAN_MOTOR_CLOSE;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CLEAN_MOTOR_OPEN;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CLEAN_MOTOR_LOW;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CLEAN_MOTOR_MEDIUM;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CLEAN_MOTOR_HIGH;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CleanMotorState_MIN;
constexpr TuyaSettingMsg_CleanMotorState TuyaSettingMsg::CleanMotorState_MAX;
constexpr int TuyaSettingMsg::CleanMotorState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_FanMotorLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[7];
}
bool TuyaSettingMsg_FanMotorLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_CLOSE;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_MUTE;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_NORMAL;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_STRONG;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_SUPER_STRONG;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FAN_MOTOR_NOT_SET;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FanMotorLevel_MIN;
constexpr TuyaSettingMsg_FanMotorLevel TuyaSettingMsg::FanMotorLevel_MAX;
constexpr int TuyaSettingMsg::FanMotorLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_WaterBoxLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[8];
}
bool TuyaSettingMsg_WaterBoxLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WATER_BOX_LEVEL_CLOSE;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WATER_BOX_LEVEL_ONE;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WATER_BOX_LEVEL_TWO;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WATER_BOX_LEVEL_THREE;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WATER_BOX_LEVEL_NOT_SET;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WaterBoxLevel_MIN;
constexpr TuyaSettingMsg_WaterBoxLevel TuyaSettingMsg::WaterBoxLevel_MAX;
constexpr int TuyaSettingMsg::WaterBoxLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_YtypeSweep_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[9];
}
bool TuyaSettingMsg_YtypeSweep_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg::YTYPE_SWEEP_CLOSE;
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg::YTYPE_SWEEP_OPEN;
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg::YTYPE_SWEEP_NOT_SET;
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg::YtypeSweep_MIN;
constexpr TuyaSettingMsg_YtypeSweep TuyaSettingMsg::YtypeSweep_MAX;
constexpr int TuyaSettingMsg::YtypeSweep_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaSettingMsg_PenaltyAreaMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[10];
}
bool TuyaSettingMsg_PenaltyAreaMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg::ban_clean_and_sweep;
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg::ban_clean;
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg::ban_sweep;
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg::PenaltyAreaMode_MIN;
constexpr TuyaSettingMsg_PenaltyAreaMode TuyaSettingMsg::PenaltyAreaMode_MAX;
constexpr int TuyaSettingMsg::PenaltyAreaMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotStatusMsg_STATUS_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[11];
}
bool RobotStatusMsg_STATUS_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RobotStatusMsg_STATUS RobotStatusMsg::initial;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::smart;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::zone_clean;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::part_clean;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::cleaning;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::paused;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::goto_pos;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::pos_arrived;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::pos_unarrive;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::goto_charge;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::charging;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::charge_done;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::sleep;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::select_room;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::aim_clean;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::control_clean;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::explore;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::come_down_from_partner;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::standby;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::STATUS_MIN;
constexpr RobotStatusMsg_STATUS RobotStatusMsg::STATUS_MAX;
constexpr int RobotStatusMsg::STATUS_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotStatusMsg_Fault_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[12];
}
bool RobotStatusMsg_Fault_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 53:
    case 54:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RobotStatusMsg_Fault RobotStatusMsg::no_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::edge_sweep_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::middle_sweel_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::left_wheel_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::right_wheel_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::garbage_box_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::land_check_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::collision_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::laser_ranging_sensor_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::D_TOF_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::edge_sensor_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::low_water_volume_of_water_tank;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dust_box_is_full;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dust_box_removed;
constexpr RobotStatusMsg_Fault RobotStatusMsg::abnormal_installation_of_dust_box;
constexpr RobotStatusMsg_Fault RobotStatusMsg::abnormal_installation_of_roller_brush;
constexpr RobotStatusMsg_Fault RobotStatusMsg::the_drive_wheel_is_entangled;
constexpr RobotStatusMsg_Fault RobotStatusMsg::fan_blocked;
constexpr RobotStatusMsg_Fault RobotStatusMsg::battery_is_too_low_return_to_charging;
constexpr RobotStatusMsg_Fault RobotStatusMsg::battery_is_too_low_stop_cleaning;
constexpr RobotStatusMsg_Fault RobotStatusMsg::power_is_less_than_20;
constexpr RobotStatusMsg_Fault RobotStatusMsg::charging_electrode_of_base_station_is_dirty;
constexpr RobotStatusMsg_Fault RobotStatusMsg::complete_the_cleaning_task;
constexpr RobotStatusMsg_Fault RobotStatusMsg::sweeping_area_blocked;
constexpr RobotStatusMsg_Fault RobotStatusMsg::start_in_restricted_area;
constexpr RobotStatusMsg_Fault RobotStatusMsg::cleaning_area_does_not_exist;
constexpr RobotStatusMsg_Fault RobotStatusMsg::positioning_abnormality;
constexpr RobotStatusMsg_Fault RobotStatusMsg::unable_to_continue_working;
constexpr RobotStatusMsg_Fault RobotStatusMsg::unable_to_return_to_base_station;
constexpr RobotStatusMsg_Fault RobotStatusMsg::water_shortage_in_water_tank;
constexpr RobotStatusMsg_Fault RobotStatusMsg::water_tank_not_installed_in_place;
constexpr RobotStatusMsg_Fault RobotStatusMsg::water_tank_is_full;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dust_collection_bag_is_full;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dust_collection_failed;
constexpr RobotStatusMsg_Fault RobotStatusMsg::sewage_tank_is_full;
constexpr RobotStatusMsg_Fault RobotStatusMsg::sewage_tank_cannot_be_recycled;
constexpr RobotStatusMsg_Fault RobotStatusMsg::heating_system_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::mop_drying_tips;
constexpr RobotStatusMsg_Fault RobotStatusMsg::enclosure_tank_cover_not_fully_closed;
constexpr RobotStatusMsg_Fault RobotStatusMsg::housing_dust_box_not_fully_closed;
constexpr RobotStatusMsg_Fault RobotStatusMsg::broom_water;
constexpr RobotStatusMsg_Fault RobotStatusMsg::sweeping_machine_pumping;
constexpr RobotStatusMsg_Fault RobotStatusMsg::host_start;
constexpr RobotStatusMsg_Fault RobotStatusMsg::host_pause;
constexpr RobotStatusMsg_Fault RobotStatusMsg::suspension_sensor_fault;
constexpr RobotStatusMsg_Fault RobotStatusMsg::not_in_horizontal_plane;
constexpr RobotStatusMsg_Fault RobotStatusMsg::check_the_radar_upper_cover;
constexpr RobotStatusMsg_Fault RobotStatusMsg::abnormal_noise_of_main_engine;
constexpr RobotStatusMsg_Fault RobotStatusMsg::sudden_stop;
constexpr RobotStatusMsg_Fault RobotStatusMsg::not_start_after_charging;
constexpr RobotStatusMsg_Fault RobotStatusMsg::rebuild_drawing;
constexpr RobotStatusMsg_Fault RobotStatusMsg::pause_during_running;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dust_duct_blockage;
constexpr RobotStatusMsg_Fault RobotStatusMsg::excessive_dust;
constexpr RobotStatusMsg_Fault RobotStatusMsg::pick_up;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dangling_handling;
constexpr RobotStatusMsg_Fault RobotStatusMsg::trapped;
constexpr RobotStatusMsg_Fault RobotStatusMsg::mop_brush_motor_is_not_setup;
constexpr RobotStatusMsg_Fault RobotStatusMsg::edge_brush_motor_is_not_setuo;
constexpr RobotStatusMsg_Fault RobotStatusMsg::edge_sweep_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::middle_sweel_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::battery_error;
constexpr RobotStatusMsg_Fault RobotStatusMsg::fan_motor_error;
constexpr RobotStatusMsg_Fault RobotStatusMsg::mop_brush_motor_is_twine;
constexpr RobotStatusMsg_Fault RobotStatusMsg::mop_brush_motor_is_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_clean_water_box_is_not_exist;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_waste_water_box_is_not_exist;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_water_overflow;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_dust_collection_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_clean_mop_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_drying_mop_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::partner_air_blower_error_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::dry_mop_temperature_err;
constexpr RobotStatusMsg_Fault RobotStatusMsg::start_up_when_slant;
constexpr RobotStatusMsg_Fault RobotStatusMsg::Fault_MIN;
constexpr RobotStatusMsg_Fault RobotStatusMsg::Fault_MAX;
constexpr int RobotStatusMsg::Fault_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguagePackMsg_DownloadStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[13];
}
bool LanguagePackMsg_DownloadStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::DOWNLOAD_FAILED;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::INSTALLING;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::INSTALL_SUCCESS;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::USING;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::DownloadStatus_MIN;
constexpr LanguagePackMsg_DownloadStatus LanguagePackMsg::DownloadStatus_MAX;
constexpr int LanguagePackMsg::DownloadStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguagePackMsg_LanguageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[14];
}
bool LanguagePackMsg_LanguageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::SIMPLIFIED_CHINESE;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::TRADITIONAL_CHINESE;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::ENGLISH;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::GRTMAN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::FRENCH;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::RUSSIAN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::SPANISH;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::KOREAN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::LATIN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::PORTUGUESE;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::JAPANESE;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::ITALIAN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::LanguageType_MIN;
constexpr LanguagePackMsg_LanguageType LanguagePackMsg::LanguageType_MAX;
constexpr int LanguagePackMsg::LanguageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TuyaStartupMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TuyaDpMessage_2eproto);
  return file_level_enum_descriptors_TuyaDpMessage_2eproto[15];
}
bool TuyaStartupMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TuyaCommandMsg::_Internal {
 public:
  static const ::LSLAM::Points& aim_point_clean_points(const TuyaCommandMsg* msg);
};

const ::LSLAM::Points&
TuyaCommandMsg::_Internal::aim_point_clean_points(const TuyaCommandMsg* msg) {
  return *msg->_impl_.aim_point_clean_points_;
}
void TuyaCommandMsg::clear_plan_area_clean_points() {
  _impl_.plan_area_clean_points_.Clear();
}
void TuyaCommandMsg::clear_partition_segmentation_points() {
  _impl_.partition_segmentation_points_.Clear();
}
void TuyaCommandMsg::clear_aim_point_clean_points() {
  if (GetArenaForAllocation() == nullptr && _impl_.aim_point_clean_points_ != nullptr) {
    delete _impl_.aim_point_clean_points_;
  }
  _impl_.aim_point_clean_points_ = nullptr;
}
TuyaCommandMsg::TuyaCommandMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.TuyaCommandMsg)
}
TuyaCommandMsg::TuyaCommandMsg(const TuyaCommandMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TuyaCommandMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.plan_area_clean_points_){from._impl_.plan_area_clean_points_}
    , decltype(_impl_.partition_segmentation_points_){from._impl_.partition_segmentation_points_}
    , decltype(_impl_.room_id_){from._impl_.room_id_}
    , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
    , decltype(_impl_.aim_point_clean_points_){nullptr}
    , decltype(_impl_.current_command_){}
    , decltype(_impl_.select_area_clean_time_number_){}
    , decltype(_impl_.room_number_){}
    , decltype(_impl_.area_number_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.suction_level_){}
    , decltype(_impl_.water_volume_level_){}
    , decltype(_impl_.plan_area_clean_time_number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_aim_point_clean_points()) {
    _this->_impl_.aim_point_clean_points_ = new ::LSLAM::Points(*from._impl_.aim_point_clean_points_);
  }
  ::memcpy(&_impl_.current_command_, &from._impl_.current_command_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.plan_area_clean_time_number_) -
    reinterpret_cast<char*>(&_impl_.current_command_)) + sizeof(_impl_.plan_area_clean_time_number_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.TuyaCommandMsg)
}

inline void TuyaCommandMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.plan_area_clean_points_){arena}
    , decltype(_impl_.partition_segmentation_points_){arena}
    , decltype(_impl_.room_id_){arena}
    , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
    , decltype(_impl_.aim_point_clean_points_){nullptr}
    , decltype(_impl_.current_command_){0}
    , decltype(_impl_.select_area_clean_time_number_){0}
    , decltype(_impl_.room_number_){0}
    , decltype(_impl_.area_number_){0}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.suction_level_){0}
    , decltype(_impl_.water_volume_level_){0}
    , decltype(_impl_.plan_area_clean_time_number_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TuyaCommandMsg::~TuyaCommandMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.TuyaCommandMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TuyaCommandMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.plan_area_clean_points_.~RepeatedPtrField();
  _impl_.partition_segmentation_points_.~RepeatedPtrField();
  _impl_.room_id_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.aim_point_clean_points_;
}

void TuyaCommandMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TuyaCommandMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.TuyaCommandMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.plan_area_clean_points_.Clear();
  _impl_.partition_segmentation_points_.Clear();
  _impl_.room_id_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.aim_point_clean_points_ != nullptr) {
    delete _impl_.aim_point_clean_points_;
  }
  _impl_.aim_point_clean_points_ = nullptr;
  ::memset(&_impl_.current_command_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.plan_area_clean_time_number_) -
      reinterpret_cast<char*>(&_impl_.current_command_)) + sizeof(_impl_.plan_area_clean_time_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TuyaCommandMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .LSLAM.TuyaCommandMsg.COMMAND current_command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_command(static_cast<::LSLAM::TuyaCommandMsg_COMMAND>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points plan_area_clean_points = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_plan_area_clean_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points partition_segmentation_points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partition_segmentation_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.Points aim_point_clean_points = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_aim_point_clean_points(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 room_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_room_id(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_room_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 select_area_clean_time_number = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.select_area_clean_time_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 room_number = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.room_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 area_number = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.area_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaCommandMsg.RemoteControlDirection direction = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_direction(static_cast<::LSLAM::TuyaCommandMsg_RemoteControlDirection>(val));
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaCommandMsg.SuctionLevel suction_level = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_suction_level(static_cast<::LSLAM::TuyaCommandMsg_SuctionLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaCommandMsg.WaterVolumeLevel water_volume_level = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_water_volume_level(static_cast<::LSLAM::TuyaCommandMsg_WaterVolumeLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 plan_area_clean_time_number = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.plan_area_clean_time_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TuyaCommandMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.TuyaCommandMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .LSLAM.TuyaCommandMsg.COMMAND current_command = 1;
  if (this->_internal_current_command() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_current_command(), target);
  }

  // repeated .LSLAM.Points plan_area_clean_points = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_plan_area_clean_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_plan_area_clean_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .LSLAM.Points partition_segmentation_points = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partition_segmentation_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_partition_segmentation_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .LSLAM.Points aim_point_clean_points = 4;
  if (this->_internal_has_aim_point_clean_points()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::aim_point_clean_points(this),
        _Internal::aim_point_clean_points(this).GetCachedSize(), target, stream);
  }

  // repeated int32 room_id = 5;
  {
    int byte_size = _impl_._room_id_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_room_id(), byte_size, target);
    }
  }

  // int32 select_area_clean_time_number = 6;
  if (this->_internal_select_area_clean_time_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_select_area_clean_time_number(), target);
  }

  // int32 room_number = 7;
  if (this->_internal_room_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_room_number(), target);
  }

  // int32 area_number = 8;
  if (this->_internal_area_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_area_number(), target);
  }

  // .LSLAM.TuyaCommandMsg.RemoteControlDirection direction = 9;
  if (this->_internal_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_direction(), target);
  }

  // .LSLAM.TuyaCommandMsg.SuctionLevel suction_level = 18;
  if (this->_internal_suction_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_suction_level(), target);
  }

  // .LSLAM.TuyaCommandMsg.WaterVolumeLevel water_volume_level = 19;
  if (this->_internal_water_volume_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_water_volume_level(), target);
  }

  // int32 plan_area_clean_time_number = 20;
  if (this->_internal_plan_area_clean_time_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_plan_area_clean_time_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.TuyaCommandMsg)
  return target;
}

size_t TuyaCommandMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.TuyaCommandMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .LSLAM.Points plan_area_clean_points = 2;
  total_size += 1UL * this->_internal_plan_area_clean_points_size();
  for (const auto& msg : this->_impl_.plan_area_clean_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LSLAM.Points partition_segmentation_points = 3;
  total_size += 1UL * this->_internal_partition_segmentation_points_size();
  for (const auto& msg : this->_impl_.partition_segmentation_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 room_id = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.room_id_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._room_id_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // .LSLAM.Points aim_point_clean_points = 4;
  if (this->_internal_has_aim_point_clean_points()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.aim_point_clean_points_);
  }

  // .LSLAM.TuyaCommandMsg.COMMAND current_command = 1;
  if (this->_internal_current_command() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_command());
  }

  // int32 select_area_clean_time_number = 6;
  if (this->_internal_select_area_clean_time_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_select_area_clean_time_number());
  }

  // int32 room_number = 7;
  if (this->_internal_room_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_room_number());
  }

  // int32 area_number = 8;
  if (this->_internal_area_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_area_number());
  }

  // .LSLAM.TuyaCommandMsg.RemoteControlDirection direction = 9;
  if (this->_internal_direction() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  // .LSLAM.TuyaCommandMsg.SuctionLevel suction_level = 18;
  if (this->_internal_suction_level() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_suction_level());
  }

  // .LSLAM.TuyaCommandMsg.WaterVolumeLevel water_volume_level = 19;
  if (this->_internal_water_volume_level() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_water_volume_level());
  }

  // int32 plan_area_clean_time_number = 20;
  if (this->_internal_plan_area_clean_time_number() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_plan_area_clean_time_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TuyaCommandMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TuyaCommandMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TuyaCommandMsg::GetClassData() const { return &_class_data_; }


void TuyaCommandMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TuyaCommandMsg*>(&to_msg);
  auto& from = static_cast<const TuyaCommandMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.TuyaCommandMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.plan_area_clean_points_.MergeFrom(from._impl_.plan_area_clean_points_);
  _this->_impl_.partition_segmentation_points_.MergeFrom(from._impl_.partition_segmentation_points_);
  _this->_impl_.room_id_.MergeFrom(from._impl_.room_id_);
  if (from._internal_has_aim_point_clean_points()) {
    _this->_internal_mutable_aim_point_clean_points()->::LSLAM::Points::MergeFrom(
        from._internal_aim_point_clean_points());
  }
  if (from._internal_current_command() != 0) {
    _this->_internal_set_current_command(from._internal_current_command());
  }
  if (from._internal_select_area_clean_time_number() != 0) {
    _this->_internal_set_select_area_clean_time_number(from._internal_select_area_clean_time_number());
  }
  if (from._internal_room_number() != 0) {
    _this->_internal_set_room_number(from._internal_room_number());
  }
  if (from._internal_area_number() != 0) {
    _this->_internal_set_area_number(from._internal_area_number());
  }
  if (from._internal_direction() != 0) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (from._internal_suction_level() != 0) {
    _this->_internal_set_suction_level(from._internal_suction_level());
  }
  if (from._internal_water_volume_level() != 0) {
    _this->_internal_set_water_volume_level(from._internal_water_volume_level());
  }
  if (from._internal_plan_area_clean_time_number() != 0) {
    _this->_internal_set_plan_area_clean_time_number(from._internal_plan_area_clean_time_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TuyaCommandMsg::CopyFrom(const TuyaCommandMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.TuyaCommandMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TuyaCommandMsg::IsInitialized() const {
  return true;
}

void TuyaCommandMsg::InternalSwap(TuyaCommandMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.plan_area_clean_points_.InternalSwap(&other->_impl_.plan_area_clean_points_);
  _impl_.partition_segmentation_points_.InternalSwap(&other->_impl_.partition_segmentation_points_);
  _impl_.room_id_.InternalSwap(&other->_impl_.room_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TuyaCommandMsg, _impl_.plan_area_clean_time_number_)
      + sizeof(TuyaCommandMsg::_impl_.plan_area_clean_time_number_)
      - PROTOBUF_FIELD_OFFSET(TuyaCommandMsg, _impl_.aim_point_clean_points_)>(
          reinterpret_cast<char*>(&_impl_.aim_point_clean_points_),
          reinterpret_cast<char*>(&other->_impl_.aim_point_clean_points_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TuyaCommandMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[0]);
}

// ===================================================================

class TuyaSettingMsg::_Internal {
 public:
};

void TuyaSettingMsg::clear_virtual_wall_points() {
  _impl_.virtual_wall_points_.Clear();
}
void TuyaSettingMsg::clear_partition_segmentation_points() {
  _impl_.partition_segmentation_points_.Clear();
}
void TuyaSettingMsg::clear_ban_sweep_penalty_area_points() {
  _impl_.ban_sweep_penalty_area_points_.Clear();
}
void TuyaSettingMsg::clear_ban_clean_and_sweep_penalty_area_points() {
  _impl_.ban_clean_and_sweep_penalty_area_points_.Clear();
}
TuyaSettingMsg::TuyaSettingMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.TuyaSettingMsg)
}
TuyaSettingMsg::TuyaSettingMsg(const TuyaSettingMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TuyaSettingMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.virtual_wall_points_){from._impl_.virtual_wall_points_}
    , decltype(_impl_.clean_time_number_){from._impl_.clean_time_number_}
    , /*decltype(_impl_._clean_time_number_cached_byte_size_)*/{0}
    , decltype(_impl_.room_number_){from._impl_.room_number_}
    , /*decltype(_impl_._room_number_cached_byte_size_)*/{0}
    , decltype(_impl_.room_id_){from._impl_.room_id_}
    , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
    , decltype(_impl_.partition_segmentation_points_){from._impl_.partition_segmentation_points_}
    , decltype(_impl_.ban_sweep_penalty_area_points_){from._impl_.ban_sweep_penalty_area_points_}
    , decltype(_impl_.ban_clean_and_sweep_penalty_area_points_){from._impl_.ban_clean_and_sweep_penalty_area_points_}
    , decltype(_impl_.fan_motor_level_){from._impl_.fan_motor_level_}
    , /*decltype(_impl_._fan_motor_level_cached_byte_size_)*/{0}
    , decltype(_impl_.water_box_level_){from._impl_.water_box_level_}
    , /*decltype(_impl_._water_box_level_cached_byte_size_)*/{0}
    , decltype(_impl_.ytype_sweep_){from._impl_.ytype_sweep_}
    , /*decltype(_impl_._ytype_sweep_cached_byte_size_)*/{0}
    , decltype(_impl_.name_length_){from._impl_.name_length_}
    , /*decltype(_impl_._name_length_cached_byte_size_)*/{0}
    , decltype(_impl_.room_name_){from._impl_.room_name_}
    , decltype(_impl_.timing_open_or_close_){from._impl_.timing_open_or_close_}
    , /*decltype(_impl_._timing_open_or_close_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_week_){from._impl_.timing_week_}
    , /*decltype(_impl_._timing_week_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_start_time_){from._impl_.timing_start_time_}
    , /*decltype(_impl_._timing_start_time_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_clean_mode_){from._impl_.timing_clean_mode_}
    , /*decltype(_impl_._timing_clean_mode_cached_byte_size_)*/{0}
    , decltype(_impl_.quiet_day_){from._impl_.quiet_day_}
    , /*decltype(_impl_._quiet_day_cached_byte_size_)*/{0}
    , decltype(_impl_.clean_set_){}
    , decltype(_impl_.virtual_wall_number_){}
    , decltype(_impl_.ban_sweep_penalty_area_number_){}
    , decltype(_impl_.ban_clean_and_sweep_penalty_area_number_){}
    , decltype(_impl_.time_zone_){}
    , decltype(_impl_.timing_number_){}
    , decltype(_impl_.quiet_start_time_){}
    , decltype(_impl_.quiet_end_time_){}
    , decltype(_impl_.current_fan_motor_level_){}
    , decltype(_impl_.current_water_box_level_){}
    , decltype(_impl_.do_not_disturb_switch_open_){}
    , decltype(_impl_.breakpoint_continue_to_sweep_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.set_result_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.clean_set_, &from._impl_.clean_set_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.set_result_) -
    reinterpret_cast<char*>(&_impl_.clean_set_)) + sizeof(_impl_.set_result_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.TuyaSettingMsg)
}

inline void TuyaSettingMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.virtual_wall_points_){arena}
    , decltype(_impl_.clean_time_number_){arena}
    , /*decltype(_impl_._clean_time_number_cached_byte_size_)*/{0}
    , decltype(_impl_.room_number_){arena}
    , /*decltype(_impl_._room_number_cached_byte_size_)*/{0}
    , decltype(_impl_.room_id_){arena}
    , /*decltype(_impl_._room_id_cached_byte_size_)*/{0}
    , decltype(_impl_.partition_segmentation_points_){arena}
    , decltype(_impl_.ban_sweep_penalty_area_points_){arena}
    , decltype(_impl_.ban_clean_and_sweep_penalty_area_points_){arena}
    , decltype(_impl_.fan_motor_level_){arena}
    , /*decltype(_impl_._fan_motor_level_cached_byte_size_)*/{0}
    , decltype(_impl_.water_box_level_){arena}
    , /*decltype(_impl_._water_box_level_cached_byte_size_)*/{0}
    , decltype(_impl_.ytype_sweep_){arena}
    , /*decltype(_impl_._ytype_sweep_cached_byte_size_)*/{0}
    , decltype(_impl_.name_length_){arena}
    , /*decltype(_impl_._name_length_cached_byte_size_)*/{0}
    , decltype(_impl_.room_name_){arena}
    , decltype(_impl_.timing_open_or_close_){arena}
    , /*decltype(_impl_._timing_open_or_close_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_week_){arena}
    , /*decltype(_impl_._timing_week_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_start_time_){arena}
    , /*decltype(_impl_._timing_start_time_cached_byte_size_)*/{0}
    , decltype(_impl_.timing_clean_mode_){arena}
    , /*decltype(_impl_._timing_clean_mode_cached_byte_size_)*/{0}
    , decltype(_impl_.quiet_day_){arena}
    , /*decltype(_impl_._quiet_day_cached_byte_size_)*/{0}
    , decltype(_impl_.clean_set_){0}
    , decltype(_impl_.virtual_wall_number_){0}
    , decltype(_impl_.ban_sweep_penalty_area_number_){0}
    , decltype(_impl_.ban_clean_and_sweep_penalty_area_number_){0}
    , decltype(_impl_.time_zone_){0}
    , decltype(_impl_.timing_number_){0}
    , decltype(_impl_.quiet_start_time_){0}
    , decltype(_impl_.quiet_end_time_){0}
    , decltype(_impl_.current_fan_motor_level_){0}
    , decltype(_impl_.current_water_box_level_){0}
    , decltype(_impl_.do_not_disturb_switch_open_){false}
    , decltype(_impl_.breakpoint_continue_to_sweep_){false}
    , decltype(_impl_.volume_){0}
    , decltype(_impl_.set_result_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TuyaSettingMsg::~TuyaSettingMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.TuyaSettingMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TuyaSettingMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.virtual_wall_points_.~RepeatedPtrField();
  _impl_.clean_time_number_.~RepeatedField();
  _impl_.room_number_.~RepeatedField();
  _impl_.room_id_.~RepeatedField();
  _impl_.partition_segmentation_points_.~RepeatedPtrField();
  _impl_.ban_sweep_penalty_area_points_.~RepeatedPtrField();
  _impl_.ban_clean_and_sweep_penalty_area_points_.~RepeatedPtrField();
  _impl_.fan_motor_level_.~RepeatedField();
  _impl_.water_box_level_.~RepeatedField();
  _impl_.ytype_sweep_.~RepeatedField();
  _impl_.name_length_.~RepeatedField();
  _impl_.room_name_.~RepeatedPtrField();
  _impl_.timing_open_or_close_.~RepeatedField();
  _impl_.timing_week_.~RepeatedField();
  _impl_.timing_start_time_.~RepeatedField();
  _impl_.timing_clean_mode_.~RepeatedField();
  _impl_.quiet_day_.~RepeatedField();
}

void TuyaSettingMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TuyaSettingMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.TuyaSettingMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.virtual_wall_points_.Clear();
  _impl_.clean_time_number_.Clear();
  _impl_.room_number_.Clear();
  _impl_.room_id_.Clear();
  _impl_.partition_segmentation_points_.Clear();
  _impl_.ban_sweep_penalty_area_points_.Clear();
  _impl_.ban_clean_and_sweep_penalty_area_points_.Clear();
  _impl_.fan_motor_level_.Clear();
  _impl_.water_box_level_.Clear();
  _impl_.ytype_sweep_.Clear();
  _impl_.name_length_.Clear();
  _impl_.room_name_.Clear();
  _impl_.timing_open_or_close_.Clear();
  _impl_.timing_week_.Clear();
  _impl_.timing_start_time_.Clear();
  _impl_.timing_clean_mode_.Clear();
  _impl_.quiet_day_.Clear();
  ::memset(&_impl_.clean_set_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.set_result_) -
      reinterpret_cast<char*>(&_impl_.clean_set_)) + sizeof(_impl_.set_result_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TuyaSettingMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .LSLAM.TuyaSettingMsg.SET clean_set = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_clean_set(static_cast<::LSLAM::TuyaSettingMsg_SET>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 virtual_wall_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.virtual_wall_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points virtual_wall_points = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_virtual_wall_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 clean_time_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_clean_time_number(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_clean_time_number(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 room_number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_room_number(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_room_number(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 room_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_room_id(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 48) {
          _internal_add_room_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points partition_segmentation_points = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partition_segmentation_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 ban_sweep_penalty_area_number = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ban_sweep_penalty_area_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points ban_sweep_penalty_area_points = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ban_sweep_penalty_area_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 ban_clean_and_sweep_penalty_area_number = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.ban_clean_and_sweep_penalty_area_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.Points ban_clean_and_sweep_penalty_area_points = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ban_clean_and_sweep_penalty_area_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.TuyaSettingMsg.FanMotorLevel fan_motor_level = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_fan_motor_level(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 96) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_fan_motor_level(static_cast<::LSLAM::TuyaSettingMsg_FanMotorLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.TuyaSettingMsg.WaterBoxLevel water_box_level = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_water_box_level(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 104) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_water_box_level(static_cast<::LSLAM::TuyaSettingMsg_WaterBoxLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.TuyaSettingMsg.YtypeSweep ytype_sweep = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_ytype_sweep(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 112) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_ytype_sweep(static_cast<::LSLAM::TuyaSettingMsg_YtypeSweep>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 name_length = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_name_length(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 120) {
          _internal_add_name_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string room_name = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_room_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "LSLAM.TuyaSettingMsg.room_name"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 time_zone = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.time_zone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 timing_number = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.timing_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 timing_open_or_close = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_timing_open_or_close(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 208) {
          _internal_add_timing_open_or_close(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 timing_week = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_timing_week(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 216) {
          _internal_add_timing_week(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 timing_start_time = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_timing_start_time(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 224) {
          _internal_add_timing_start_time(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .LSLAM.TuyaSettingMsg.CleanMode timing_clean_mode = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_timing_clean_mode(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 232) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_timing_clean_mode(static_cast<::LSLAM::TuyaSettingMsg_CleanMode>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 quiet_day = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_quiet_day(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 240) {
          _internal_add_quiet_day(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 quiet_start_time = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _impl_.quiet_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 quiet_end_time = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _impl_.quiet_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool do_not_disturb_switch_open = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.do_not_disturb_switch_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaSettingMsg.FanMotorLevel current_fan_motor_level = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_fan_motor_level(static_cast<::LSLAM::TuyaSettingMsg_FanMotorLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaSettingMsg.WaterBoxLevel current_water_box_level = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_water_box_level(static_cast<::LSLAM::TuyaSettingMsg_WaterBoxLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 volume = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool breakpoint_continue_to_sweep = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.breakpoint_continue_to_sweep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 set_result = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.set_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TuyaSettingMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.TuyaSettingMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .LSLAM.TuyaSettingMsg.SET clean_set = 1;
  if (this->_internal_clean_set() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_clean_set(), target);
  }

  // int32 virtual_wall_number = 2;
  if (this->_internal_virtual_wall_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_virtual_wall_number(), target);
  }

  // repeated .LSLAM.Points virtual_wall_points = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_virtual_wall_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_virtual_wall_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int32 clean_time_number = 4;
  {
    int byte_size = _impl_._clean_time_number_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, _internal_clean_time_number(), byte_size, target);
    }
  }

  // repeated int32 room_number = 5;
  {
    int byte_size = _impl_._room_number_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_room_number(), byte_size, target);
    }
  }

  // repeated int32 room_id = 6;
  {
    int byte_size = _impl_._room_id_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          6, _internal_room_id(), byte_size, target);
    }
  }

  // repeated .LSLAM.Points partition_segmentation_points = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_partition_segmentation_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_partition_segmentation_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 ban_sweep_penalty_area_number = 8;
  if (this->_internal_ban_sweep_penalty_area_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_ban_sweep_penalty_area_number(), target);
  }

  // repeated .LSLAM.Points ban_sweep_penalty_area_points = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ban_sweep_penalty_area_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_ban_sweep_penalty_area_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 ban_clean_and_sweep_penalty_area_number = 10;
  if (this->_internal_ban_clean_and_sweep_penalty_area_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_ban_clean_and_sweep_penalty_area_number(), target);
  }

  // repeated .LSLAM.Points ban_clean_and_sweep_penalty_area_points = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ban_clean_and_sweep_penalty_area_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_ban_clean_and_sweep_penalty_area_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .LSLAM.TuyaSettingMsg.FanMotorLevel fan_motor_level = 12;
  {
    int byte_size = _impl_._fan_motor_level_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          12, _impl_.fan_motor_level_, byte_size, target);
    }
  }

  // repeated .LSLAM.TuyaSettingMsg.WaterBoxLevel water_box_level = 13;
  {
    int byte_size = _impl_._water_box_level_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          13, _impl_.water_box_level_, byte_size, target);
    }
  }

  // repeated .LSLAM.TuyaSettingMsg.YtypeSweep ytype_sweep = 14;
  {
    int byte_size = _impl_._ytype_sweep_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          14, _impl_.ytype_sweep_, byte_size, target);
    }
  }

  // repeated int32 name_length = 15;
  {
    int byte_size = _impl_._name_length_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          15, _internal_name_length(), byte_size, target);
    }
  }

  // repeated string room_name = 17;
  for (int i = 0, n = this->_internal_room_name_size(); i < n; i++) {
    const auto& s = this->_internal_room_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.TuyaSettingMsg.room_name");
    target = stream->WriteString(17, s, target);
  }

  // int32 time_zone = 18;
  if (this->_internal_time_zone() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_time_zone(), target);
  }

  // int32 timing_number = 25;
  if (this->_internal_timing_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_timing_number(), target);
  }

  // repeated int32 timing_open_or_close = 26;
  {
    int byte_size = _impl_._timing_open_or_close_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          26, _internal_timing_open_or_close(), byte_size, target);
    }
  }

  // repeated int32 timing_week = 27;
  {
    int byte_size = _impl_._timing_week_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          27, _internal_timing_week(), byte_size, target);
    }
  }

  // repeated int32 timing_start_time = 28;
  {
    int byte_size = _impl_._timing_start_time_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          28, _internal_timing_start_time(), byte_size, target);
    }
  }

  // repeated .LSLAM.TuyaSettingMsg.CleanMode timing_clean_mode = 29;
  {
    int byte_size = _impl_._timing_clean_mode_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          29, _impl_.timing_clean_mode_, byte_size, target);
    }
  }

  // repeated int32 quiet_day = 30;
  {
    int byte_size = _impl_._quiet_day_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          30, _internal_quiet_day(), byte_size, target);
    }
  }

  // int32 quiet_start_time = 31;
  if (this->_internal_quiet_start_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(31, this->_internal_quiet_start_time(), target);
  }

  // int32 quiet_end_time = 32;
  if (this->_internal_quiet_end_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(32, this->_internal_quiet_end_time(), target);
  }

  // bool do_not_disturb_switch_open = 33;
  if (this->_internal_do_not_disturb_switch_open() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_do_not_disturb_switch_open(), target);
  }

  // .LSLAM.TuyaSettingMsg.FanMotorLevel current_fan_motor_level = 34;
  if (this->_internal_current_fan_motor_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_current_fan_motor_level(), target);
  }

  // .LSLAM.TuyaSettingMsg.WaterBoxLevel current_water_box_level = 35;
  if (this->_internal_current_water_box_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      35, this->_internal_current_water_box_level(), target);
  }

  // int32 volume = 36;
  if (this->_internal_volume() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(36, this->_internal_volume(), target);
  }

  // bool breakpoint_continue_to_sweep = 37;
  if (this->_internal_breakpoint_continue_to_sweep() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_breakpoint_continue_to_sweep(), target);
  }

  // int32 set_result = 38;
  if (this->_internal_set_result() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(38, this->_internal_set_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.TuyaSettingMsg)
  return target;
}

size_t TuyaSettingMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.TuyaSettingMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .LSLAM.Points virtual_wall_points = 3;
  total_size += 1UL * this->_internal_virtual_wall_points_size();
  for (const auto& msg : this->_impl_.virtual_wall_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 clean_time_number = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.clean_time_number_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._clean_time_number_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 room_number = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.room_number_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._room_number_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 room_id = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.room_id_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._room_id_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated .LSLAM.Points partition_segmentation_points = 7;
  total_size += 1UL * this->_internal_partition_segmentation_points_size();
  for (const auto& msg : this->_impl_.partition_segmentation_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LSLAM.Points ban_sweep_penalty_area_points = 9;
  total_size += 1UL * this->_internal_ban_sweep_penalty_area_points_size();
  for (const auto& msg : this->_impl_.ban_sweep_penalty_area_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LSLAM.Points ban_clean_and_sweep_penalty_area_points = 11;
  total_size += 1UL * this->_internal_ban_clean_and_sweep_penalty_area_points_size();
  for (const auto& msg : this->_impl_.ban_clean_and_sweep_penalty_area_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LSLAM.TuyaSettingMsg.FanMotorLevel fan_motor_level = 12;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_fan_motor_level_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_fan_motor_level(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._fan_motor_level_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated .LSLAM.TuyaSettingMsg.WaterBoxLevel water_box_level = 13;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_water_box_level_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_water_box_level(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._water_box_level_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated .LSLAM.TuyaSettingMsg.YtypeSweep ytype_sweep = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_ytype_sweep_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_ytype_sweep(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ytype_sweep_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 name_length = 15;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.name_length_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._name_length_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated string room_name = 17;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.room_name_.size());
  for (int i = 0, n = _impl_.room_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.room_name_.Get(i));
  }

  // repeated int32 timing_open_or_close = 26;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.timing_open_or_close_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._timing_open_or_close_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 timing_week = 27;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.timing_week_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._timing_week_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 timing_start_time = 28;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.timing_start_time_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._timing_start_time_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated .LSLAM.TuyaSettingMsg.CleanMode timing_clean_mode = 29;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_timing_clean_mode_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_timing_clean_mode(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._timing_clean_mode_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // repeated int32 quiet_day = 30;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.quiet_day_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._quiet_day_cached_byte_size_.Set(cached_size);
    total_size += data_size;
  }

  // .LSLAM.TuyaSettingMsg.SET clean_set = 1;
  if (this->_internal_clean_set() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_clean_set());
  }

  // int32 virtual_wall_number = 2;
  if (this->_internal_virtual_wall_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_virtual_wall_number());
  }

  // int32 ban_sweep_penalty_area_number = 8;
  if (this->_internal_ban_sweep_penalty_area_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ban_sweep_penalty_area_number());
  }

  // int32 ban_clean_and_sweep_penalty_area_number = 10;
  if (this->_internal_ban_clean_and_sweep_penalty_area_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ban_clean_and_sweep_penalty_area_number());
  }

  // int32 time_zone = 18;
  if (this->_internal_time_zone() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_time_zone());
  }

  // int32 timing_number = 25;
  if (this->_internal_timing_number() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_timing_number());
  }

  // int32 quiet_start_time = 31;
  if (this->_internal_quiet_start_time() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_quiet_start_time());
  }

  // int32 quiet_end_time = 32;
  if (this->_internal_quiet_end_time() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_quiet_end_time());
  }

  // .LSLAM.TuyaSettingMsg.FanMotorLevel current_fan_motor_level = 34;
  if (this->_internal_current_fan_motor_level() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_fan_motor_level());
  }

  // .LSLAM.TuyaSettingMsg.WaterBoxLevel current_water_box_level = 35;
  if (this->_internal_current_water_box_level() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_water_box_level());
  }

  // bool do_not_disturb_switch_open = 33;
  if (this->_internal_do_not_disturb_switch_open() != 0) {
    total_size += 2 + 1;
  }

  // bool breakpoint_continue_to_sweep = 37;
  if (this->_internal_breakpoint_continue_to_sweep() != 0) {
    total_size += 2 + 1;
  }

  // int32 volume = 36;
  if (this->_internal_volume() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_volume());
  }

  // int32 set_result = 38;
  if (this->_internal_set_result() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_set_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TuyaSettingMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TuyaSettingMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TuyaSettingMsg::GetClassData() const { return &_class_data_; }


void TuyaSettingMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TuyaSettingMsg*>(&to_msg);
  auto& from = static_cast<const TuyaSettingMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.TuyaSettingMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.virtual_wall_points_.MergeFrom(from._impl_.virtual_wall_points_);
  _this->_impl_.clean_time_number_.MergeFrom(from._impl_.clean_time_number_);
  _this->_impl_.room_number_.MergeFrom(from._impl_.room_number_);
  _this->_impl_.room_id_.MergeFrom(from._impl_.room_id_);
  _this->_impl_.partition_segmentation_points_.MergeFrom(from._impl_.partition_segmentation_points_);
  _this->_impl_.ban_sweep_penalty_area_points_.MergeFrom(from._impl_.ban_sweep_penalty_area_points_);
  _this->_impl_.ban_clean_and_sweep_penalty_area_points_.MergeFrom(from._impl_.ban_clean_and_sweep_penalty_area_points_);
  _this->_impl_.fan_motor_level_.MergeFrom(from._impl_.fan_motor_level_);
  _this->_impl_.water_box_level_.MergeFrom(from._impl_.water_box_level_);
  _this->_impl_.ytype_sweep_.MergeFrom(from._impl_.ytype_sweep_);
  _this->_impl_.name_length_.MergeFrom(from._impl_.name_length_);
  _this->_impl_.room_name_.MergeFrom(from._impl_.room_name_);
  _this->_impl_.timing_open_or_close_.MergeFrom(from._impl_.timing_open_or_close_);
  _this->_impl_.timing_week_.MergeFrom(from._impl_.timing_week_);
  _this->_impl_.timing_start_time_.MergeFrom(from._impl_.timing_start_time_);
  _this->_impl_.timing_clean_mode_.MergeFrom(from._impl_.timing_clean_mode_);
  _this->_impl_.quiet_day_.MergeFrom(from._impl_.quiet_day_);
  if (from._internal_clean_set() != 0) {
    _this->_internal_set_clean_set(from._internal_clean_set());
  }
  if (from._internal_virtual_wall_number() != 0) {
    _this->_internal_set_virtual_wall_number(from._internal_virtual_wall_number());
  }
  if (from._internal_ban_sweep_penalty_area_number() != 0) {
    _this->_internal_set_ban_sweep_penalty_area_number(from._internal_ban_sweep_penalty_area_number());
  }
  if (from._internal_ban_clean_and_sweep_penalty_area_number() != 0) {
    _this->_internal_set_ban_clean_and_sweep_penalty_area_number(from._internal_ban_clean_and_sweep_penalty_area_number());
  }
  if (from._internal_time_zone() != 0) {
    _this->_internal_set_time_zone(from._internal_time_zone());
  }
  if (from._internal_timing_number() != 0) {
    _this->_internal_set_timing_number(from._internal_timing_number());
  }
  if (from._internal_quiet_start_time() != 0) {
    _this->_internal_set_quiet_start_time(from._internal_quiet_start_time());
  }
  if (from._internal_quiet_end_time() != 0) {
    _this->_internal_set_quiet_end_time(from._internal_quiet_end_time());
  }
  if (from._internal_current_fan_motor_level() != 0) {
    _this->_internal_set_current_fan_motor_level(from._internal_current_fan_motor_level());
  }
  if (from._internal_current_water_box_level() != 0) {
    _this->_internal_set_current_water_box_level(from._internal_current_water_box_level());
  }
  if (from._internal_do_not_disturb_switch_open() != 0) {
    _this->_internal_set_do_not_disturb_switch_open(from._internal_do_not_disturb_switch_open());
  }
  if (from._internal_breakpoint_continue_to_sweep() != 0) {
    _this->_internal_set_breakpoint_continue_to_sweep(from._internal_breakpoint_continue_to_sweep());
  }
  if (from._internal_volume() != 0) {
    _this->_internal_set_volume(from._internal_volume());
  }
  if (from._internal_set_result() != 0) {
    _this->_internal_set_set_result(from._internal_set_result());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TuyaSettingMsg::CopyFrom(const TuyaSettingMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.TuyaSettingMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TuyaSettingMsg::IsInitialized() const {
  return true;
}

void TuyaSettingMsg::InternalSwap(TuyaSettingMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.virtual_wall_points_.InternalSwap(&other->_impl_.virtual_wall_points_);
  _impl_.clean_time_number_.InternalSwap(&other->_impl_.clean_time_number_);
  _impl_.room_number_.InternalSwap(&other->_impl_.room_number_);
  _impl_.room_id_.InternalSwap(&other->_impl_.room_id_);
  _impl_.partition_segmentation_points_.InternalSwap(&other->_impl_.partition_segmentation_points_);
  _impl_.ban_sweep_penalty_area_points_.InternalSwap(&other->_impl_.ban_sweep_penalty_area_points_);
  _impl_.ban_clean_and_sweep_penalty_area_points_.InternalSwap(&other->_impl_.ban_clean_and_sweep_penalty_area_points_);
  _impl_.fan_motor_level_.InternalSwap(&other->_impl_.fan_motor_level_);
  _impl_.water_box_level_.InternalSwap(&other->_impl_.water_box_level_);
  _impl_.ytype_sweep_.InternalSwap(&other->_impl_.ytype_sweep_);
  _impl_.name_length_.InternalSwap(&other->_impl_.name_length_);
  _impl_.room_name_.InternalSwap(&other->_impl_.room_name_);
  _impl_.timing_open_or_close_.InternalSwap(&other->_impl_.timing_open_or_close_);
  _impl_.timing_week_.InternalSwap(&other->_impl_.timing_week_);
  _impl_.timing_start_time_.InternalSwap(&other->_impl_.timing_start_time_);
  _impl_.timing_clean_mode_.InternalSwap(&other->_impl_.timing_clean_mode_);
  _impl_.quiet_day_.InternalSwap(&other->_impl_.quiet_day_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TuyaSettingMsg, _impl_.set_result_)
      + sizeof(TuyaSettingMsg::_impl_.set_result_)
      - PROTOBUF_FIELD_OFFSET(TuyaSettingMsg, _impl_.clean_set_)>(
          reinterpret_cast<char*>(&_impl_.clean_set_),
          reinterpret_cast<char*>(&other->_impl_.clean_set_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TuyaSettingMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[1]);
}

// ===================================================================

class RobotStatusMsg::_Internal {
 public:
};

RobotStatusMsg::RobotStatusMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.RobotStatusMsg)
}
RobotStatusMsg::RobotStatusMsg(const RobotStatusMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotStatusMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.current_status_){}
    , decltype(_impl_.current_fault_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.current_status_, &from._impl_.current_status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.current_fault_) -
    reinterpret_cast<char*>(&_impl_.current_status_)) + sizeof(_impl_.current_fault_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.RobotStatusMsg)
}

inline void RobotStatusMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.current_status_){0}
    , decltype(_impl_.current_fault_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RobotStatusMsg::~RobotStatusMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.RobotStatusMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotStatusMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotStatusMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotStatusMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.RobotStatusMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.current_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.current_fault_) -
      reinterpret_cast<char*>(&_impl_.current_status_)) + sizeof(_impl_.current_fault_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotStatusMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .LSLAM.RobotStatusMsg.STATUS current_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_status(static_cast<::LSLAM::RobotStatusMsg_STATUS>(val));
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.RobotStatusMsg.Fault current_fault = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_fault(static_cast<::LSLAM::RobotStatusMsg_Fault>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotStatusMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.RobotStatusMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .LSLAM.RobotStatusMsg.STATUS current_status = 1;
  if (this->_internal_current_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_current_status(), target);
  }

  // .LSLAM.RobotStatusMsg.Fault current_fault = 2;
  if (this->_internal_current_fault() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_current_fault(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.RobotStatusMsg)
  return target;
}

size_t RobotStatusMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.RobotStatusMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .LSLAM.RobotStatusMsg.STATUS current_status = 1;
  if (this->_internal_current_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_status());
  }

  // .LSLAM.RobotStatusMsg.Fault current_fault = 2;
  if (this->_internal_current_fault() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_current_fault());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotStatusMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotStatusMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotStatusMsg::GetClassData() const { return &_class_data_; }


void RobotStatusMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotStatusMsg*>(&to_msg);
  auto& from = static_cast<const RobotStatusMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.RobotStatusMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_current_status() != 0) {
    _this->_internal_set_current_status(from._internal_current_status());
  }
  if (from._internal_current_fault() != 0) {
    _this->_internal_set_current_fault(from._internal_current_fault());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotStatusMsg::CopyFrom(const RobotStatusMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.RobotStatusMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotStatusMsg::IsInitialized() const {
  return true;
}

void RobotStatusMsg::InternalSwap(RobotStatusMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotStatusMsg, _impl_.current_fault_)
      + sizeof(RobotStatusMsg::_impl_.current_fault_)
      - PROTOBUF_FIELD_OFFSET(RobotStatusMsg, _impl_.current_status_)>(
          reinterpret_cast<char*>(&_impl_.current_status_),
          reinterpret_cast<char*>(&other->_impl_.current_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotStatusMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[2]);
}

// ===================================================================

class DeviceMsg::_Internal {
 public:
};

DeviceMsg::DeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.DeviceMsg)
}
DeviceMsg::DeviceMsg(const DeviceMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeviceMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wifi_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.mcu_verssion_){}
    , decltype(_impl_.firmware_version_){}
    , decltype(_impl_.device_sn_){}
    , decltype(_impl_.module_uuid_){}
    , decltype(_impl_.rssi_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.wifi_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wifi_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_wifi_name().empty()) {
    _this->_impl_.wifi_name_.Set(from._internal_wifi_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_id().empty()) {
    _this->_impl_.id_.Set(from._internal_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mcu_verssion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mcu_verssion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mcu_verssion().empty()) {
    _this->_impl_.mcu_verssion_.Set(from._internal_mcu_verssion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_version().empty()) {
    _this->_impl_.firmware_version_.Set(from._internal_firmware_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.device_sn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_sn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device_sn().empty()) {
    _this->_impl_.device_sn_.Set(from._internal_device_sn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.module_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_module_uuid().empty()) {
    _this->_impl_.module_uuid_.Set(from._internal_module_uuid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.rssi_ = from._impl_.rssi_;
  // @@protoc_insertion_point(copy_constructor:LSLAM.DeviceMsg)
}

inline void DeviceMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wifi_name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.mcu_verssion_){}
    , decltype(_impl_.firmware_version_){}
    , decltype(_impl_.device_sn_){}
    , decltype(_impl_.module_uuid_){}
    , decltype(_impl_.rssi_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.wifi_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wifi_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mcu_verssion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mcu_verssion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.firmware_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.device_sn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_sn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.module_uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceMsg::~DeviceMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.DeviceMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wifi_name_.Destroy();
  _impl_.id_.Destroy();
  _impl_.mac_.Destroy();
  _impl_.mcu_verssion_.Destroy();
  _impl_.firmware_version_.Destroy();
  _impl_.device_sn_.Destroy();
  _impl_.module_uuid_.Destroy();
}

void DeviceMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.DeviceMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wifi_name_.ClearToEmpty();
  _impl_.id_.ClearToEmpty();
  _impl_.mac_.ClearToEmpty();
  _impl_.mcu_verssion_.ClearToEmpty();
  _impl_.firmware_version_.ClearToEmpty();
  _impl_.device_sn_.ClearToEmpty();
  _impl_.module_uuid_.ClearToEmpty();
  _impl_.rssi_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Wifi_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_wifi_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.Wifi_name"));
        } else
          goto handle_unusual;
        continue;
      // int32 RSSI = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.ID"));
        } else
          goto handle_unusual;
        continue;
      // string Mac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.Mac"));
        } else
          goto handle_unusual;
        continue;
      // string MCU_Verssion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mcu_verssion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.MCU_Verssion"));
        } else
          goto handle_unusual;
        continue;
      // string Firmware_Version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_firmware_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.Firmware_Version"));
        } else
          goto handle_unusual;
        continue;
      // string device_SN = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device_sn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.device_SN"));
        } else
          goto handle_unusual;
        continue;
      // string module_UUID = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_module_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.DeviceMsg.module_UUID"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.DeviceMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Wifi_name = 1;
  if (!this->_internal_wifi_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_wifi_name().data(), static_cast<int>(this->_internal_wifi_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.Wifi_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_wifi_name(), target);
  }

  // int32 RSSI = 2;
  if (this->_internal_rssi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rssi(), target);
  }

  // string ID = 3;
  if (!this->_internal_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.ID");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id(), target);
  }

  // string Mac = 4;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.Mac");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_mac(), target);
  }

  // string MCU_Verssion = 5;
  if (!this->_internal_mcu_verssion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mcu_verssion().data(), static_cast<int>(this->_internal_mcu_verssion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.MCU_Verssion");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_mcu_verssion(), target);
  }

  // string Firmware_Version = 6;
  if (!this->_internal_firmware_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_version().data(), static_cast<int>(this->_internal_firmware_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.Firmware_Version");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_firmware_version(), target);
  }

  // string device_SN = 7;
  if (!this->_internal_device_sn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_device_sn().data(), static_cast<int>(this->_internal_device_sn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.device_SN");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_device_sn(), target);
  }

  // string module_UUID = 8;
  if (!this->_internal_module_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_module_uuid().data(), static_cast<int>(this->_internal_module_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.DeviceMsg.module_UUID");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_module_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.DeviceMsg)
  return target;
}

size_t DeviceMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.DeviceMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Wifi_name = 1;
  if (!this->_internal_wifi_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_wifi_name());
  }

  // string ID = 3;
  if (!this->_internal_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  // string Mac = 4;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // string MCU_Verssion = 5;
  if (!this->_internal_mcu_verssion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mcu_verssion());
  }

  // string Firmware_Version = 6;
  if (!this->_internal_firmware_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_version());
  }

  // string device_SN = 7;
  if (!this->_internal_device_sn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_sn());
  }

  // string module_UUID = 8;
  if (!this->_internal_module_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_module_uuid());
  }

  // int32 RSSI = 2;
  if (this->_internal_rssi() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rssi());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeviceMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeviceMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeviceMsg::GetClassData() const { return &_class_data_; }


void DeviceMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeviceMsg*>(&to_msg);
  auto& from = static_cast<const DeviceMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.DeviceMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_wifi_name().empty()) {
    _this->_internal_set_wifi_name(from._internal_wifi_name());
  }
  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (!from._internal_mcu_verssion().empty()) {
    _this->_internal_set_mcu_verssion(from._internal_mcu_verssion());
  }
  if (!from._internal_firmware_version().empty()) {
    _this->_internal_set_firmware_version(from._internal_firmware_version());
  }
  if (!from._internal_device_sn().empty()) {
    _this->_internal_set_device_sn(from._internal_device_sn());
  }
  if (!from._internal_module_uuid().empty()) {
    _this->_internal_set_module_uuid(from._internal_module_uuid());
  }
  if (from._internal_rssi() != 0) {
    _this->_internal_set_rssi(from._internal_rssi());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceMsg::CopyFrom(const DeviceMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.DeviceMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceMsg::IsInitialized() const {
  return true;
}

void DeviceMsg::InternalSwap(DeviceMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wifi_name_, lhs_arena,
      &other->_impl_.wifi_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.id_, lhs_arena,
      &other->_impl_.id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mcu_verssion_, lhs_arena,
      &other->_impl_.mcu_verssion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firmware_version_, lhs_arena,
      &other->_impl_.firmware_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.device_sn_, lhs_arena,
      &other->_impl_.device_sn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.module_uuid_, lhs_arena,
      &other->_impl_.module_uuid_, rhs_arena
  );
  swap(_impl_.rssi_, other->_impl_.rssi_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[3]);
}

// ===================================================================

class CleanRecordMsg::_Internal {
 public:
};

CleanRecordMsg::CleanRecordMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.CleanRecordMsg)
}
CleanRecordMsg::CleanRecordMsg(const CleanRecordMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CleanRecordMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clean_time_){}
    , decltype(_impl_.clean_area_){}
    , decltype(_impl_.all_clean_time_){}
    , decltype(_impl_.clean_time_number_){}
    , decltype(_impl_.all_clean_time_number_){}
    , decltype(_impl_.all_clean_area_){}
    , decltype(_impl_.clean_percentage_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.clean_time_, &from._impl_.clean_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clean_percentage_) -
    reinterpret_cast<char*>(&_impl_.clean_time_)) + sizeof(_impl_.clean_percentage_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.CleanRecordMsg)
}

inline void CleanRecordMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clean_time_){0}
    , decltype(_impl_.clean_area_){0}
    , decltype(_impl_.all_clean_time_){0}
    , decltype(_impl_.clean_time_number_){0}
    , decltype(_impl_.all_clean_time_number_){0}
    , decltype(_impl_.all_clean_area_){0}
    , decltype(_impl_.clean_percentage_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CleanRecordMsg::~CleanRecordMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.CleanRecordMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CleanRecordMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CleanRecordMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CleanRecordMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.CleanRecordMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.clean_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.clean_percentage_) -
      reinterpret_cast<char*>(&_impl_.clean_time_)) + sizeof(_impl_.clean_percentage_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CleanRecordMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double clean_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.clean_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double clean_area = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.clean_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 clean_time_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.clean_time_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double all_clean_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.all_clean_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double all_clean_area = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.all_clean_area_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 all_clean_time_number = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.all_clean_time_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double clean_percentage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.clean_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CleanRecordMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.CleanRecordMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double clean_time = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_time = this->_internal_clean_time();
  uint64_t raw_clean_time;
  memcpy(&raw_clean_time, &tmp_clean_time, sizeof(tmp_clean_time));
  if (raw_clean_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_clean_time(), target);
  }

  // double clean_area = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_area = this->_internal_clean_area();
  uint64_t raw_clean_area;
  memcpy(&raw_clean_area, &tmp_clean_area, sizeof(tmp_clean_area));
  if (raw_clean_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_clean_area(), target);
  }

  // int32 clean_time_number = 3;
  if (this->_internal_clean_time_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_clean_time_number(), target);
  }

  // double all_clean_time = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_time = this->_internal_all_clean_time();
  uint64_t raw_all_clean_time;
  memcpy(&raw_all_clean_time, &tmp_all_clean_time, sizeof(tmp_all_clean_time));
  if (raw_all_clean_time != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_all_clean_time(), target);
  }

  // double all_clean_area = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_area = this->_internal_all_clean_area();
  uint64_t raw_all_clean_area;
  memcpy(&raw_all_clean_area, &tmp_all_clean_area, sizeof(tmp_all_clean_area));
  if (raw_all_clean_area != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_all_clean_area(), target);
  }

  // int32 all_clean_time_number = 6;
  if (this->_internal_all_clean_time_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_all_clean_time_number(), target);
  }

  // double clean_percentage = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_percentage = this->_internal_clean_percentage();
  uint64_t raw_clean_percentage;
  memcpy(&raw_clean_percentage, &tmp_clean_percentage, sizeof(tmp_clean_percentage));
  if (raw_clean_percentage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_clean_percentage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.CleanRecordMsg)
  return target;
}

size_t CleanRecordMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.CleanRecordMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double clean_time = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_time = this->_internal_clean_time();
  uint64_t raw_clean_time;
  memcpy(&raw_clean_time, &tmp_clean_time, sizeof(tmp_clean_time));
  if (raw_clean_time != 0) {
    total_size += 1 + 8;
  }

  // double clean_area = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_area = this->_internal_clean_area();
  uint64_t raw_clean_area;
  memcpy(&raw_clean_area, &tmp_clean_area, sizeof(tmp_clean_area));
  if (raw_clean_area != 0) {
    total_size += 1 + 8;
  }

  // double all_clean_time = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_time = this->_internal_all_clean_time();
  uint64_t raw_all_clean_time;
  memcpy(&raw_all_clean_time, &tmp_all_clean_time, sizeof(tmp_all_clean_time));
  if (raw_all_clean_time != 0) {
    total_size += 1 + 8;
  }

  // int32 clean_time_number = 3;
  if (this->_internal_clean_time_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_clean_time_number());
  }

  // int32 all_clean_time_number = 6;
  if (this->_internal_all_clean_time_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_all_clean_time_number());
  }

  // double all_clean_area = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_area = this->_internal_all_clean_area();
  uint64_t raw_all_clean_area;
  memcpy(&raw_all_clean_area, &tmp_all_clean_area, sizeof(tmp_all_clean_area));
  if (raw_all_clean_area != 0) {
    total_size += 1 + 8;
  }

  // double clean_percentage = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_percentage = this->_internal_clean_percentage();
  uint64_t raw_clean_percentage;
  memcpy(&raw_clean_percentage, &tmp_clean_percentage, sizeof(tmp_clean_percentage));
  if (raw_clean_percentage != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CleanRecordMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CleanRecordMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CleanRecordMsg::GetClassData() const { return &_class_data_; }


void CleanRecordMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CleanRecordMsg*>(&to_msg);
  auto& from = static_cast<const CleanRecordMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.CleanRecordMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_time = from._internal_clean_time();
  uint64_t raw_clean_time;
  memcpy(&raw_clean_time, &tmp_clean_time, sizeof(tmp_clean_time));
  if (raw_clean_time != 0) {
    _this->_internal_set_clean_time(from._internal_clean_time());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_area = from._internal_clean_area();
  uint64_t raw_clean_area;
  memcpy(&raw_clean_area, &tmp_clean_area, sizeof(tmp_clean_area));
  if (raw_clean_area != 0) {
    _this->_internal_set_clean_area(from._internal_clean_area());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_time = from._internal_all_clean_time();
  uint64_t raw_all_clean_time;
  memcpy(&raw_all_clean_time, &tmp_all_clean_time, sizeof(tmp_all_clean_time));
  if (raw_all_clean_time != 0) {
    _this->_internal_set_all_clean_time(from._internal_all_clean_time());
  }
  if (from._internal_clean_time_number() != 0) {
    _this->_internal_set_clean_time_number(from._internal_clean_time_number());
  }
  if (from._internal_all_clean_time_number() != 0) {
    _this->_internal_set_all_clean_time_number(from._internal_all_clean_time_number());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_all_clean_area = from._internal_all_clean_area();
  uint64_t raw_all_clean_area;
  memcpy(&raw_all_clean_area, &tmp_all_clean_area, sizeof(tmp_all_clean_area));
  if (raw_all_clean_area != 0) {
    _this->_internal_set_all_clean_area(from._internal_all_clean_area());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_clean_percentage = from._internal_clean_percentage();
  uint64_t raw_clean_percentage;
  memcpy(&raw_clean_percentage, &tmp_clean_percentage, sizeof(tmp_clean_percentage));
  if (raw_clean_percentage != 0) {
    _this->_internal_set_clean_percentage(from._internal_clean_percentage());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CleanRecordMsg::CopyFrom(const CleanRecordMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.CleanRecordMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CleanRecordMsg::IsInitialized() const {
  return true;
}

void CleanRecordMsg::InternalSwap(CleanRecordMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CleanRecordMsg, _impl_.clean_percentage_)
      + sizeof(CleanRecordMsg::_impl_.clean_percentage_)
      - PROTOBUF_FIELD_OFFSET(CleanRecordMsg, _impl_.clean_time_)>(
          reinterpret_cast<char*>(&_impl_.clean_time_),
          reinterpret_cast<char*>(&other->_impl_.clean_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CleanRecordMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[4]);
}

// ===================================================================

class CleanDeviceMsg::_Internal {
 public:
};

CleanDeviceMsg::CleanDeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.CleanDeviceMsg)
}
CleanDeviceMsg::CleanDeviceMsg(const CleanDeviceMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CleanDeviceMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.edge_brush_life_){}
    , decltype(_impl_.roll_brush_life_){}
    , decltype(_impl_.filter_life_){}
    , decltype(_impl_.rag_life_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.edge_brush_life_, &from._impl_.edge_brush_life_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rag_life_) -
    reinterpret_cast<char*>(&_impl_.edge_brush_life_)) + sizeof(_impl_.rag_life_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.CleanDeviceMsg)
}

inline void CleanDeviceMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.edge_brush_life_){0}
    , decltype(_impl_.roll_brush_life_){0}
    , decltype(_impl_.filter_life_){0}
    , decltype(_impl_.rag_life_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CleanDeviceMsg::~CleanDeviceMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.CleanDeviceMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CleanDeviceMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CleanDeviceMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CleanDeviceMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.CleanDeviceMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.edge_brush_life_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rag_life_) -
      reinterpret_cast<char*>(&_impl_.edge_brush_life_)) + sizeof(_impl_.rag_life_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CleanDeviceMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 edge_brush_life = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.edge_brush_life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 roll_brush_life = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.roll_brush_life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 filter_life = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.filter_life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 rag_life = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.rag_life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CleanDeviceMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.CleanDeviceMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 edge_brush_life = 1;
  if (this->_internal_edge_brush_life() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_edge_brush_life(), target);
  }

  // int32 roll_brush_life = 2;
  if (this->_internal_roll_brush_life() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_roll_brush_life(), target);
  }

  // int32 filter_life = 3;
  if (this->_internal_filter_life() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_filter_life(), target);
  }

  // int32 rag_life = 4;
  if (this->_internal_rag_life() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_rag_life(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.CleanDeviceMsg)
  return target;
}

size_t CleanDeviceMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.CleanDeviceMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 edge_brush_life = 1;
  if (this->_internal_edge_brush_life() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_edge_brush_life());
  }

  // int32 roll_brush_life = 2;
  if (this->_internal_roll_brush_life() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roll_brush_life());
  }

  // int32 filter_life = 3;
  if (this->_internal_filter_life() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_filter_life());
  }

  // int32 rag_life = 4;
  if (this->_internal_rag_life() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rag_life());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CleanDeviceMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CleanDeviceMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CleanDeviceMsg::GetClassData() const { return &_class_data_; }


void CleanDeviceMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CleanDeviceMsg*>(&to_msg);
  auto& from = static_cast<const CleanDeviceMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.CleanDeviceMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_edge_brush_life() != 0) {
    _this->_internal_set_edge_brush_life(from._internal_edge_brush_life());
  }
  if (from._internal_roll_brush_life() != 0) {
    _this->_internal_set_roll_brush_life(from._internal_roll_brush_life());
  }
  if (from._internal_filter_life() != 0) {
    _this->_internal_set_filter_life(from._internal_filter_life());
  }
  if (from._internal_rag_life() != 0) {
    _this->_internal_set_rag_life(from._internal_rag_life());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CleanDeviceMsg::CopyFrom(const CleanDeviceMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.CleanDeviceMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CleanDeviceMsg::IsInitialized() const {
  return true;
}

void CleanDeviceMsg::InternalSwap(CleanDeviceMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CleanDeviceMsg, _impl_.rag_life_)
      + sizeof(CleanDeviceMsg::_impl_.rag_life_)
      - PROTOBUF_FIELD_OFFSET(CleanDeviceMsg, _impl_.edge_brush_life_)>(
          reinterpret_cast<char*>(&_impl_.edge_brush_life_),
          reinterpret_cast<char*>(&other->_impl_.edge_brush_life_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CleanDeviceMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[5]);
}

// ===================================================================

class LanguagePackMsg::_Internal {
 public:
};

LanguagePackMsg::LanguagePackMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.LanguagePackMsg)
}
LanguagePackMsg::LanguagePackMsg(const LanguagePackMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LanguagePackMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.check_code_){}
    , decltype(_impl_.language_pack_url_){}
    , decltype(_impl_.download_status_){}
    , decltype(_impl_.download_and_install_schedu_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.check_code_length_){}
    , decltype(_impl_.language_pack_url_length_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.check_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_code().empty()) {
    _this->_impl_.check_code_.Set(from._internal_check_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_pack_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_pack_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_language_pack_url().empty()) {
    _this->_impl_.language_pack_url_.Set(from._internal_language_pack_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.download_status_, &from._impl_.download_status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.language_pack_url_length_) -
    reinterpret_cast<char*>(&_impl_.download_status_)) + sizeof(_impl_.language_pack_url_length_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.LanguagePackMsg)
}

inline void LanguagePackMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.check_code_){}
    , decltype(_impl_.language_pack_url_){}
    , decltype(_impl_.download_status_){0}
    , decltype(_impl_.download_and_install_schedu_){0}
    , decltype(_impl_.language_){0}
    , decltype(_impl_.check_code_length_){0}
    , decltype(_impl_.language_pack_url_length_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.check_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_pack_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_pack_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LanguagePackMsg::~LanguagePackMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.LanguagePackMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LanguagePackMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.check_code_.Destroy();
  _impl_.language_pack_url_.Destroy();
}

void LanguagePackMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LanguagePackMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.LanguagePackMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.check_code_.ClearToEmpty();
  _impl_.language_pack_url_.ClearToEmpty();
  ::memset(&_impl_.download_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.language_pack_url_length_) -
      reinterpret_cast<char*>(&_impl_.download_status_)) + sizeof(_impl_.language_pack_url_length_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LanguagePackMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .LSLAM.LanguagePackMsg.DownloadStatus download_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_download_status(static_cast<::LSLAM::LanguagePackMsg_DownloadStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 download_and_install_schedu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.download_and_install_schedu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.LanguagePackMsg.LanguageType language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_language(static_cast<::LSLAM::LanguagePackMsg_LanguageType>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 check_code_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.check_code_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string check_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_check_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.LanguagePackMsg.check_code"));
        } else
          goto handle_unusual;
        continue;
      // int32 language_pack_url_length = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.language_pack_url_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string language_pack_url = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_language_pack_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LSLAM.LanguagePackMsg.language_pack_url"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LanguagePackMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.LanguagePackMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .LSLAM.LanguagePackMsg.DownloadStatus download_status = 1;
  if (this->_internal_download_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_download_status(), target);
  }

  // int32 download_and_install_schedu = 2;
  if (this->_internal_download_and_install_schedu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_download_and_install_schedu(), target);
  }

  // .LSLAM.LanguagePackMsg.LanguageType language = 3;
  if (this->_internal_language() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_language(), target);
  }

  // int32 check_code_length = 4;
  if (this->_internal_check_code_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_check_code_length(), target);
  }

  // string check_code = 5;
  if (!this->_internal_check_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_code().data(), static_cast<int>(this->_internal_check_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.LanguagePackMsg.check_code");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_check_code(), target);
  }

  // int32 language_pack_url_length = 6;
  if (this->_internal_language_pack_url_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_language_pack_url_length(), target);
  }

  // string language_pack_url = 7;
  if (!this->_internal_language_pack_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_language_pack_url().data(), static_cast<int>(this->_internal_language_pack_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LSLAM.LanguagePackMsg.language_pack_url");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_language_pack_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.LanguagePackMsg)
  return target;
}

size_t LanguagePackMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.LanguagePackMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string check_code = 5;
  if (!this->_internal_check_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_code());
  }

  // string language_pack_url = 7;
  if (!this->_internal_language_pack_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language_pack_url());
  }

  // .LSLAM.LanguagePackMsg.DownloadStatus download_status = 1;
  if (this->_internal_download_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_download_status());
  }

  // int32 download_and_install_schedu = 2;
  if (this->_internal_download_and_install_schedu() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_download_and_install_schedu());
  }

  // .LSLAM.LanguagePackMsg.LanguageType language = 3;
  if (this->_internal_language() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_language());
  }

  // int32 check_code_length = 4;
  if (this->_internal_check_code_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_check_code_length());
  }

  // int32 language_pack_url_length = 6;
  if (this->_internal_language_pack_url_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_language_pack_url_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LanguagePackMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LanguagePackMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LanguagePackMsg::GetClassData() const { return &_class_data_; }


void LanguagePackMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LanguagePackMsg*>(&to_msg);
  auto& from = static_cast<const LanguagePackMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.LanguagePackMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_check_code().empty()) {
    _this->_internal_set_check_code(from._internal_check_code());
  }
  if (!from._internal_language_pack_url().empty()) {
    _this->_internal_set_language_pack_url(from._internal_language_pack_url());
  }
  if (from._internal_download_status() != 0) {
    _this->_internal_set_download_status(from._internal_download_status());
  }
  if (from._internal_download_and_install_schedu() != 0) {
    _this->_internal_set_download_and_install_schedu(from._internal_download_and_install_schedu());
  }
  if (from._internal_language() != 0) {
    _this->_internal_set_language(from._internal_language());
  }
  if (from._internal_check_code_length() != 0) {
    _this->_internal_set_check_code_length(from._internal_check_code_length());
  }
  if (from._internal_language_pack_url_length() != 0) {
    _this->_internal_set_language_pack_url_length(from._internal_language_pack_url_length());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LanguagePackMsg::CopyFrom(const LanguagePackMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.LanguagePackMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LanguagePackMsg::IsInitialized() const {
  return true;
}

void LanguagePackMsg::InternalSwap(LanguagePackMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.check_code_, lhs_arena,
      &other->_impl_.check_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_pack_url_, lhs_arena,
      &other->_impl_.language_pack_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LanguagePackMsg, _impl_.language_pack_url_length_)
      + sizeof(LanguagePackMsg::_impl_.language_pack_url_length_)
      - PROTOBUF_FIELD_OFFSET(LanguagePackMsg, _impl_.download_status_)>(
          reinterpret_cast<char*>(&_impl_.download_status_),
          reinterpret_cast<char*>(&other->_impl_.download_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LanguagePackMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[6]);
}

// ===================================================================

class TuyaDpMsg::_Internal {
 public:
  static const ::LSLAM::CleanDeviceMsg& clean_device_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::CleanRecordMsg& clean_record_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::DeviceMsg& device_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::RobotStatusMsg& robot_status_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::LanguagePackMsg& language_pack_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::TuyaSettingMsg& tuya_setting_msg(const TuyaDpMsg* msg);
  static const ::LSLAM::TuyaCommandMsg& tuya_command_msg(const TuyaDpMsg* msg);
};

const ::LSLAM::CleanDeviceMsg&
TuyaDpMsg::_Internal::clean_device_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.clean_device_msg_;
}
const ::LSLAM::CleanRecordMsg&
TuyaDpMsg::_Internal::clean_record_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.clean_record_msg_;
}
const ::LSLAM::DeviceMsg&
TuyaDpMsg::_Internal::device_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.device_msg_;
}
const ::LSLAM::RobotStatusMsg&
TuyaDpMsg::_Internal::robot_status_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.robot_status_msg_;
}
const ::LSLAM::LanguagePackMsg&
TuyaDpMsg::_Internal::language_pack_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.language_pack_msg_;
}
const ::LSLAM::TuyaSettingMsg&
TuyaDpMsg::_Internal::tuya_setting_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.tuya_setting_msg_;
}
const ::LSLAM::TuyaCommandMsg&
TuyaDpMsg::_Internal::tuya_command_msg(const TuyaDpMsg* msg) {
  return *msg->_impl_.tuya_command_msg_;
}
TuyaDpMsg::TuyaDpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LSLAM.TuyaDpMsg)
}
TuyaDpMsg::TuyaDpMsg(const TuyaDpMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TuyaDpMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.clean_device_msg_){nullptr}
    , decltype(_impl_.clean_record_msg_){nullptr}
    , decltype(_impl_.device_msg_){nullptr}
    , decltype(_impl_.robot_status_msg_){nullptr}
    , decltype(_impl_.language_pack_msg_){nullptr}
    , decltype(_impl_.tuya_setting_msg_){nullptr}
    , decltype(_impl_.tuya_command_msg_){nullptr}
    , decltype(_impl_.battery_percentage_){}
    , decltype(_impl_.command_or_setting_){}
    , decltype(_impl_.startup_mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_clean_device_msg()) {
    _this->_impl_.clean_device_msg_ = new ::LSLAM::CleanDeviceMsg(*from._impl_.clean_device_msg_);
  }
  if (from._internal_has_clean_record_msg()) {
    _this->_impl_.clean_record_msg_ = new ::LSLAM::CleanRecordMsg(*from._impl_.clean_record_msg_);
  }
  if (from._internal_has_device_msg()) {
    _this->_impl_.device_msg_ = new ::LSLAM::DeviceMsg(*from._impl_.device_msg_);
  }
  if (from._internal_has_robot_status_msg()) {
    _this->_impl_.robot_status_msg_ = new ::LSLAM::RobotStatusMsg(*from._impl_.robot_status_msg_);
  }
  if (from._internal_has_language_pack_msg()) {
    _this->_impl_.language_pack_msg_ = new ::LSLAM::LanguagePackMsg(*from._impl_.language_pack_msg_);
  }
  if (from._internal_has_tuya_setting_msg()) {
    _this->_impl_.tuya_setting_msg_ = new ::LSLAM::TuyaSettingMsg(*from._impl_.tuya_setting_msg_);
  }
  if (from._internal_has_tuya_command_msg()) {
    _this->_impl_.tuya_command_msg_ = new ::LSLAM::TuyaCommandMsg(*from._impl_.tuya_command_msg_);
  }
  ::memcpy(&_impl_.battery_percentage_, &from._impl_.battery_percentage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.startup_mode_) -
    reinterpret_cast<char*>(&_impl_.battery_percentage_)) + sizeof(_impl_.startup_mode_));
  // @@protoc_insertion_point(copy_constructor:LSLAM.TuyaDpMsg)
}

inline void TuyaDpMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.clean_device_msg_){nullptr}
    , decltype(_impl_.clean_record_msg_){nullptr}
    , decltype(_impl_.device_msg_){nullptr}
    , decltype(_impl_.robot_status_msg_){nullptr}
    , decltype(_impl_.language_pack_msg_){nullptr}
    , decltype(_impl_.tuya_setting_msg_){nullptr}
    , decltype(_impl_.tuya_command_msg_){nullptr}
    , decltype(_impl_.battery_percentage_){0}
    , decltype(_impl_.command_or_setting_){0}
    , decltype(_impl_.startup_mode_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TuyaDpMsg::~TuyaDpMsg() {
  // @@protoc_insertion_point(destructor:LSLAM.TuyaDpMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TuyaDpMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.clean_device_msg_;
  if (this != internal_default_instance()) delete _impl_.clean_record_msg_;
  if (this != internal_default_instance()) delete _impl_.device_msg_;
  if (this != internal_default_instance()) delete _impl_.robot_status_msg_;
  if (this != internal_default_instance()) delete _impl_.language_pack_msg_;
  if (this != internal_default_instance()) delete _impl_.tuya_setting_msg_;
  if (this != internal_default_instance()) delete _impl_.tuya_command_msg_;
}

void TuyaDpMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TuyaDpMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LSLAM.TuyaDpMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.clean_device_msg_ != nullptr) {
    delete _impl_.clean_device_msg_;
  }
  _impl_.clean_device_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.clean_record_msg_ != nullptr) {
    delete _impl_.clean_record_msg_;
  }
  _impl_.clean_record_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.device_msg_ != nullptr) {
    delete _impl_.device_msg_;
  }
  _impl_.device_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.robot_status_msg_ != nullptr) {
    delete _impl_.robot_status_msg_;
  }
  _impl_.robot_status_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.language_pack_msg_ != nullptr) {
    delete _impl_.language_pack_msg_;
  }
  _impl_.language_pack_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.tuya_setting_msg_ != nullptr) {
    delete _impl_.tuya_setting_msg_;
  }
  _impl_.tuya_setting_msg_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.tuya_command_msg_ != nullptr) {
    delete _impl_.tuya_command_msg_;
  }
  _impl_.tuya_command_msg_ = nullptr;
  ::memset(&_impl_.battery_percentage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.startup_mode_) -
      reinterpret_cast<char*>(&_impl_.battery_percentage_)) + sizeof(_impl_.startup_mode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TuyaDpMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .LSLAM.CleanDeviceMsg clean_device_msg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_clean_device_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.CleanRecordMsg clean_record_msg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_clean_record_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.DeviceMsg device_msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 battery_percentage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.battery_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.RobotStatusMsg robot_status_msg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot_status_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.LanguagePackMsg language_pack_msg = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_language_pack_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaSettingMsg tuya_setting_msg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuya_setting_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaCommandMsg tuya_command_msg = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_tuya_command_msg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 command_or_setting = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.command_or_setting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .LSLAM.TuyaStartupMode startup_mode = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_startup_mode(static_cast<::LSLAM::TuyaStartupMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TuyaDpMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LSLAM.TuyaDpMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .LSLAM.CleanDeviceMsg clean_device_msg = 1;
  if (this->_internal_has_clean_device_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::clean_device_msg(this),
        _Internal::clean_device_msg(this).GetCachedSize(), target, stream);
  }

  // .LSLAM.CleanRecordMsg clean_record_msg = 2;
  if (this->_internal_has_clean_record_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::clean_record_msg(this),
        _Internal::clean_record_msg(this).GetCachedSize(), target, stream);
  }

  // .LSLAM.DeviceMsg device_msg = 3;
  if (this->_internal_has_device_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::device_msg(this),
        _Internal::device_msg(this).GetCachedSize(), target, stream);
  }

  // int32 battery_percentage = 4;
  if (this->_internal_battery_percentage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_battery_percentage(), target);
  }

  // .LSLAM.RobotStatusMsg robot_status_msg = 5;
  if (this->_internal_has_robot_status_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::robot_status_msg(this),
        _Internal::robot_status_msg(this).GetCachedSize(), target, stream);
  }

  // .LSLAM.LanguagePackMsg language_pack_msg = 6;
  if (this->_internal_has_language_pack_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::language_pack_msg(this),
        _Internal::language_pack_msg(this).GetCachedSize(), target, stream);
  }

  // .LSLAM.TuyaSettingMsg tuya_setting_msg = 7;
  if (this->_internal_has_tuya_setting_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::tuya_setting_msg(this),
        _Internal::tuya_setting_msg(this).GetCachedSize(), target, stream);
  }

  // .LSLAM.TuyaCommandMsg tuya_command_msg = 8;
  if (this->_internal_has_tuya_command_msg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::tuya_command_msg(this),
        _Internal::tuya_command_msg(this).GetCachedSize(), target, stream);
  }

  // int32 command_or_setting = 9;
  if (this->_internal_command_or_setting() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_command_or_setting(), target);
  }

  // .LSLAM.TuyaStartupMode startup_mode = 10;
  if (this->_internal_startup_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_startup_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LSLAM.TuyaDpMsg)
  return target;
}

size_t TuyaDpMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LSLAM.TuyaDpMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .LSLAM.CleanDeviceMsg clean_device_msg = 1;
  if (this->_internal_has_clean_device_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clean_device_msg_);
  }

  // .LSLAM.CleanRecordMsg clean_record_msg = 2;
  if (this->_internal_has_clean_record_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.clean_record_msg_);
  }

  // .LSLAM.DeviceMsg device_msg = 3;
  if (this->_internal_has_device_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.device_msg_);
  }

  // .LSLAM.RobotStatusMsg robot_status_msg = 5;
  if (this->_internal_has_robot_status_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.robot_status_msg_);
  }

  // .LSLAM.LanguagePackMsg language_pack_msg = 6;
  if (this->_internal_has_language_pack_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.language_pack_msg_);
  }

  // .LSLAM.TuyaSettingMsg tuya_setting_msg = 7;
  if (this->_internal_has_tuya_setting_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuya_setting_msg_);
  }

  // .LSLAM.TuyaCommandMsg tuya_command_msg = 8;
  if (this->_internal_has_tuya_command_msg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tuya_command_msg_);
  }

  // int32 battery_percentage = 4;
  if (this->_internal_battery_percentage() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_battery_percentage());
  }

  // int32 command_or_setting = 9;
  if (this->_internal_command_or_setting() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_command_or_setting());
  }

  // .LSLAM.TuyaStartupMode startup_mode = 10;
  if (this->_internal_startup_mode() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_startup_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TuyaDpMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TuyaDpMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TuyaDpMsg::GetClassData() const { return &_class_data_; }


void TuyaDpMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TuyaDpMsg*>(&to_msg);
  auto& from = static_cast<const TuyaDpMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LSLAM.TuyaDpMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_clean_device_msg()) {
    _this->_internal_mutable_clean_device_msg()->::LSLAM::CleanDeviceMsg::MergeFrom(
        from._internal_clean_device_msg());
  }
  if (from._internal_has_clean_record_msg()) {
    _this->_internal_mutable_clean_record_msg()->::LSLAM::CleanRecordMsg::MergeFrom(
        from._internal_clean_record_msg());
  }
  if (from._internal_has_device_msg()) {
    _this->_internal_mutable_device_msg()->::LSLAM::DeviceMsg::MergeFrom(
        from._internal_device_msg());
  }
  if (from._internal_has_robot_status_msg()) {
    _this->_internal_mutable_robot_status_msg()->::LSLAM::RobotStatusMsg::MergeFrom(
        from._internal_robot_status_msg());
  }
  if (from._internal_has_language_pack_msg()) {
    _this->_internal_mutable_language_pack_msg()->::LSLAM::LanguagePackMsg::MergeFrom(
        from._internal_language_pack_msg());
  }
  if (from._internal_has_tuya_setting_msg()) {
    _this->_internal_mutable_tuya_setting_msg()->::LSLAM::TuyaSettingMsg::MergeFrom(
        from._internal_tuya_setting_msg());
  }
  if (from._internal_has_tuya_command_msg()) {
    _this->_internal_mutable_tuya_command_msg()->::LSLAM::TuyaCommandMsg::MergeFrom(
        from._internal_tuya_command_msg());
  }
  if (from._internal_battery_percentage() != 0) {
    _this->_internal_set_battery_percentage(from._internal_battery_percentage());
  }
  if (from._internal_command_or_setting() != 0) {
    _this->_internal_set_command_or_setting(from._internal_command_or_setting());
  }
  if (from._internal_startup_mode() != 0) {
    _this->_internal_set_startup_mode(from._internal_startup_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TuyaDpMsg::CopyFrom(const TuyaDpMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LSLAM.TuyaDpMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TuyaDpMsg::IsInitialized() const {
  return true;
}

void TuyaDpMsg::InternalSwap(TuyaDpMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TuyaDpMsg, _impl_.startup_mode_)
      + sizeof(TuyaDpMsg::_impl_.startup_mode_)
      - PROTOBUF_FIELD_OFFSET(TuyaDpMsg, _impl_.clean_device_msg_)>(
          reinterpret_cast<char*>(&_impl_.clean_device_msg_),
          reinterpret_cast<char*>(&other->_impl_.clean_device_msg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TuyaDpMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TuyaDpMessage_2eproto_getter, &descriptor_table_TuyaDpMessage_2eproto_once,
      file_level_metadata_TuyaDpMessage_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace LSLAM
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::LSLAM::TuyaCommandMsg*
Arena::CreateMaybeMessage< ::LSLAM::TuyaCommandMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::TuyaCommandMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::TuyaSettingMsg*
Arena::CreateMaybeMessage< ::LSLAM::TuyaSettingMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::TuyaSettingMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::RobotStatusMsg*
Arena::CreateMaybeMessage< ::LSLAM::RobotStatusMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::RobotStatusMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::DeviceMsg*
Arena::CreateMaybeMessage< ::LSLAM::DeviceMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::DeviceMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::CleanRecordMsg*
Arena::CreateMaybeMessage< ::LSLAM::CleanRecordMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::CleanRecordMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::CleanDeviceMsg*
Arena::CreateMaybeMessage< ::LSLAM::CleanDeviceMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::CleanDeviceMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::LanguagePackMsg*
Arena::CreateMaybeMessage< ::LSLAM::LanguagePackMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::LanguagePackMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::LSLAM::TuyaDpMsg*
Arena::CreateMaybeMessage< ::LSLAM::TuyaDpMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LSLAM::TuyaDpMsg >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
