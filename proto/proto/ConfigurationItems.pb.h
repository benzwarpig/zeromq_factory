// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ConfigurationItems.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ConfigurationItems_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ConfigurationItems_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Point.pb.h"
#include "MyOccupancyGrid.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ConfigurationItems_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ConfigurationItems_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ConfigurationItems_2eproto;
namespace LSLAM {
class ConfigurationItems;
struct ConfigurationItemsDefaultTypeInternal;
extern ConfigurationItemsDefaultTypeInternal _ConfigurationItems_default_instance_;
class ContinueCleanAtBreakPoint;
struct ContinueCleanAtBreakPointDefaultTypeInternal;
extern ContinueCleanAtBreakPointDefaultTypeInternal _ContinueCleanAtBreakPoint_default_instance_;
class DivisionLineInfo;
struct DivisionLineInfoDefaultTypeInternal;
extern DivisionLineInfoDefaultTypeInternal _DivisionLineInfo_default_instance_;
class MapInfo;
struct MapInfoDefaultTypeInternal;
extern MapInfoDefaultTypeInternal _MapInfo_default_instance_;
class MapInfoOfPrograms;
struct MapInfoOfProgramsDefaultTypeInternal;
extern MapInfoOfProgramsDefaultTypeInternal _MapInfoOfPrograms_default_instance_;
class VirtualWallInfo;
struct VirtualWallInfoDefaultTypeInternal;
extern VirtualWallInfoDefaultTypeInternal _VirtualWallInfo_default_instance_;
}  // namespace LSLAM
PROTOBUF_NAMESPACE_OPEN
template<> ::LSLAM::ConfigurationItems* Arena::CreateMaybeMessage<::LSLAM::ConfigurationItems>(Arena*);
template<> ::LSLAM::ContinueCleanAtBreakPoint* Arena::CreateMaybeMessage<::LSLAM::ContinueCleanAtBreakPoint>(Arena*);
template<> ::LSLAM::DivisionLineInfo* Arena::CreateMaybeMessage<::LSLAM::DivisionLineInfo>(Arena*);
template<> ::LSLAM::MapInfo* Arena::CreateMaybeMessage<::LSLAM::MapInfo>(Arena*);
template<> ::LSLAM::MapInfoOfPrograms* Arena::CreateMaybeMessage<::LSLAM::MapInfoOfPrograms>(Arena*);
template<> ::LSLAM::VirtualWallInfo* Arena::CreateMaybeMessage<::LSLAM::VirtualWallInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace LSLAM {

enum SaveAndReadOptions : int {
  LOCAL_LAYER_INFO = 0,
  CONTINUE_CLEAN_AT_BREAK_POINT_INFO = 1,
  COMPLETE_CLEAN = 2,
  ADJUSTED_ANGLE = 3,
  SaveAndReadOptions_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SaveAndReadOptions_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SaveAndReadOptions_IsValid(int value);
constexpr SaveAndReadOptions SaveAndReadOptions_MIN = LOCAL_LAYER_INFO;
constexpr SaveAndReadOptions SaveAndReadOptions_MAX = ADJUSTED_ANGLE;
constexpr int SaveAndReadOptions_ARRAYSIZE = SaveAndReadOptions_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SaveAndReadOptions_descriptor();
template<typename T>
inline const std::string& SaveAndReadOptions_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SaveAndReadOptions>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SaveAndReadOptions_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SaveAndReadOptions_descriptor(), enum_t_value);
}
inline bool SaveAndReadOptions_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SaveAndReadOptions* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaveAndReadOptions>(
    SaveAndReadOptions_descriptor(), name, value);
}
// ===================================================================

class ContinueCleanAtBreakPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.ContinueCleanAtBreakPoint) */ {
 public:
  inline ContinueCleanAtBreakPoint() : ContinueCleanAtBreakPoint(nullptr) {}
  ~ContinueCleanAtBreakPoint() override;
  explicit PROTOBUF_CONSTEXPR ContinueCleanAtBreakPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContinueCleanAtBreakPoint(const ContinueCleanAtBreakPoint& from);
  ContinueCleanAtBreakPoint(ContinueCleanAtBreakPoint&& from) noexcept
    : ContinueCleanAtBreakPoint() {
    *this = ::std::move(from);
  }

  inline ContinueCleanAtBreakPoint& operator=(const ContinueCleanAtBreakPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueCleanAtBreakPoint& operator=(ContinueCleanAtBreakPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueCleanAtBreakPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueCleanAtBreakPoint* internal_default_instance() {
    return reinterpret_cast<const ContinueCleanAtBreakPoint*>(
               &_ContinueCleanAtBreakPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ContinueCleanAtBreakPoint& a, ContinueCleanAtBreakPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueCleanAtBreakPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueCleanAtBreakPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueCleanAtBreakPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueCleanAtBreakPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContinueCleanAtBreakPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContinueCleanAtBreakPoint& from) {
    ContinueCleanAtBreakPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinueCleanAtBreakPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.ContinueCleanAtBreakPoint";
  }
  protected:
  explicit ContinueCleanAtBreakPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllCleanTasksFieldNumber = 2,
    kCleanedAreaIdFieldNumber = 3,
    kBreakPointFieldNumber = 6,
    kBreakPointAreaIdFieldNumber = 1,
    kMapIdFieldNumber = 4,
    kCleanAndMopStateFieldNumber = 5,
  };
  // repeated uint32 all_clean_tasks = 2;
  int all_clean_tasks_size() const;
  private:
  int _internal_all_clean_tasks_size() const;
  public:
  void clear_all_clean_tasks();
  private:
  uint32_t _internal_all_clean_tasks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_all_clean_tasks() const;
  void _internal_add_all_clean_tasks(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_all_clean_tasks();
  public:
  uint32_t all_clean_tasks(int index) const;
  void set_all_clean_tasks(int index, uint32_t value);
  void add_all_clean_tasks(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      all_clean_tasks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_all_clean_tasks();

  // repeated uint32 cleaned_area_id = 3;
  int cleaned_area_id_size() const;
  private:
  int _internal_cleaned_area_id_size() const;
  public:
  void clear_cleaned_area_id();
  private:
  uint32_t _internal_cleaned_area_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_cleaned_area_id() const;
  void _internal_add_cleaned_area_id(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_cleaned_area_id();
  public:
  uint32_t cleaned_area_id(int index) const;
  void set_cleaned_area_id(int index, uint32_t value);
  void add_cleaned_area_id(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      cleaned_area_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_cleaned_area_id();

  // .LSLAM.Point break_point = 6;
  bool has_break_point() const;
  private:
  bool _internal_has_break_point() const;
  public:
  void clear_break_point();
  const ::LSLAM::Point& break_point() const;
  PROTOBUF_NODISCARD ::LSLAM::Point* release_break_point();
  ::LSLAM::Point* mutable_break_point();
  void set_allocated_break_point(::LSLAM::Point* break_point);
  private:
  const ::LSLAM::Point& _internal_break_point() const;
  ::LSLAM::Point* _internal_mutable_break_point();
  public:
  void unsafe_arena_set_allocated_break_point(
      ::LSLAM::Point* break_point);
  ::LSLAM::Point* unsafe_arena_release_break_point();

  // uint32 break_point_area_id = 1;
  void clear_break_point_area_id();
  uint32_t break_point_area_id() const;
  void set_break_point_area_id(uint32_t value);
  private:
  uint32_t _internal_break_point_area_id() const;
  void _internal_set_break_point_area_id(uint32_t value);
  public:

  // uint32 map_id = 4;
  void clear_map_id();
  uint32_t map_id() const;
  void set_map_id(uint32_t value);
  private:
  uint32_t _internal_map_id() const;
  void _internal_set_map_id(uint32_t value);
  public:

  // uint32 clean_and_mop_state = 5;
  void clear_clean_and_mop_state();
  uint32_t clean_and_mop_state() const;
  void set_clean_and_mop_state(uint32_t value);
  private:
  uint32_t _internal_clean_and_mop_state() const;
  void _internal_set_clean_and_mop_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.ContinueCleanAtBreakPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > all_clean_tasks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _all_clean_tasks_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > cleaned_area_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cleaned_area_id_cached_byte_size_;
    ::LSLAM::Point* break_point_;
    uint32_t break_point_area_id_;
    uint32_t map_id_;
    uint32_t clean_and_mop_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// -------------------------------------------------------------------

class MapInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.MapInfo) */ {
 public:
  inline MapInfo() : MapInfo(nullptr) {}
  ~MapInfo() override;
  explicit PROTOBUF_CONSTEXPR MapInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapInfo(const MapInfo& from);
  MapInfo(MapInfo&& from) noexcept
    : MapInfo() {
    *this = ::std::move(from);
  }

  inline MapInfo& operator=(const MapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInfo& operator=(MapInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapInfo* internal_default_instance() {
    return reinterpret_cast<const MapInfo*>(
               &_MapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MapInfo& a, MapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapInfo& from) {
    MapInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.MapInfo";
  }
  protected:
  explicit MapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapDataFieldNumber = 5,
    kSavedOriginXFieldNumber = 1,
    kSavedOriginYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // repeated int32 map_data = 5;
  int map_data_size() const;
  private:
  int _internal_map_data_size() const;
  public:
  void clear_map_data();
  private:
  int32_t _internal_map_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_map_data() const;
  void _internal_add_map_data(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_map_data();
  public:
  int32_t map_data(int index) const;
  void set_map_data(int index, int32_t value);
  void add_map_data(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      map_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_map_data();

  // double saved_origin_x = 1;
  void clear_saved_origin_x();
  double saved_origin_x() const;
  void set_saved_origin_x(double value);
  private:
  double _internal_saved_origin_x() const;
  void _internal_set_saved_origin_x(double value);
  public:

  // double saved_origin_y = 2;
  void clear_saved_origin_y();
  double saved_origin_y() const;
  void set_saved_origin_y(double value);
  private:
  double _internal_saved_origin_y() const;
  void _internal_set_saved_origin_y(double value);
  public:

  // uint32 width = 3;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 4;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.MapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > map_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _map_data_cached_byte_size_;
    double saved_origin_x_;
    double saved_origin_y_;
    uint32_t width_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// -------------------------------------------------------------------

class DivisionLineInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.DivisionLineInfo) */ {
 public:
  inline DivisionLineInfo() : DivisionLineInfo(nullptr) {}
  ~DivisionLineInfo() override;
  explicit PROTOBUF_CONSTEXPR DivisionLineInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DivisionLineInfo(const DivisionLineInfo& from);
  DivisionLineInfo(DivisionLineInfo&& from) noexcept
    : DivisionLineInfo() {
    *this = ::std::move(from);
  }

  inline DivisionLineInfo& operator=(const DivisionLineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DivisionLineInfo& operator=(DivisionLineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DivisionLineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DivisionLineInfo* internal_default_instance() {
    return reinterpret_cast<const DivisionLineInfo*>(
               &_DivisionLineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DivisionLineInfo& a, DivisionLineInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DivisionLineInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DivisionLineInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DivisionLineInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DivisionLineInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DivisionLineInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DivisionLineInfo& from) {
    DivisionLineInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DivisionLineInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.DivisionLineInfo";
  }
  protected:
  explicit DivisionLineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDivisionLinesLengthFieldNumber = 1,
    kDivisionLinesPointFieldNumber = 2,
  };
  // repeated int32 division_lines_length = 1;
  int division_lines_length_size() const;
  private:
  int _internal_division_lines_length_size() const;
  public:
  void clear_division_lines_length();
  private:
  int32_t _internal_division_lines_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_division_lines_length() const;
  void _internal_add_division_lines_length(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_division_lines_length();
  public:
  int32_t division_lines_length(int index) const;
  void set_division_lines_length(int index, int32_t value);
  void add_division_lines_length(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      division_lines_length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_division_lines_length();

  // repeated .LSLAM.Point division_lines_point = 2;
  int division_lines_point_size() const;
  private:
  int _internal_division_lines_point_size() const;
  public:
  void clear_division_lines_point();
  ::LSLAM::Point* mutable_division_lines_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >*
      mutable_division_lines_point();
  private:
  const ::LSLAM::Point& _internal_division_lines_point(int index) const;
  ::LSLAM::Point* _internal_add_division_lines_point();
  public:
  const ::LSLAM::Point& division_lines_point(int index) const;
  ::LSLAM::Point* add_division_lines_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >&
      division_lines_point() const;

  // @@protoc_insertion_point(class_scope:LSLAM.DivisionLineInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > division_lines_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _division_lines_length_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point > division_lines_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// -------------------------------------------------------------------

class VirtualWallInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.VirtualWallInfo) */ {
 public:
  inline VirtualWallInfo() : VirtualWallInfo(nullptr) {}
  ~VirtualWallInfo() override;
  explicit PROTOBUF_CONSTEXPR VirtualWallInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualWallInfo(const VirtualWallInfo& from);
  VirtualWallInfo(VirtualWallInfo&& from) noexcept
    : VirtualWallInfo() {
    *this = ::std::move(from);
  }

  inline VirtualWallInfo& operator=(const VirtualWallInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualWallInfo& operator=(VirtualWallInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualWallInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualWallInfo* internal_default_instance() {
    return reinterpret_cast<const VirtualWallInfo*>(
               &_VirtualWallInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VirtualWallInfo& a, VirtualWallInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualWallInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualWallInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VirtualWallInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VirtualWallInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualWallInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VirtualWallInfo& from) {
    VirtualWallInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualWallInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.VirtualWallInfo";
  }
  protected:
  explicit VirtualWallInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualWallsLengthFieldNumber = 1,
    kVirtualWallsPointFieldNumber = 2,
  };
  // repeated int32 virtual_walls_length = 1;
  int virtual_walls_length_size() const;
  private:
  int _internal_virtual_walls_length_size() const;
  public:
  void clear_virtual_walls_length();
  private:
  int32_t _internal_virtual_walls_length(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_virtual_walls_length() const;
  void _internal_add_virtual_walls_length(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_virtual_walls_length();
  public:
  int32_t virtual_walls_length(int index) const;
  void set_virtual_walls_length(int index, int32_t value);
  void add_virtual_walls_length(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      virtual_walls_length() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_virtual_walls_length();

  // repeated .LSLAM.Point virtual_walls_point = 2;
  int virtual_walls_point_size() const;
  private:
  int _internal_virtual_walls_point_size() const;
  public:
  void clear_virtual_walls_point();
  ::LSLAM::Point* mutable_virtual_walls_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >*
      mutable_virtual_walls_point();
  private:
  const ::LSLAM::Point& _internal_virtual_walls_point(int index) const;
  ::LSLAM::Point* _internal_add_virtual_walls_point();
  public:
  const ::LSLAM::Point& virtual_walls_point(int index) const;
  ::LSLAM::Point* add_virtual_walls_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >&
      virtual_walls_point() const;

  // @@protoc_insertion_point(class_scope:LSLAM.VirtualWallInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > virtual_walls_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _virtual_walls_length_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point > virtual_walls_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// -------------------------------------------------------------------

class ConfigurationItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.ConfigurationItems) */ {
 public:
  inline ConfigurationItems() : ConfigurationItems(nullptr) {}
  ~ConfigurationItems() override;
  explicit PROTOBUF_CONSTEXPR ConfigurationItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigurationItems(const ConfigurationItems& from);
  ConfigurationItems(ConfigurationItems&& from) noexcept
    : ConfigurationItems() {
    *this = ::std::move(from);
  }

  inline ConfigurationItems& operator=(const ConfigurationItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigurationItems& operator=(ConfigurationItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigurationItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigurationItems* internal_default_instance() {
    return reinterpret_cast<const ConfigurationItems*>(
               &_ConfigurationItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigurationItems& a, ConfigurationItems& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigurationItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigurationItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigurationItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigurationItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigurationItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigurationItems& from) {
    ConfigurationItems::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigurationItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.ConfigurationItems";
  }
  protected:
  explicit ConfigurationItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalLayerInfoFieldNumber = 1,
    kContinueCleanAtBreakPointInfoFieldNumber = 2,
    kCompleteCleanFieldNumber = 3,
    kIsAdjustedAngleFieldNumber = 4,
  };
  // .LSLAM.MapInfo local_layer_info = 1;
  bool has_local_layer_info() const;
  private:
  bool _internal_has_local_layer_info() const;
  public:
  void clear_local_layer_info();
  const ::LSLAM::MapInfo& local_layer_info() const;
  PROTOBUF_NODISCARD ::LSLAM::MapInfo* release_local_layer_info();
  ::LSLAM::MapInfo* mutable_local_layer_info();
  void set_allocated_local_layer_info(::LSLAM::MapInfo* local_layer_info);
  private:
  const ::LSLAM::MapInfo& _internal_local_layer_info() const;
  ::LSLAM::MapInfo* _internal_mutable_local_layer_info();
  public:
  void unsafe_arena_set_allocated_local_layer_info(
      ::LSLAM::MapInfo* local_layer_info);
  ::LSLAM::MapInfo* unsafe_arena_release_local_layer_info();

  // .LSLAM.ContinueCleanAtBreakPoint continue_clean_at_break_point_info = 2;
  bool has_continue_clean_at_break_point_info() const;
  private:
  bool _internal_has_continue_clean_at_break_point_info() const;
  public:
  void clear_continue_clean_at_break_point_info();
  const ::LSLAM::ContinueCleanAtBreakPoint& continue_clean_at_break_point_info() const;
  PROTOBUF_NODISCARD ::LSLAM::ContinueCleanAtBreakPoint* release_continue_clean_at_break_point_info();
  ::LSLAM::ContinueCleanAtBreakPoint* mutable_continue_clean_at_break_point_info();
  void set_allocated_continue_clean_at_break_point_info(::LSLAM::ContinueCleanAtBreakPoint* continue_clean_at_break_point_info);
  private:
  const ::LSLAM::ContinueCleanAtBreakPoint& _internal_continue_clean_at_break_point_info() const;
  ::LSLAM::ContinueCleanAtBreakPoint* _internal_mutable_continue_clean_at_break_point_info();
  public:
  void unsafe_arena_set_allocated_continue_clean_at_break_point_info(
      ::LSLAM::ContinueCleanAtBreakPoint* continue_clean_at_break_point_info);
  ::LSLAM::ContinueCleanAtBreakPoint* unsafe_arena_release_continue_clean_at_break_point_info();

  // bool complete_clean = 3;
  void clear_complete_clean();
  bool complete_clean() const;
  void set_complete_clean(bool value);
  private:
  bool _internal_complete_clean() const;
  void _internal_set_complete_clean(bool value);
  public:

  // bool is_adjusted_angle = 4;
  void clear_is_adjusted_angle();
  bool is_adjusted_angle() const;
  void set_is_adjusted_angle(bool value);
  private:
  bool _internal_is_adjusted_angle() const;
  void _internal_set_is_adjusted_angle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.ConfigurationItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::LSLAM::MapInfo* local_layer_info_;
    ::LSLAM::ContinueCleanAtBreakPoint* continue_clean_at_break_point_info_;
    bool complete_clean_;
    bool is_adjusted_angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// -------------------------------------------------------------------

class MapInfoOfPrograms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LSLAM.MapInfoOfPrograms) */ {
 public:
  inline MapInfoOfPrograms() : MapInfoOfPrograms(nullptr) {}
  ~MapInfoOfPrograms() override;
  explicit PROTOBUF_CONSTEXPR MapInfoOfPrograms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapInfoOfPrograms(const MapInfoOfPrograms& from);
  MapInfoOfPrograms(MapInfoOfPrograms&& from) noexcept
    : MapInfoOfPrograms() {
    *this = ::std::move(from);
  }

  inline MapInfoOfPrograms& operator=(const MapInfoOfPrograms& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapInfoOfPrograms& operator=(MapInfoOfPrograms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapInfoOfPrograms& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapInfoOfPrograms* internal_default_instance() {
    return reinterpret_cast<const MapInfoOfPrograms*>(
               &_MapInfoOfPrograms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MapInfoOfPrograms& a, MapInfoOfPrograms& b) {
    a.Swap(&b);
  }
  inline void Swap(MapInfoOfPrograms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapInfoOfPrograms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapInfoOfPrograms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapInfoOfPrograms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapInfoOfPrograms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MapInfoOfPrograms& from) {
    MapInfoOfPrograms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapInfoOfPrograms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LSLAM.MapInfoOfPrograms";
  }
  protected:
  explicit MapInfoOfPrograms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsCleanWayFieldNumber = 7,
    kPbStreamFileNameFieldNumber = 3,
    kSegmentMapFieldNumber = 2,
    kDivisionLineInfoFieldNumber = 5,
    kVirtualWallInfoFieldNumber = 6,
    kMapRotationAngleFieldNumber = 4,
    kMapIdFieldNumber = 1,
  };
  // repeated uint32 rooms_clean_way = 7;
  int rooms_clean_way_size() const;
  private:
  int _internal_rooms_clean_way_size() const;
  public:
  void clear_rooms_clean_way();
  private:
  uint32_t _internal_rooms_clean_way(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_rooms_clean_way() const;
  void _internal_add_rooms_clean_way(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_rooms_clean_way();
  public:
  uint32_t rooms_clean_way(int index) const;
  void set_rooms_clean_way(int index, uint32_t value);
  void add_rooms_clean_way(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      rooms_clean_way() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_rooms_clean_way();

  // bytes pbStream_file_name = 3;
  void clear_pbstream_file_name();
  const std::string& pbstream_file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pbstream_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pbstream_file_name();
  PROTOBUF_NODISCARD std::string* release_pbstream_file_name();
  void set_allocated_pbstream_file_name(std::string* pbstream_file_name);
  private:
  const std::string& _internal_pbstream_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pbstream_file_name(const std::string& value);
  std::string* _internal_mutable_pbstream_file_name();
  public:

  // .LSLAM.MyOccupancyGrid segment_map = 2;
  bool has_segment_map() const;
  private:
  bool _internal_has_segment_map() const;
  public:
  void clear_segment_map();
  const ::LSLAM::MyOccupancyGrid& segment_map() const;
  PROTOBUF_NODISCARD ::LSLAM::MyOccupancyGrid* release_segment_map();
  ::LSLAM::MyOccupancyGrid* mutable_segment_map();
  void set_allocated_segment_map(::LSLAM::MyOccupancyGrid* segment_map);
  private:
  const ::LSLAM::MyOccupancyGrid& _internal_segment_map() const;
  ::LSLAM::MyOccupancyGrid* _internal_mutable_segment_map();
  public:
  void unsafe_arena_set_allocated_segment_map(
      ::LSLAM::MyOccupancyGrid* segment_map);
  ::LSLAM::MyOccupancyGrid* unsafe_arena_release_segment_map();

  // .LSLAM.DivisionLineInfo division_line_info = 5;
  bool has_division_line_info() const;
  private:
  bool _internal_has_division_line_info() const;
  public:
  void clear_division_line_info();
  const ::LSLAM::DivisionLineInfo& division_line_info() const;
  PROTOBUF_NODISCARD ::LSLAM::DivisionLineInfo* release_division_line_info();
  ::LSLAM::DivisionLineInfo* mutable_division_line_info();
  void set_allocated_division_line_info(::LSLAM::DivisionLineInfo* division_line_info);
  private:
  const ::LSLAM::DivisionLineInfo& _internal_division_line_info() const;
  ::LSLAM::DivisionLineInfo* _internal_mutable_division_line_info();
  public:
  void unsafe_arena_set_allocated_division_line_info(
      ::LSLAM::DivisionLineInfo* division_line_info);
  ::LSLAM::DivisionLineInfo* unsafe_arena_release_division_line_info();

  // .LSLAM.VirtualWallInfo virtual_wall_info = 6;
  bool has_virtual_wall_info() const;
  private:
  bool _internal_has_virtual_wall_info() const;
  public:
  void clear_virtual_wall_info();
  const ::LSLAM::VirtualWallInfo& virtual_wall_info() const;
  PROTOBUF_NODISCARD ::LSLAM::VirtualWallInfo* release_virtual_wall_info();
  ::LSLAM::VirtualWallInfo* mutable_virtual_wall_info();
  void set_allocated_virtual_wall_info(::LSLAM::VirtualWallInfo* virtual_wall_info);
  private:
  const ::LSLAM::VirtualWallInfo& _internal_virtual_wall_info() const;
  ::LSLAM::VirtualWallInfo* _internal_mutable_virtual_wall_info();
  public:
  void unsafe_arena_set_allocated_virtual_wall_info(
      ::LSLAM::VirtualWallInfo* virtual_wall_info);
  ::LSLAM::VirtualWallInfo* unsafe_arena_release_virtual_wall_info();

  // double map_rotation_angle = 4;
  void clear_map_rotation_angle();
  double map_rotation_angle() const;
  void set_map_rotation_angle(double value);
  private:
  double _internal_map_rotation_angle() const;
  void _internal_set_map_rotation_angle(double value);
  public:

  // int32 map_id = 1;
  void clear_map_id();
  int32_t map_id() const;
  void set_map_id(int32_t value);
  private:
  int32_t _internal_map_id() const;
  void _internal_set_map_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LSLAM.MapInfoOfPrograms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > rooms_clean_way_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _rooms_clean_way_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pbstream_file_name_;
    ::LSLAM::MyOccupancyGrid* segment_map_;
    ::LSLAM::DivisionLineInfo* division_line_info_;
    ::LSLAM::VirtualWallInfo* virtual_wall_info_;
    double map_rotation_angle_;
    int32_t map_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ConfigurationItems_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ContinueCleanAtBreakPoint

// uint32 break_point_area_id = 1;
inline void ContinueCleanAtBreakPoint::clear_break_point_area_id() {
  _impl_.break_point_area_id_ = 0u;
}
inline uint32_t ContinueCleanAtBreakPoint::_internal_break_point_area_id() const {
  return _impl_.break_point_area_id_;
}
inline uint32_t ContinueCleanAtBreakPoint::break_point_area_id() const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.break_point_area_id)
  return _internal_break_point_area_id();
}
inline void ContinueCleanAtBreakPoint::_internal_set_break_point_area_id(uint32_t value) {
  
  _impl_.break_point_area_id_ = value;
}
inline void ContinueCleanAtBreakPoint::set_break_point_area_id(uint32_t value) {
  _internal_set_break_point_area_id(value);
  // @@protoc_insertion_point(field_set:LSLAM.ContinueCleanAtBreakPoint.break_point_area_id)
}

// repeated uint32 all_clean_tasks = 2;
inline int ContinueCleanAtBreakPoint::_internal_all_clean_tasks_size() const {
  return _impl_.all_clean_tasks_.size();
}
inline int ContinueCleanAtBreakPoint::all_clean_tasks_size() const {
  return _internal_all_clean_tasks_size();
}
inline void ContinueCleanAtBreakPoint::clear_all_clean_tasks() {
  _impl_.all_clean_tasks_.Clear();
}
inline uint32_t ContinueCleanAtBreakPoint::_internal_all_clean_tasks(int index) const {
  return _impl_.all_clean_tasks_.Get(index);
}
inline uint32_t ContinueCleanAtBreakPoint::all_clean_tasks(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.all_clean_tasks)
  return _internal_all_clean_tasks(index);
}
inline void ContinueCleanAtBreakPoint::set_all_clean_tasks(int index, uint32_t value) {
  _impl_.all_clean_tasks_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.ContinueCleanAtBreakPoint.all_clean_tasks)
}
inline void ContinueCleanAtBreakPoint::_internal_add_all_clean_tasks(uint32_t value) {
  _impl_.all_clean_tasks_.Add(value);
}
inline void ContinueCleanAtBreakPoint::add_all_clean_tasks(uint32_t value) {
  _internal_add_all_clean_tasks(value);
  // @@protoc_insertion_point(field_add:LSLAM.ContinueCleanAtBreakPoint.all_clean_tasks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ContinueCleanAtBreakPoint::_internal_all_clean_tasks() const {
  return _impl_.all_clean_tasks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ContinueCleanAtBreakPoint::all_clean_tasks() const {
  // @@protoc_insertion_point(field_list:LSLAM.ContinueCleanAtBreakPoint.all_clean_tasks)
  return _internal_all_clean_tasks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ContinueCleanAtBreakPoint::_internal_mutable_all_clean_tasks() {
  return &_impl_.all_clean_tasks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ContinueCleanAtBreakPoint::mutable_all_clean_tasks() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.ContinueCleanAtBreakPoint.all_clean_tasks)
  return _internal_mutable_all_clean_tasks();
}

// repeated uint32 cleaned_area_id = 3;
inline int ContinueCleanAtBreakPoint::_internal_cleaned_area_id_size() const {
  return _impl_.cleaned_area_id_.size();
}
inline int ContinueCleanAtBreakPoint::cleaned_area_id_size() const {
  return _internal_cleaned_area_id_size();
}
inline void ContinueCleanAtBreakPoint::clear_cleaned_area_id() {
  _impl_.cleaned_area_id_.Clear();
}
inline uint32_t ContinueCleanAtBreakPoint::_internal_cleaned_area_id(int index) const {
  return _impl_.cleaned_area_id_.Get(index);
}
inline uint32_t ContinueCleanAtBreakPoint::cleaned_area_id(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.cleaned_area_id)
  return _internal_cleaned_area_id(index);
}
inline void ContinueCleanAtBreakPoint::set_cleaned_area_id(int index, uint32_t value) {
  _impl_.cleaned_area_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.ContinueCleanAtBreakPoint.cleaned_area_id)
}
inline void ContinueCleanAtBreakPoint::_internal_add_cleaned_area_id(uint32_t value) {
  _impl_.cleaned_area_id_.Add(value);
}
inline void ContinueCleanAtBreakPoint::add_cleaned_area_id(uint32_t value) {
  _internal_add_cleaned_area_id(value);
  // @@protoc_insertion_point(field_add:LSLAM.ContinueCleanAtBreakPoint.cleaned_area_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ContinueCleanAtBreakPoint::_internal_cleaned_area_id() const {
  return _impl_.cleaned_area_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ContinueCleanAtBreakPoint::cleaned_area_id() const {
  // @@protoc_insertion_point(field_list:LSLAM.ContinueCleanAtBreakPoint.cleaned_area_id)
  return _internal_cleaned_area_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ContinueCleanAtBreakPoint::_internal_mutable_cleaned_area_id() {
  return &_impl_.cleaned_area_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ContinueCleanAtBreakPoint::mutable_cleaned_area_id() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.ContinueCleanAtBreakPoint.cleaned_area_id)
  return _internal_mutable_cleaned_area_id();
}

// uint32 map_id = 4;
inline void ContinueCleanAtBreakPoint::clear_map_id() {
  _impl_.map_id_ = 0u;
}
inline uint32_t ContinueCleanAtBreakPoint::_internal_map_id() const {
  return _impl_.map_id_;
}
inline uint32_t ContinueCleanAtBreakPoint::map_id() const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.map_id)
  return _internal_map_id();
}
inline void ContinueCleanAtBreakPoint::_internal_set_map_id(uint32_t value) {
  
  _impl_.map_id_ = value;
}
inline void ContinueCleanAtBreakPoint::set_map_id(uint32_t value) {
  _internal_set_map_id(value);
  // @@protoc_insertion_point(field_set:LSLAM.ContinueCleanAtBreakPoint.map_id)
}

// uint32 clean_and_mop_state = 5;
inline void ContinueCleanAtBreakPoint::clear_clean_and_mop_state() {
  _impl_.clean_and_mop_state_ = 0u;
}
inline uint32_t ContinueCleanAtBreakPoint::_internal_clean_and_mop_state() const {
  return _impl_.clean_and_mop_state_;
}
inline uint32_t ContinueCleanAtBreakPoint::clean_and_mop_state() const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.clean_and_mop_state)
  return _internal_clean_and_mop_state();
}
inline void ContinueCleanAtBreakPoint::_internal_set_clean_and_mop_state(uint32_t value) {
  
  _impl_.clean_and_mop_state_ = value;
}
inline void ContinueCleanAtBreakPoint::set_clean_and_mop_state(uint32_t value) {
  _internal_set_clean_and_mop_state(value);
  // @@protoc_insertion_point(field_set:LSLAM.ContinueCleanAtBreakPoint.clean_and_mop_state)
}

// .LSLAM.Point break_point = 6;
inline bool ContinueCleanAtBreakPoint::_internal_has_break_point() const {
  return this != internal_default_instance() && _impl_.break_point_ != nullptr;
}
inline bool ContinueCleanAtBreakPoint::has_break_point() const {
  return _internal_has_break_point();
}
inline const ::LSLAM::Point& ContinueCleanAtBreakPoint::_internal_break_point() const {
  const ::LSLAM::Point* p = _impl_.break_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::Point&>(
      ::LSLAM::_Point_default_instance_);
}
inline const ::LSLAM::Point& ContinueCleanAtBreakPoint::break_point() const {
  // @@protoc_insertion_point(field_get:LSLAM.ContinueCleanAtBreakPoint.break_point)
  return _internal_break_point();
}
inline void ContinueCleanAtBreakPoint::unsafe_arena_set_allocated_break_point(
    ::LSLAM::Point* break_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.break_point_);
  }
  _impl_.break_point_ = break_point;
  if (break_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.ContinueCleanAtBreakPoint.break_point)
}
inline ::LSLAM::Point* ContinueCleanAtBreakPoint::release_break_point() {
  
  ::LSLAM::Point* temp = _impl_.break_point_;
  _impl_.break_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::Point* ContinueCleanAtBreakPoint::unsafe_arena_release_break_point() {
  // @@protoc_insertion_point(field_release:LSLAM.ContinueCleanAtBreakPoint.break_point)
  
  ::LSLAM::Point* temp = _impl_.break_point_;
  _impl_.break_point_ = nullptr;
  return temp;
}
inline ::LSLAM::Point* ContinueCleanAtBreakPoint::_internal_mutable_break_point() {
  
  if (_impl_.break_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::Point>(GetArenaForAllocation());
    _impl_.break_point_ = p;
  }
  return _impl_.break_point_;
}
inline ::LSLAM::Point* ContinueCleanAtBreakPoint::mutable_break_point() {
  ::LSLAM::Point* _msg = _internal_mutable_break_point();
  // @@protoc_insertion_point(field_mutable:LSLAM.ContinueCleanAtBreakPoint.break_point)
  return _msg;
}
inline void ContinueCleanAtBreakPoint::set_allocated_break_point(::LSLAM::Point* break_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.break_point_);
  }
  if (break_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(break_point));
    if (message_arena != submessage_arena) {
      break_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, break_point, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.break_point_ = break_point;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.ContinueCleanAtBreakPoint.break_point)
}

// -------------------------------------------------------------------

// MapInfo

// double saved_origin_x = 1;
inline void MapInfo::clear_saved_origin_x() {
  _impl_.saved_origin_x_ = 0;
}
inline double MapInfo::_internal_saved_origin_x() const {
  return _impl_.saved_origin_x_;
}
inline double MapInfo::saved_origin_x() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfo.saved_origin_x)
  return _internal_saved_origin_x();
}
inline void MapInfo::_internal_set_saved_origin_x(double value) {
  
  _impl_.saved_origin_x_ = value;
}
inline void MapInfo::set_saved_origin_x(double value) {
  _internal_set_saved_origin_x(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfo.saved_origin_x)
}

// double saved_origin_y = 2;
inline void MapInfo::clear_saved_origin_y() {
  _impl_.saved_origin_y_ = 0;
}
inline double MapInfo::_internal_saved_origin_y() const {
  return _impl_.saved_origin_y_;
}
inline double MapInfo::saved_origin_y() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfo.saved_origin_y)
  return _internal_saved_origin_y();
}
inline void MapInfo::_internal_set_saved_origin_y(double value) {
  
  _impl_.saved_origin_y_ = value;
}
inline void MapInfo::set_saved_origin_y(double value) {
  _internal_set_saved_origin_y(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfo.saved_origin_y)
}

// uint32 width = 3;
inline void MapInfo::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t MapInfo::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t MapInfo::width() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfo.width)
  return _internal_width();
}
inline void MapInfo::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void MapInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfo.width)
}

// uint32 height = 4;
inline void MapInfo::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t MapInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t MapInfo::height() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfo.height)
  return _internal_height();
}
inline void MapInfo::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void MapInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfo.height)
}

// repeated int32 map_data = 5;
inline int MapInfo::_internal_map_data_size() const {
  return _impl_.map_data_.size();
}
inline int MapInfo::map_data_size() const {
  return _internal_map_data_size();
}
inline void MapInfo::clear_map_data() {
  _impl_.map_data_.Clear();
}
inline int32_t MapInfo::_internal_map_data(int index) const {
  return _impl_.map_data_.Get(index);
}
inline int32_t MapInfo::map_data(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfo.map_data)
  return _internal_map_data(index);
}
inline void MapInfo::set_map_data(int index, int32_t value) {
  _impl_.map_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfo.map_data)
}
inline void MapInfo::_internal_add_map_data(int32_t value) {
  _impl_.map_data_.Add(value);
}
inline void MapInfo::add_map_data(int32_t value) {
  _internal_add_map_data(value);
  // @@protoc_insertion_point(field_add:LSLAM.MapInfo.map_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MapInfo::_internal_map_data() const {
  return _impl_.map_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MapInfo::map_data() const {
  // @@protoc_insertion_point(field_list:LSLAM.MapInfo.map_data)
  return _internal_map_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MapInfo::_internal_mutable_map_data() {
  return &_impl_.map_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MapInfo::mutable_map_data() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.MapInfo.map_data)
  return _internal_mutable_map_data();
}

// -------------------------------------------------------------------

// DivisionLineInfo

// repeated int32 division_lines_length = 1;
inline int DivisionLineInfo::_internal_division_lines_length_size() const {
  return _impl_.division_lines_length_.size();
}
inline int DivisionLineInfo::division_lines_length_size() const {
  return _internal_division_lines_length_size();
}
inline void DivisionLineInfo::clear_division_lines_length() {
  _impl_.division_lines_length_.Clear();
}
inline int32_t DivisionLineInfo::_internal_division_lines_length(int index) const {
  return _impl_.division_lines_length_.Get(index);
}
inline int32_t DivisionLineInfo::division_lines_length(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.DivisionLineInfo.division_lines_length)
  return _internal_division_lines_length(index);
}
inline void DivisionLineInfo::set_division_lines_length(int index, int32_t value) {
  _impl_.division_lines_length_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.DivisionLineInfo.division_lines_length)
}
inline void DivisionLineInfo::_internal_add_division_lines_length(int32_t value) {
  _impl_.division_lines_length_.Add(value);
}
inline void DivisionLineInfo::add_division_lines_length(int32_t value) {
  _internal_add_division_lines_length(value);
  // @@protoc_insertion_point(field_add:LSLAM.DivisionLineInfo.division_lines_length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DivisionLineInfo::_internal_division_lines_length() const {
  return _impl_.division_lines_length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DivisionLineInfo::division_lines_length() const {
  // @@protoc_insertion_point(field_list:LSLAM.DivisionLineInfo.division_lines_length)
  return _internal_division_lines_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DivisionLineInfo::_internal_mutable_division_lines_length() {
  return &_impl_.division_lines_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DivisionLineInfo::mutable_division_lines_length() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.DivisionLineInfo.division_lines_length)
  return _internal_mutable_division_lines_length();
}

// repeated .LSLAM.Point division_lines_point = 2;
inline int DivisionLineInfo::_internal_division_lines_point_size() const {
  return _impl_.division_lines_point_.size();
}
inline int DivisionLineInfo::division_lines_point_size() const {
  return _internal_division_lines_point_size();
}
inline ::LSLAM::Point* DivisionLineInfo::mutable_division_lines_point(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.DivisionLineInfo.division_lines_point)
  return _impl_.division_lines_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >*
DivisionLineInfo::mutable_division_lines_point() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.DivisionLineInfo.division_lines_point)
  return &_impl_.division_lines_point_;
}
inline const ::LSLAM::Point& DivisionLineInfo::_internal_division_lines_point(int index) const {
  return _impl_.division_lines_point_.Get(index);
}
inline const ::LSLAM::Point& DivisionLineInfo::division_lines_point(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.DivisionLineInfo.division_lines_point)
  return _internal_division_lines_point(index);
}
inline ::LSLAM::Point* DivisionLineInfo::_internal_add_division_lines_point() {
  return _impl_.division_lines_point_.Add();
}
inline ::LSLAM::Point* DivisionLineInfo::add_division_lines_point() {
  ::LSLAM::Point* _add = _internal_add_division_lines_point();
  // @@protoc_insertion_point(field_add:LSLAM.DivisionLineInfo.division_lines_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >&
DivisionLineInfo::division_lines_point() const {
  // @@protoc_insertion_point(field_list:LSLAM.DivisionLineInfo.division_lines_point)
  return _impl_.division_lines_point_;
}

// -------------------------------------------------------------------

// VirtualWallInfo

// repeated int32 virtual_walls_length = 1;
inline int VirtualWallInfo::_internal_virtual_walls_length_size() const {
  return _impl_.virtual_walls_length_.size();
}
inline int VirtualWallInfo::virtual_walls_length_size() const {
  return _internal_virtual_walls_length_size();
}
inline void VirtualWallInfo::clear_virtual_walls_length() {
  _impl_.virtual_walls_length_.Clear();
}
inline int32_t VirtualWallInfo::_internal_virtual_walls_length(int index) const {
  return _impl_.virtual_walls_length_.Get(index);
}
inline int32_t VirtualWallInfo::virtual_walls_length(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.VirtualWallInfo.virtual_walls_length)
  return _internal_virtual_walls_length(index);
}
inline void VirtualWallInfo::set_virtual_walls_length(int index, int32_t value) {
  _impl_.virtual_walls_length_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.VirtualWallInfo.virtual_walls_length)
}
inline void VirtualWallInfo::_internal_add_virtual_walls_length(int32_t value) {
  _impl_.virtual_walls_length_.Add(value);
}
inline void VirtualWallInfo::add_virtual_walls_length(int32_t value) {
  _internal_add_virtual_walls_length(value);
  // @@protoc_insertion_point(field_add:LSLAM.VirtualWallInfo.virtual_walls_length)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VirtualWallInfo::_internal_virtual_walls_length() const {
  return _impl_.virtual_walls_length_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
VirtualWallInfo::virtual_walls_length() const {
  // @@protoc_insertion_point(field_list:LSLAM.VirtualWallInfo.virtual_walls_length)
  return _internal_virtual_walls_length();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VirtualWallInfo::_internal_mutable_virtual_walls_length() {
  return &_impl_.virtual_walls_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
VirtualWallInfo::mutable_virtual_walls_length() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.VirtualWallInfo.virtual_walls_length)
  return _internal_mutable_virtual_walls_length();
}

// repeated .LSLAM.Point virtual_walls_point = 2;
inline int VirtualWallInfo::_internal_virtual_walls_point_size() const {
  return _impl_.virtual_walls_point_.size();
}
inline int VirtualWallInfo::virtual_walls_point_size() const {
  return _internal_virtual_walls_point_size();
}
inline ::LSLAM::Point* VirtualWallInfo::mutable_virtual_walls_point(int index) {
  // @@protoc_insertion_point(field_mutable:LSLAM.VirtualWallInfo.virtual_walls_point)
  return _impl_.virtual_walls_point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >*
VirtualWallInfo::mutable_virtual_walls_point() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.VirtualWallInfo.virtual_walls_point)
  return &_impl_.virtual_walls_point_;
}
inline const ::LSLAM::Point& VirtualWallInfo::_internal_virtual_walls_point(int index) const {
  return _impl_.virtual_walls_point_.Get(index);
}
inline const ::LSLAM::Point& VirtualWallInfo::virtual_walls_point(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.VirtualWallInfo.virtual_walls_point)
  return _internal_virtual_walls_point(index);
}
inline ::LSLAM::Point* VirtualWallInfo::_internal_add_virtual_walls_point() {
  return _impl_.virtual_walls_point_.Add();
}
inline ::LSLAM::Point* VirtualWallInfo::add_virtual_walls_point() {
  ::LSLAM::Point* _add = _internal_add_virtual_walls_point();
  // @@protoc_insertion_point(field_add:LSLAM.VirtualWallInfo.virtual_walls_point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LSLAM::Point >&
VirtualWallInfo::virtual_walls_point() const {
  // @@protoc_insertion_point(field_list:LSLAM.VirtualWallInfo.virtual_walls_point)
  return _impl_.virtual_walls_point_;
}

// -------------------------------------------------------------------

// ConfigurationItems

// .LSLAM.MapInfo local_layer_info = 1;
inline bool ConfigurationItems::_internal_has_local_layer_info() const {
  return this != internal_default_instance() && _impl_.local_layer_info_ != nullptr;
}
inline bool ConfigurationItems::has_local_layer_info() const {
  return _internal_has_local_layer_info();
}
inline void ConfigurationItems::clear_local_layer_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.local_layer_info_ != nullptr) {
    delete _impl_.local_layer_info_;
  }
  _impl_.local_layer_info_ = nullptr;
}
inline const ::LSLAM::MapInfo& ConfigurationItems::_internal_local_layer_info() const {
  const ::LSLAM::MapInfo* p = _impl_.local_layer_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::MapInfo&>(
      ::LSLAM::_MapInfo_default_instance_);
}
inline const ::LSLAM::MapInfo& ConfigurationItems::local_layer_info() const {
  // @@protoc_insertion_point(field_get:LSLAM.ConfigurationItems.local_layer_info)
  return _internal_local_layer_info();
}
inline void ConfigurationItems::unsafe_arena_set_allocated_local_layer_info(
    ::LSLAM::MapInfo* local_layer_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.local_layer_info_);
  }
  _impl_.local_layer_info_ = local_layer_info;
  if (local_layer_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.ConfigurationItems.local_layer_info)
}
inline ::LSLAM::MapInfo* ConfigurationItems::release_local_layer_info() {
  
  ::LSLAM::MapInfo* temp = _impl_.local_layer_info_;
  _impl_.local_layer_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::MapInfo* ConfigurationItems::unsafe_arena_release_local_layer_info() {
  // @@protoc_insertion_point(field_release:LSLAM.ConfigurationItems.local_layer_info)
  
  ::LSLAM::MapInfo* temp = _impl_.local_layer_info_;
  _impl_.local_layer_info_ = nullptr;
  return temp;
}
inline ::LSLAM::MapInfo* ConfigurationItems::_internal_mutable_local_layer_info() {
  
  if (_impl_.local_layer_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::MapInfo>(GetArenaForAllocation());
    _impl_.local_layer_info_ = p;
  }
  return _impl_.local_layer_info_;
}
inline ::LSLAM::MapInfo* ConfigurationItems::mutable_local_layer_info() {
  ::LSLAM::MapInfo* _msg = _internal_mutable_local_layer_info();
  // @@protoc_insertion_point(field_mutable:LSLAM.ConfigurationItems.local_layer_info)
  return _msg;
}
inline void ConfigurationItems::set_allocated_local_layer_info(::LSLAM::MapInfo* local_layer_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.local_layer_info_;
  }
  if (local_layer_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_layer_info);
    if (message_arena != submessage_arena) {
      local_layer_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, local_layer_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.local_layer_info_ = local_layer_info;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.ConfigurationItems.local_layer_info)
}

// .LSLAM.ContinueCleanAtBreakPoint continue_clean_at_break_point_info = 2;
inline bool ConfigurationItems::_internal_has_continue_clean_at_break_point_info() const {
  return this != internal_default_instance() && _impl_.continue_clean_at_break_point_info_ != nullptr;
}
inline bool ConfigurationItems::has_continue_clean_at_break_point_info() const {
  return _internal_has_continue_clean_at_break_point_info();
}
inline void ConfigurationItems::clear_continue_clean_at_break_point_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.continue_clean_at_break_point_info_ != nullptr) {
    delete _impl_.continue_clean_at_break_point_info_;
  }
  _impl_.continue_clean_at_break_point_info_ = nullptr;
}
inline const ::LSLAM::ContinueCleanAtBreakPoint& ConfigurationItems::_internal_continue_clean_at_break_point_info() const {
  const ::LSLAM::ContinueCleanAtBreakPoint* p = _impl_.continue_clean_at_break_point_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::ContinueCleanAtBreakPoint&>(
      ::LSLAM::_ContinueCleanAtBreakPoint_default_instance_);
}
inline const ::LSLAM::ContinueCleanAtBreakPoint& ConfigurationItems::continue_clean_at_break_point_info() const {
  // @@protoc_insertion_point(field_get:LSLAM.ConfigurationItems.continue_clean_at_break_point_info)
  return _internal_continue_clean_at_break_point_info();
}
inline void ConfigurationItems::unsafe_arena_set_allocated_continue_clean_at_break_point_info(
    ::LSLAM::ContinueCleanAtBreakPoint* continue_clean_at_break_point_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.continue_clean_at_break_point_info_);
  }
  _impl_.continue_clean_at_break_point_info_ = continue_clean_at_break_point_info;
  if (continue_clean_at_break_point_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.ConfigurationItems.continue_clean_at_break_point_info)
}
inline ::LSLAM::ContinueCleanAtBreakPoint* ConfigurationItems::release_continue_clean_at_break_point_info() {
  
  ::LSLAM::ContinueCleanAtBreakPoint* temp = _impl_.continue_clean_at_break_point_info_;
  _impl_.continue_clean_at_break_point_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::ContinueCleanAtBreakPoint* ConfigurationItems::unsafe_arena_release_continue_clean_at_break_point_info() {
  // @@protoc_insertion_point(field_release:LSLAM.ConfigurationItems.continue_clean_at_break_point_info)
  
  ::LSLAM::ContinueCleanAtBreakPoint* temp = _impl_.continue_clean_at_break_point_info_;
  _impl_.continue_clean_at_break_point_info_ = nullptr;
  return temp;
}
inline ::LSLAM::ContinueCleanAtBreakPoint* ConfigurationItems::_internal_mutable_continue_clean_at_break_point_info() {
  
  if (_impl_.continue_clean_at_break_point_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::ContinueCleanAtBreakPoint>(GetArenaForAllocation());
    _impl_.continue_clean_at_break_point_info_ = p;
  }
  return _impl_.continue_clean_at_break_point_info_;
}
inline ::LSLAM::ContinueCleanAtBreakPoint* ConfigurationItems::mutable_continue_clean_at_break_point_info() {
  ::LSLAM::ContinueCleanAtBreakPoint* _msg = _internal_mutable_continue_clean_at_break_point_info();
  // @@protoc_insertion_point(field_mutable:LSLAM.ConfigurationItems.continue_clean_at_break_point_info)
  return _msg;
}
inline void ConfigurationItems::set_allocated_continue_clean_at_break_point_info(::LSLAM::ContinueCleanAtBreakPoint* continue_clean_at_break_point_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.continue_clean_at_break_point_info_;
  }
  if (continue_clean_at_break_point_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(continue_clean_at_break_point_info);
    if (message_arena != submessage_arena) {
      continue_clean_at_break_point_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, continue_clean_at_break_point_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.continue_clean_at_break_point_info_ = continue_clean_at_break_point_info;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.ConfigurationItems.continue_clean_at_break_point_info)
}

// bool complete_clean = 3;
inline void ConfigurationItems::clear_complete_clean() {
  _impl_.complete_clean_ = false;
}
inline bool ConfigurationItems::_internal_complete_clean() const {
  return _impl_.complete_clean_;
}
inline bool ConfigurationItems::complete_clean() const {
  // @@protoc_insertion_point(field_get:LSLAM.ConfigurationItems.complete_clean)
  return _internal_complete_clean();
}
inline void ConfigurationItems::_internal_set_complete_clean(bool value) {
  
  _impl_.complete_clean_ = value;
}
inline void ConfigurationItems::set_complete_clean(bool value) {
  _internal_set_complete_clean(value);
  // @@protoc_insertion_point(field_set:LSLAM.ConfigurationItems.complete_clean)
}

// bool is_adjusted_angle = 4;
inline void ConfigurationItems::clear_is_adjusted_angle() {
  _impl_.is_adjusted_angle_ = false;
}
inline bool ConfigurationItems::_internal_is_adjusted_angle() const {
  return _impl_.is_adjusted_angle_;
}
inline bool ConfigurationItems::is_adjusted_angle() const {
  // @@protoc_insertion_point(field_get:LSLAM.ConfigurationItems.is_adjusted_angle)
  return _internal_is_adjusted_angle();
}
inline void ConfigurationItems::_internal_set_is_adjusted_angle(bool value) {
  
  _impl_.is_adjusted_angle_ = value;
}
inline void ConfigurationItems::set_is_adjusted_angle(bool value) {
  _internal_set_is_adjusted_angle(value);
  // @@protoc_insertion_point(field_set:LSLAM.ConfigurationItems.is_adjusted_angle)
}

// -------------------------------------------------------------------

// MapInfoOfPrograms

// int32 map_id = 1;
inline void MapInfoOfPrograms::clear_map_id() {
  _impl_.map_id_ = 0;
}
inline int32_t MapInfoOfPrograms::_internal_map_id() const {
  return _impl_.map_id_;
}
inline int32_t MapInfoOfPrograms::map_id() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.map_id)
  return _internal_map_id();
}
inline void MapInfoOfPrograms::_internal_set_map_id(int32_t value) {
  
  _impl_.map_id_ = value;
}
inline void MapInfoOfPrograms::set_map_id(int32_t value) {
  _internal_set_map_id(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfoOfPrograms.map_id)
}

// .LSLAM.MyOccupancyGrid segment_map = 2;
inline bool MapInfoOfPrograms::_internal_has_segment_map() const {
  return this != internal_default_instance() && _impl_.segment_map_ != nullptr;
}
inline bool MapInfoOfPrograms::has_segment_map() const {
  return _internal_has_segment_map();
}
inline const ::LSLAM::MyOccupancyGrid& MapInfoOfPrograms::_internal_segment_map() const {
  const ::LSLAM::MyOccupancyGrid* p = _impl_.segment_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::MyOccupancyGrid&>(
      ::LSLAM::_MyOccupancyGrid_default_instance_);
}
inline const ::LSLAM::MyOccupancyGrid& MapInfoOfPrograms::segment_map() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.segment_map)
  return _internal_segment_map();
}
inline void MapInfoOfPrograms::unsafe_arena_set_allocated_segment_map(
    ::LSLAM::MyOccupancyGrid* segment_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segment_map_);
  }
  _impl_.segment_map_ = segment_map;
  if (segment_map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.MapInfoOfPrograms.segment_map)
}
inline ::LSLAM::MyOccupancyGrid* MapInfoOfPrograms::release_segment_map() {
  
  ::LSLAM::MyOccupancyGrid* temp = _impl_.segment_map_;
  _impl_.segment_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::MyOccupancyGrid* MapInfoOfPrograms::unsafe_arena_release_segment_map() {
  // @@protoc_insertion_point(field_release:LSLAM.MapInfoOfPrograms.segment_map)
  
  ::LSLAM::MyOccupancyGrid* temp = _impl_.segment_map_;
  _impl_.segment_map_ = nullptr;
  return temp;
}
inline ::LSLAM::MyOccupancyGrid* MapInfoOfPrograms::_internal_mutable_segment_map() {
  
  if (_impl_.segment_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::MyOccupancyGrid>(GetArenaForAllocation());
    _impl_.segment_map_ = p;
  }
  return _impl_.segment_map_;
}
inline ::LSLAM::MyOccupancyGrid* MapInfoOfPrograms::mutable_segment_map() {
  ::LSLAM::MyOccupancyGrid* _msg = _internal_mutable_segment_map();
  // @@protoc_insertion_point(field_mutable:LSLAM.MapInfoOfPrograms.segment_map)
  return _msg;
}
inline void MapInfoOfPrograms::set_allocated_segment_map(::LSLAM::MyOccupancyGrid* segment_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segment_map_);
  }
  if (segment_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segment_map));
    if (message_arena != submessage_arena) {
      segment_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment_map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.segment_map_ = segment_map;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.MapInfoOfPrograms.segment_map)
}

// bytes pbStream_file_name = 3;
inline void MapInfoOfPrograms::clear_pbstream_file_name() {
  _impl_.pbstream_file_name_.ClearToEmpty();
}
inline const std::string& MapInfoOfPrograms::pbstream_file_name() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.pbStream_file_name)
  return _internal_pbstream_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapInfoOfPrograms::set_pbstream_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pbstream_file_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LSLAM.MapInfoOfPrograms.pbStream_file_name)
}
inline std::string* MapInfoOfPrograms::mutable_pbstream_file_name() {
  std::string* _s = _internal_mutable_pbstream_file_name();
  // @@protoc_insertion_point(field_mutable:LSLAM.MapInfoOfPrograms.pbStream_file_name)
  return _s;
}
inline const std::string& MapInfoOfPrograms::_internal_pbstream_file_name() const {
  return _impl_.pbstream_file_name_.Get();
}
inline void MapInfoOfPrograms::_internal_set_pbstream_file_name(const std::string& value) {
  
  _impl_.pbstream_file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MapInfoOfPrograms::_internal_mutable_pbstream_file_name() {
  
  return _impl_.pbstream_file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MapInfoOfPrograms::release_pbstream_file_name() {
  // @@protoc_insertion_point(field_release:LSLAM.MapInfoOfPrograms.pbStream_file_name)
  return _impl_.pbstream_file_name_.Release();
}
inline void MapInfoOfPrograms::set_allocated_pbstream_file_name(std::string* pbstream_file_name) {
  if (pbstream_file_name != nullptr) {
    
  } else {
    
  }
  _impl_.pbstream_file_name_.SetAllocated(pbstream_file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pbstream_file_name_.IsDefault()) {
    _impl_.pbstream_file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LSLAM.MapInfoOfPrograms.pbStream_file_name)
}

// double map_rotation_angle = 4;
inline void MapInfoOfPrograms::clear_map_rotation_angle() {
  _impl_.map_rotation_angle_ = 0;
}
inline double MapInfoOfPrograms::_internal_map_rotation_angle() const {
  return _impl_.map_rotation_angle_;
}
inline double MapInfoOfPrograms::map_rotation_angle() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.map_rotation_angle)
  return _internal_map_rotation_angle();
}
inline void MapInfoOfPrograms::_internal_set_map_rotation_angle(double value) {
  
  _impl_.map_rotation_angle_ = value;
}
inline void MapInfoOfPrograms::set_map_rotation_angle(double value) {
  _internal_set_map_rotation_angle(value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfoOfPrograms.map_rotation_angle)
}

// .LSLAM.DivisionLineInfo division_line_info = 5;
inline bool MapInfoOfPrograms::_internal_has_division_line_info() const {
  return this != internal_default_instance() && _impl_.division_line_info_ != nullptr;
}
inline bool MapInfoOfPrograms::has_division_line_info() const {
  return _internal_has_division_line_info();
}
inline void MapInfoOfPrograms::clear_division_line_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.division_line_info_ != nullptr) {
    delete _impl_.division_line_info_;
  }
  _impl_.division_line_info_ = nullptr;
}
inline const ::LSLAM::DivisionLineInfo& MapInfoOfPrograms::_internal_division_line_info() const {
  const ::LSLAM::DivisionLineInfo* p = _impl_.division_line_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::DivisionLineInfo&>(
      ::LSLAM::_DivisionLineInfo_default_instance_);
}
inline const ::LSLAM::DivisionLineInfo& MapInfoOfPrograms::division_line_info() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.division_line_info)
  return _internal_division_line_info();
}
inline void MapInfoOfPrograms::unsafe_arena_set_allocated_division_line_info(
    ::LSLAM::DivisionLineInfo* division_line_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.division_line_info_);
  }
  _impl_.division_line_info_ = division_line_info;
  if (division_line_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.MapInfoOfPrograms.division_line_info)
}
inline ::LSLAM::DivisionLineInfo* MapInfoOfPrograms::release_division_line_info() {
  
  ::LSLAM::DivisionLineInfo* temp = _impl_.division_line_info_;
  _impl_.division_line_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::DivisionLineInfo* MapInfoOfPrograms::unsafe_arena_release_division_line_info() {
  // @@protoc_insertion_point(field_release:LSLAM.MapInfoOfPrograms.division_line_info)
  
  ::LSLAM::DivisionLineInfo* temp = _impl_.division_line_info_;
  _impl_.division_line_info_ = nullptr;
  return temp;
}
inline ::LSLAM::DivisionLineInfo* MapInfoOfPrograms::_internal_mutable_division_line_info() {
  
  if (_impl_.division_line_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::DivisionLineInfo>(GetArenaForAllocation());
    _impl_.division_line_info_ = p;
  }
  return _impl_.division_line_info_;
}
inline ::LSLAM::DivisionLineInfo* MapInfoOfPrograms::mutable_division_line_info() {
  ::LSLAM::DivisionLineInfo* _msg = _internal_mutable_division_line_info();
  // @@protoc_insertion_point(field_mutable:LSLAM.MapInfoOfPrograms.division_line_info)
  return _msg;
}
inline void MapInfoOfPrograms::set_allocated_division_line_info(::LSLAM::DivisionLineInfo* division_line_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.division_line_info_;
  }
  if (division_line_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(division_line_info);
    if (message_arena != submessage_arena) {
      division_line_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, division_line_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.division_line_info_ = division_line_info;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.MapInfoOfPrograms.division_line_info)
}

// .LSLAM.VirtualWallInfo virtual_wall_info = 6;
inline bool MapInfoOfPrograms::_internal_has_virtual_wall_info() const {
  return this != internal_default_instance() && _impl_.virtual_wall_info_ != nullptr;
}
inline bool MapInfoOfPrograms::has_virtual_wall_info() const {
  return _internal_has_virtual_wall_info();
}
inline void MapInfoOfPrograms::clear_virtual_wall_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.virtual_wall_info_ != nullptr) {
    delete _impl_.virtual_wall_info_;
  }
  _impl_.virtual_wall_info_ = nullptr;
}
inline const ::LSLAM::VirtualWallInfo& MapInfoOfPrograms::_internal_virtual_wall_info() const {
  const ::LSLAM::VirtualWallInfo* p = _impl_.virtual_wall_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::LSLAM::VirtualWallInfo&>(
      ::LSLAM::_VirtualWallInfo_default_instance_);
}
inline const ::LSLAM::VirtualWallInfo& MapInfoOfPrograms::virtual_wall_info() const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.virtual_wall_info)
  return _internal_virtual_wall_info();
}
inline void MapInfoOfPrograms::unsafe_arena_set_allocated_virtual_wall_info(
    ::LSLAM::VirtualWallInfo* virtual_wall_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.virtual_wall_info_);
  }
  _impl_.virtual_wall_info_ = virtual_wall_info;
  if (virtual_wall_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LSLAM.MapInfoOfPrograms.virtual_wall_info)
}
inline ::LSLAM::VirtualWallInfo* MapInfoOfPrograms::release_virtual_wall_info() {
  
  ::LSLAM::VirtualWallInfo* temp = _impl_.virtual_wall_info_;
  _impl_.virtual_wall_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LSLAM::VirtualWallInfo* MapInfoOfPrograms::unsafe_arena_release_virtual_wall_info() {
  // @@protoc_insertion_point(field_release:LSLAM.MapInfoOfPrograms.virtual_wall_info)
  
  ::LSLAM::VirtualWallInfo* temp = _impl_.virtual_wall_info_;
  _impl_.virtual_wall_info_ = nullptr;
  return temp;
}
inline ::LSLAM::VirtualWallInfo* MapInfoOfPrograms::_internal_mutable_virtual_wall_info() {
  
  if (_impl_.virtual_wall_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::LSLAM::VirtualWallInfo>(GetArenaForAllocation());
    _impl_.virtual_wall_info_ = p;
  }
  return _impl_.virtual_wall_info_;
}
inline ::LSLAM::VirtualWallInfo* MapInfoOfPrograms::mutable_virtual_wall_info() {
  ::LSLAM::VirtualWallInfo* _msg = _internal_mutable_virtual_wall_info();
  // @@protoc_insertion_point(field_mutable:LSLAM.MapInfoOfPrograms.virtual_wall_info)
  return _msg;
}
inline void MapInfoOfPrograms::set_allocated_virtual_wall_info(::LSLAM::VirtualWallInfo* virtual_wall_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.virtual_wall_info_;
  }
  if (virtual_wall_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(virtual_wall_info);
    if (message_arena != submessage_arena) {
      virtual_wall_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_wall_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.virtual_wall_info_ = virtual_wall_info;
  // @@protoc_insertion_point(field_set_allocated:LSLAM.MapInfoOfPrograms.virtual_wall_info)
}

// repeated uint32 rooms_clean_way = 7;
inline int MapInfoOfPrograms::_internal_rooms_clean_way_size() const {
  return _impl_.rooms_clean_way_.size();
}
inline int MapInfoOfPrograms::rooms_clean_way_size() const {
  return _internal_rooms_clean_way_size();
}
inline void MapInfoOfPrograms::clear_rooms_clean_way() {
  _impl_.rooms_clean_way_.Clear();
}
inline uint32_t MapInfoOfPrograms::_internal_rooms_clean_way(int index) const {
  return _impl_.rooms_clean_way_.Get(index);
}
inline uint32_t MapInfoOfPrograms::rooms_clean_way(int index) const {
  // @@protoc_insertion_point(field_get:LSLAM.MapInfoOfPrograms.rooms_clean_way)
  return _internal_rooms_clean_way(index);
}
inline void MapInfoOfPrograms::set_rooms_clean_way(int index, uint32_t value) {
  _impl_.rooms_clean_way_.Set(index, value);
  // @@protoc_insertion_point(field_set:LSLAM.MapInfoOfPrograms.rooms_clean_way)
}
inline void MapInfoOfPrograms::_internal_add_rooms_clean_way(uint32_t value) {
  _impl_.rooms_clean_way_.Add(value);
}
inline void MapInfoOfPrograms::add_rooms_clean_way(uint32_t value) {
  _internal_add_rooms_clean_way(value);
  // @@protoc_insertion_point(field_add:LSLAM.MapInfoOfPrograms.rooms_clean_way)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MapInfoOfPrograms::_internal_rooms_clean_way() const {
  return _impl_.rooms_clean_way_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MapInfoOfPrograms::rooms_clean_way() const {
  // @@protoc_insertion_point(field_list:LSLAM.MapInfoOfPrograms.rooms_clean_way)
  return _internal_rooms_clean_way();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MapInfoOfPrograms::_internal_mutable_rooms_clean_way() {
  return &_impl_.rooms_clean_way_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MapInfoOfPrograms::mutable_rooms_clean_way() {
  // @@protoc_insertion_point(field_mutable_list:LSLAM.MapInfoOfPrograms.rooms_clean_way)
  return _internal_mutable_rooms_clean_way();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace LSLAM

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::LSLAM::SaveAndReadOptions> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LSLAM::SaveAndReadOptions>() {
  return ::LSLAM::SaveAndReadOptions_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ConfigurationItems_2eproto
